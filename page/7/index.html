<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-07-30T09:42:33.000Z" title="2021/7/30 下午5:42:33">2021-07-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-30T09:42:33.000Z" title="2021/7/30 下午5:42:33">2021-07-30</time></span><span class="level-item">19 minutes read (About 2805 words)</span></div></div><div class="content"><p>[toc]</p>
<h3 id="三、垃圾回收器的选择"><a href="#三、垃圾回收器的选择" class="headerlink" title="三、垃圾回收器的选择"></a>三、垃圾回收器的选择</h3><p>1.吞吐量还是响应时间</p>
<p>首先引入两个概念：吞吐量和延迟时间</p>
<p>吞吐量 &#x3D; CPU在用户应用程序运行的时间 &#x2F; (CPU在用户应用程序运行的时间 + CPU垃圾回收的时间)</p>
<p>延迟时间 &#x3D; 平均每次的GC的耗时</p>
<p>通常，吞吐优先还是响应优先这个在JVM中是一个两难之选。堆内存增大，GC一次能处理的数量变大，吞吐量大；但是GC一次的时间会变长，导致后面排队的线程等待时间变长；相反，如果堆内存小，GC一次时间短，排队等待的线程等待时间变短，延迟减少，但一次请求的数量变小(并不绝对符合)，无法同时兼顾。吞吐优先VS响应优先，是JVM调优过程中需要权衡的核心问题。</p>
<p>2.垃圾回收器设计上的考量</p>
<p>垃圾回收器的底层实现机制非常复杂，但是设计者的设计目标无外乎以下几条：</p>
<p>JVM在GC时不允许一边垃圾回收，一边还创建新对象(就像不能一边打扫卫生，还在一边扔垃圾)。</p>
<p>基于第一条GC时需要一段Stop the world的暂停时间，而STW会造成系统短暂停顿不能处理任何请求；</p>
<p>新生代收集频率高，性能优先，常用复制算法；老年代频次低，空间敏感，避免复制方式。</p>
<p>所有垃圾回收器的设计目标都是要让GC频率更少，时间更短，减少GC对系统影响！</p>
<p>3.CMS和G1</p>
<p>目前主流的垃圾回收器配置是新生代采用ParNew，老年代采用CMS组合的方式，或者是完全采用G1回收器，从未来的趋势来看，G1是官方维护和更为推崇的垃圾回收器。<br><img src="/../../images/e6cefe4eea2841a83444256f617387f1.png" alt="e6cefe4eea2841a83444256f617387f1.png"></p>
<p>业务系统，延迟敏感的推荐CMS；大内存服务，要求高吞吐的，采用G1回收器！下面单独就两款回收器的工作机制和适用场景进行一下说明：</p>
<h3 id="四、CMS回收器"><a href="#四、CMS回收器" class="headerlink" title="四、CMS回收器"></a>四、CMS回收器</h3><p>1.CMS垃圾回收器的工作机制</p>
<p>CMS主要是针对老年代的回收器，新生代的采用ParNew回收器，工作流程就是上文提到的经典复制算法，在三块区中进行流转回收，只不过采用多线程并行的方式加快了MinorGC速度。老年代是标记-清除，默认会在一次FullGC算法后做整理算法，清理内存碎片。</p>
<p><img src="/../../images/1773c842a1a29791cdb3b153d6691a53.png" alt="1773c842a1a29791cdb3b153d6691a53.png"></p>
<p>优点：并发收集、主打“低延时” 。在最耗时的两个阶段都没有发生STW，而需要STW的阶段都以很快速度完成。</p>
<p>缺点：1、消耗CPU；2、浮动垃圾；3、内存碎片</p>
<p>适用场景：重视服务器响应速度，要求系统停顿时间最短。</p>
<p>2.登录系统的压测前配置</p>
<p>调优场景以之前的登录系统为例，按照之前容量估算套路，引入性能压测环节，测试同学对登录接口压至1s内60M的对象生成速度，假设只配置了4C8G的机器配置，采用ParNew+CMS的组合回收器，堆内存分配4g，线程栈默认1M，初始配置如下：</p>
<p>-Xms4g –Xmx4g –Xmn1536m -Xss1m -XX:+UseConcMarkSweepGC<br>划分Eden和Surviror大小，如按照默认-XX:SurvivorRatio&#x3D;8 分配规则，基于CMS的JVM运行模型粗略计算如下<br><img src="/../../images/8e9ff3a637d9a56a9ca6c25750a21d83.png" alt="8e9ff3a637d9a56a9ca6c25750a21d83.png"></p>
<p>基本上，可以看到20S后Eden区就满了，此时再运行的时候对象已经无法分配，会触发MinorGC，假设在这次GC后S1装入100M，马上过20S又会触发一次MinorGC，多出来的100M存活对象再加上S1区已经存在的100M，已无法顺利放入到S2区，此时就会触发JVM的动态年龄机制，将一批100M左右的对象推到老年代保存，持续运行一段时间，当老年代也满了的情况下，系统可能不到一小时候就会触发一次FullGC。</p>
<p>3.基于CMS的调优思路</p>
<p>首先采取上调Survior区容量策略：新生代划2g，维持E:S1:S2&#x3D;8:1:1，此时Eden&#x3D;1.6G，S&#x3D;200M。60M&#x2F;S速率，运行25s左右会触发一次MinorGC，回收的对象需要超过200M才触发进入老年代，对象进入老年代的几率大大降低，短命对象在几次minorGC后就释放掉了。此时的JVM配置如下：</p>
<p> -Xms4g –Xmx4g –Xmn2g -Xss1m -XX:SurvivorRatio&#x3D;8  -XX:+UseConcMarkSweepGC<br>然后再下调晋升老年代年龄，默认为15——当躲过15次MinorGC后，可进入老年代；可适当调低改值为5~10，让长寿对象应尽快去往属于它的地方，而不是在新生代来回折腾，占用空间，这样可以优化每次MinorGC的耗时。</p>
<p> -Xms4g –Xmx4g –Xmn2g -Xss1m -XX:SurvivorRatio&#x3D;8  -XX:MaxTenuringThreshold&#x3D;15 -XX:+UseConcMarkSweepGC<br>再选择性的去优化老年代参数：比如老年代默认在标记清除以后会做整理，还可以在CMS的增加GC频次还是增加GC时长上做些取舍，如下是响应优先的参数调优：<br><img src="/../../images/ac9b9b654c90de311c243c35d642711d.png" alt="ac9b9b654c90de311c243c35d642711d.png"></p>
<p>那么最终我们可以得到一个比较适用于自身业务系统的、基于CMS回收器的JVM参数：</p>
<p><code> -Xms4g –Xmx4g –Xmn2g -Xss1m -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=5 -XX:+UseConcMarkSweepGC  -XX:CMSInitiatingOccupancyFraction=70  -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch</code></p>
<h3 id="五、G1垃圾回收器"><a href="#五、G1垃圾回收器" class="headerlink" title="五、G1垃圾回收器"></a>五、G1垃圾回收器</h3><p>1.CMS回收器的不足</p>
<p>服务启动前就需要指定新生代和老年代大小，启动了就不能动态调整了！</p>
<p>新生代和老年代都必须<strong>分配独立且连续的一整块内存空间</strong>！</p>
<p>所有针对老年代的操作必须扫描整个老年代空间，相同的老年代对象，堆空间越大扫描耗时越长！</p>
<p>2.G1回收器的设计思路</p>
<p>G1回收天然的适用于大内存服务器，首先G1将堆内存空间拆分为多个大小相等的Region块，Region的个数默认2048个，配置4g堆内存，每个region的大小就为2M。Region动态的属于老年代或者新生代，上一秒还是分配成新生代，经过回收以后空出来，下一秒有可能被分为老年代区。</p>
<p>在G1回收器这里已经不需要再提前设置新生代和老年代的大小，但是新生代仍区分Eden和Survivor区。大大降低了JVM参数的调优复杂度，<strong>只需配置-XX:MaxGCPauseMillis&#x3D;n(ms)，设置最大GC停顿时间</strong>，剩下的交给G1回收器。G1会自动追踪每个region可以回收的大小和预估的时间，最后在真正垃圾回收的时候，尽量把垃圾回收控制在设置的时间范围内，在有限的时间内回收更多的对象。</p>
<p><img src="/../../images/e032a5b52480e7702acbce7757990f64.png" alt="e032a5b52480e7702acbce7757990f64.png"></p>
<p>所以综合来看，**G1主打高吞吐，特别适用多核、大内存服务(如Kafka&#x2F;ElasticSearch)**。</p>
<p>3.G1的工作机制</p>
<p>新生代回收：对象优先分配Eden的Region，JVM不停给新生代分配更多的region，直到新生代占堆总大小的60%，触发MinorGC。</p>
<p>进入老年代对象的条件不变：达到晋升年龄；动态年龄判定；大对象等</p>
<p>Mix混合回收：当老年代的Region占堆内存的45%以后，触发MixGC，会分阶段多次混合回收新生代和老年代的Region。</p>
<p>Full GC：MixGC时发现无可用的新Region块了来分配复制的存活对象，立马触发FullGC，停止系统程序，单线程标记、清除和整理，空闲出一批Region，过程很缓慢。</p>
<p><img src="/../../images/7c735a8c1064187bdd507687bb91dd42.png" alt="7c735a8c1064187bdd507687bb91dd42.png"></p>
<p>4.G1的核心调优参数</p>
<p>G1收集器自身已经有一套预测和调整机制了，因此我们首先的选择是相信它，即调整-XX:MaxGCPauseMillis&#x3D;N参数，这也符合G1的目的——让GC调优尽量简单！同时也不要自己显式设置新生代的大小(用-Xmn或-XX:NewRatio参数)，如果人为干预新生代的大小，会导致目标时间这个参数失效。</p>
<p>针对-XX:MaxGCPauseMillis来说，参数的设置带有明显的倾向性：调低↓：延迟更低，但MinorGC频繁，MixGC回收老年代区减少，增大Full GC的风险。调高↑：单次回收更多的对象，但系统整体响应时间也会被拉长。</p>
<p>针对InitiatingHeapOccupancyPercent来说，调参大小的效果也不一样：调低↓：更早触发MixGC，浪费cpu。调高↑：堆积过多代回收region，增大FullGC的风险。</p>
<p>5.G1调优在Kafka集群的应用</p>
<p>比如日志平台的Kafka集群每秒写入300M数据至内存，broker节点的配置为16C32G，假设堆内存给16g，新生代分配8g，每秒产生对象假设100M左右，差不多一分多钟就会产生一次MinorGC，CMS机制下需要等Eden满了以后，才一次性清理大约8g左右的垃圾对象，差不多会有秒级的STW停顿，如果是老年代的GC延时长则会有十秒级的STW停顿。</p>
<p><code>-Xms16g –Xmx16g –Xmn8g -Xss1m -XX:+UseConcMarkSweepGC</code><br>假设采用了G1回收器，适当调低最大耗时，设定MaxGCPauseMillis为100ms，并且适当调低堆使用率阈值，G1就会在允许的响应时间内自动的、多批次的去进行垃圾回收，保证每个STW的时间都不会太长。</p>
<p><code> -Xms16g -Xmx16g -Xss1m -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:InitiatingHeapOccupancyPercent=40</code><br>所以线上的kafka和ES集群，动辄32~64g的大内存，如果让CMS去整块回收十多G乃至几十G的垃圾对象，对于系统而言绝对不利！一般来说，堆内存超过8g的大内存服务器，都更推荐使用G1回收器！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-07-28T09:50:03.000Z" title="2021/7/28 下午5:50:03">2021-07-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-28T09:50:03.000Z" title="2021/7/28 下午5:50:03">2021-07-28</time></span><span class="level-item">an hour read (About 9168 words)</span></div></div><div class="content"><p>[toc]</p>
<p>1、自我介绍，项目介绍，遇到的难点？产生原因？如何解决？</p>
<h3 id="2、HashMap1-8与1-7区别？ConcurrentHashMap实现原理-？"><a href="#2、HashMap1-8与1-7区别？ConcurrentHashMap实现原理-？" class="headerlink" title="2、HashMap1.8与1.7区别？ConcurrentHashMap实现原理 ？"></a>2、HashMap1.8与1.7区别？ConcurrentHashMap实现原理 ？</h3><p>HashMap</p>
<p><strong>组成差别</strong><br>1.7:数组+单链表<br>1.8:数据+单链表+红黑树<br><strong>链表存放差别：</strong><br>出现哈希冲突时：<br>1.7直接把数据存放在链表，再无其它操作<br>1.8把数据存放在链表，链表长度超过8就转红黑树<br><strong>扩容差别：</strong><br>1.7扩容条件是数组大于阈值且存在哈希冲突时扩容<br>1.8扩容条件是数组长度大于阈值或链表转红黑树时且数组元素小于64时扩容<br><strong>插值方法：</strong><br>1.7用的是头插法，(在链表头部插入新值)，弊端：可能造成逆序死循环<br>1.8用的是尾插法可避免上面的问题</p>
<p>ConcurrentHashMap采用了非常精妙的”分段锁”策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>;</span><br><span class="line"><span class="comment">// 一个Segment维护着一个HashEntry数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> </span><br><span class="line">  <span class="comment">//MAX_SEGMENTS 为1&lt;&lt;16=65536，也就是最大并发数为65536</span></span><br><span class="line">  <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">	<span class="comment">//2的sshif次方等于ssize，例:ssize=16,sshift=4;ssize=32,sshif=5</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//ssize 为segments数组长度，根据concurrentLevel计算得出</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line"> 	 ++sshift;</span><br><span class="line">  	ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。比如：默认情况下concurrentLevel是16，则ssize为16；若concurrentLevel为14，ssize为16；若concurrentLevel为17，则ssize为32。</strong></p>
<h3 id="3、jvm类加载器，自定义类加载器，双亲委派机制，优缺点，tomcat类加载机制"><a href="#3、jvm类加载器，自定义类加载器，双亲委派机制，优缺点，tomcat类加载机制" class="headerlink" title="3、jvm类加载器，自定义类加载器，双亲委派机制，优缺点，tomcat类加载机制?"></a>3、jvm类加载器，自定义类加载器，双亲委派机制，优缺点，tomcat类加载机制?</h3><p>避免类的重复加载， 确保一个类的全局唯一性Java 类随着它的类加载器一起具备了一种带<strong>有优先级的层级关系</strong>， 通过这种层级关系可以避免类的重复加载， 当父亲已经加载了该类时， 就没有必要子ClassLoader 再加载一次</p>
<p>Tomcat各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AppClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二者同时继承了 URLClassLoader ，继承关系如下：</p>
<p>Tomcat 自己实现了自己的类加载器 WebAppClassLoader。</p>
<ol>
<li>先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。</li>
<li>如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。</li>
<li>如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 AppClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。</li>
<li>如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。</li>
<li><strong>加载依然失败，才使用 AppClassLoader 继续加载。</strong></li>
<li>都没有加载成功的话，抛出异常。</li>
</ol>
<p>总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。</p>
<ul>
<li>保证了基础类不会被同时加载。</li>
<li>又保证了在同一个 Tomcat 下不同 web 之间的 class 是相互隔离的。</li>
</ul>
<h3 id="5、cms收集器过程，g1收集器原理，怎么实现可预测停顿的，region的大小结构？"><a href="#5、cms收集器过程，g1收集器原理，怎么实现可预测停顿的，region的大小结构？" class="headerlink" title="5、cms收集器过程，g1收集器原理，怎么实现可预测停顿的，region的大小结构？"></a>5、cms收集器过程，g1收集器原理，怎么实现可预测停顿的，region的大小结构？</h3><p>CMS 处理过程有七个步骤：</p>
<ol>
<li>初始标记(CMS-initial-mark) ,会导致stw;</li>
<li>并发标记(CMS-concurrent-mark)，与用户线程同时运行；</li>
<li>预清理（CMS-concurrent-preclean），与用户线程同时运行；</li>
<li>可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；</li>
<li>重新标记(CMS-remark) ，会导致swt；</li>
<li>并发清除(CMS-concurrent-sweep)，与用户线程同时运行；</li>
<li>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行； 其运行流程图如下所示：</li>
</ol>
<h3 id="6、内存溢出，内存泄漏遇到过吗？什么场景产生的，怎么解决的？"><a href="#6、内存溢出，内存泄漏遇到过吗？什么场景产生的，怎么解决的？" class="headerlink" title="6、内存溢出，内存泄漏遇到过吗？什么场景产生的，怎么解决的？"></a>6、内存溢出，内存泄漏遇到过吗？什么场景产生的，怎么解决的？</h3><p>引起内存溢出的原因有很多种，常见的有以下几种：<br>　　1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；<br>　　2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；<br>　　3.代码中存在死循环或循环产生过多重复的对象实体；<br>　　4.使用的第三方软件中的BUG；<br>　　5.启动参数内存值设定的过小；</p>
<p>【情况一】：<br><code>java.lang.OutOfMemoryError:Javaheapspace</code>：这种是java堆内存不够，一个原因是真不够（如递归的层数太多等），另一个原因是程序中有死循环；<br>　　如果是java堆内存不够的话，可以通过调整JVM下面的配置来解决：<br>　　-Xms3062m<br>　　-Xmx3062m</p>
<p>【情况二】<br><code>java.lang.OutOfMemoryError:GCoverheadlimitexceeded</code><br>　　【解释】：JDK6新增错误类型，当GC为释放很小空间占用大量时间时抛出；一般是因为堆太小，导致异常的原因，没有足够的内存。<br>　　【解决方案】：<br>　　1、查看系统是否有使用大内存的代码或死循环；<br>　　2、通过添加JVM配置，来限制使用内存：<br>　　-XX:-UseGCOverheadLimit</p>
<p>【情况五】：<br>　　java.lang.OutOfMemoryError:unabletocreatenewnativethread<br>　　【原因】：Stack空间不足以创建额外的线程，要么是创建的线程过多，要么是Stack空间确实小了。<br>　　【解决】：由于JVM没有提供参数设置总的stack空间大小，但可以设置单个线程栈的大小；而系统的用户空间一共是3G，<br>　　　　　　　除了Text&#x2F;Data&#x2F;BSS&#x2F;MemoryMapping几个段之外，Heap和Stack空间的总量有限，是此消彼长的。因此遇到这个错误，<br>　　　　　　  可以通过两个途径解决：1.通过-Xss启动参数减少单个线程栈大小，这样便能开更多线程（当然不能太小，太小会出现StackOverflowError）；<br>　　　　　　　　　　　　　　　　　　2.通过-Xms-Xmx两参数减少Heap大小，将内存让给Stack（前提是保证Heap空间够用）。</p>
<p>【情况六】：<br>　　java.lang.StackOverflowError<br>　　【原因】：这也内存溢出错误的一种，即线程栈的溢出，要么是方法调用层次过多（比如存在无限递归调用），要么是线程栈太小。<br>　　【解决】：优化程序设计，减少方法调用层次；调整-Xss参数增加线程栈大小</p>
<p>Java都采用了“可达性分析”算法来进行内存回收，原理是：会有几个引用作为root节点，对于任意对象来说，如果从root层层遍历，如果找不到对于他的引用链，那么这个对象就被标记为无用，就会在gc时被销毁。</p>
<h3 id="7、volatile的原理？synchronized和重入锁实现原理以及区别？"><a href="#7、volatile的原理？synchronized和重入锁实现原理以及区别？" class="headerlink" title="7、volatile的原理？synchronized和重入锁实现原理以及区别？"></a>7、volatile的原理？synchronized和重入锁实现原理以及区别？</h3><p>volatile保证<strong>可见性</strong>、<strong>防止指令重排</strong>，不保证<strong>原子性</strong>。在JVM底层volatile是采用“内存屏障”来实现的。</p>
<h3 id="8、redis字符串实现，sds和c字符串区别？"><a href="#8、redis字符串实现，sds和c字符串区别？" class="headerlink" title="8、redis字符串实现，sds和c字符串区别？"></a>8、redis字符串实现，sds和c字符串区别？</h3><p><strong>1、在求长度的时候</strong>   C字符串 O(n)  SDS只需要访问len属性即可 时间复杂度O(1).<br><strong>2、缓冲区溢出问题</strong>   C字符串会修改与它相邻 SDS 这里会先根据空间是否够用,实际空间长度为 free + len + 1<br><strong>3、字符串内存分配</strong>   SDS 内部使用两种机制 惰性空间释放跟空间预分配<br>空间预分配：这里SDS&lt;1M的时候是 free &#x3D; len,若SDS&#x3D;6byte 则空间为 6byte + 6byte + 1byte<br>大于1M的时候free &#x3D; 1M, 若SDS长度为60M 则实际空间为 60M + 1M + 1byte<br>惰性空间释放  不立即使用内存重新分配来回收缩短后的字节，而是通过free记录起来，以供后续使用，SDS也提供了相应的API，防止惰性空间导致内存浪费。</p>
<h3 id="9、redis集群，为什么是16384个slot？选举过程，会有脑裂问题么，raft算法，优缺点？"><a href="#9、redis集群，为什么是16384个slot？选举过程，会有脑裂问题么，raft算法，优缺点？" class="headerlink" title="9、redis集群，为什么是16384个slot？选举过程，会有脑裂问题么，raft算法，优缺点？"></a>9、redis集群，为什么是16384个slot？选举过程，会有脑裂问题么，raft算法，优缺点？</h3><p>(1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。<br>如上所述，在消息头中，最占空间的是<code>myslots[CLUSTER_SLOTS/8]</code>。<br>当槽位为65536时，这块的大小是:<br><code>65536÷8÷1024=8kb</code><br>因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。<br>(2)redis的集群主节点数量基本不可能超过1000个。<br>如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。<br>那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。<br>(3)槽位越小，节点少的情况下，压缩比高<br>Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots &#x2F; N很高的话(N表示节点数)，bitmap的压缩率就很低。<br>如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。</p>
<h3 id="10、redis有序集合怎么实现的，跳表是什么？往跳表添加一个元素的过程获取分数的时间复杂度，为什么不用红黑树，红黑树有什么特点，左旋右旋操作？"><a href="#10、redis有序集合怎么实现的，跳表是什么？往跳表添加一个元素的过程获取分数的时间复杂度，为什么不用红黑树，红黑树有什么特点，左旋右旋操作？" class="headerlink" title="10、redis有序集合怎么实现的，跳表是什么？往跳表添加一个元素的过程获取分数的时间复杂度，为什么不用红黑树，红黑树有什么特点，左旋右旋操作？"></a>10、redis有序集合怎么实现的，跳表是什么？往跳表添加一个元素的过程获取分数的时间复杂度，为什么不用红黑树，红黑树有什么特点，左旋右旋操作？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Redis使用了两种数据结构来共同实现有序集合</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">     <span class="comment">//跳跃表</span></span><br><span class="line">     zskiplist *zsl;		<span class="comment">// 范围操作 查找O(logN)</span></span><br><span class="line">     <span class="comment">//字典</span></span><br><span class="line">     dict *dice;				<span class="comment">// 无序保存元素 查找O(1) </span></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>当有序集合对象同时满足以下两个条件时，对象使用 <code>ziplist</code> 编码：<br>1、保存的元素数量小于128；<br>2、保存的所有元素长度都小于64字节。</p>
<p>不能满足上面两个条件的使用 <code>skiplist</code> 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</p>
<p>假设我们要插入的结点是10，首先我们按照跳表查找结点的方法，找到待插入结点的前置结点（仅小于待插入结点）：</p>
<p><img src="/../../images/37c930c77206489399169c56786dd606.png" alt="img"></p>
<p>接下来，按照一般链表的插入方式，把结点10插入到结点9的下一个位置：</p>
<p><img src="/../../images/9637fdae9cf545e9b561454d5311b9c6.png" alt="img"></p>
<p>这样是不是插入工作就完成了呢？并不是。随着原始链表的新结点越来越多，索引会渐渐变得不够用了，因此索引结点也需要相应作出调整。</p>
<p>如何调整索引呢？我们让新插入的结点随机“晋升”，也就是成为索引结点。<strong>新结点晋升成功的几率是50%。</strong></p>
<p>假设第一次随机的结果是晋升成功，那么我们把结点10作为索引结点，插入到第1层索引的对应位置，并且向下指向原始链表的结点10：</p>
<p><img src="/../../images/7900200883c844b48f00beb22c4cb396.png" alt="img"></p>
<p>新结点在成功晋升之后，仍然有机会继续向上一层索引晋升。我们再进行一次随机，假设随机的结果是晋升失败，那么插入操作就告一段落了。</p>
<p>小灰说的是什么意思呢？让我们看看下图， 新结点10已经晋升到第2层索引，下一次随机的结果仍然是晋升成功，这时候该怎么办呢？</p>
<p><img src="/../../images/9eb747d7eb504e4aa3c8fffd09aa1e33.png" alt="img"></p>
<p><img src="/../../images/fdb807a921d44fb49a6e06909726090d.png" alt="img"></p>
<p><img src="/../../images/07bdf3513f104153a8dfda29d6f8e220.png" alt="img"></p>
<p>Redis之所以使用跳表而不使用红黑树原因如下：<br>    1.实现简单，相对于红黑树来说，<strong>实现更加的简单</strong>，不容易出错，代码更加容易维护和调试。<br>    2.跳表的<strong>底层节点</strong>有都是通过<strong>双向指针相互链接</strong>，这和B+树一样，对于范围查找会更加的方便。<br>    3.跳表的效率和红黑树一样，<strong>查找单个Key时间复杂度都是O(logn)</strong><br>    4.跳表更加灵活，可以通过改变索引构建策略，有效的平衡执行效率和内存消耗。</p>
<table>
<thead>
<tr>
<th>zrangebyscore<br />zrevrangebyscore</th>
<th>O(log(n)+k)，k为要获取成员个数，n为当前成员个数</th>
</tr>
</thead>
<tbody><tr>
<td>zadd</td>
<td>O(k*log(n))，k为添加 成员个数，n为当前成员个数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="11、锁升级过程，轻量锁可以变成偏向锁么？偏向锁可以变成无锁么？对象头结构，锁状态变化过程？"><a href="#11、锁升级过程，轻量锁可以变成偏向锁么？偏向锁可以变成无锁么？对象头结构，锁状态变化过程？" class="headerlink" title="11、锁升级过程，轻量锁可以变成偏向锁么？偏向锁可以变成无锁么？对象头结构，锁状态变化过程？"></a>11、锁升级过程，轻量锁可以变成偏向锁么？偏向锁可以变成无锁么？对象头结构，锁状态变化过程？</h3><p><strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率.</p>
<p>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。偏向锁通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致STW(stop the word)操作； </p>
<blockquote>
<p>锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p>
</blockquote>
<p><strong>轻量级锁（自旋锁）</strong></p>
<blockquote>
<p>自旋锁：自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
</blockquote>
<p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。</p>
<h3 id="12、Innodb的结构了解么？磁盘页和缓存区是怎么配合的？缓冲区和磁盘数据不一致怎么办，服务器突然宕机了数据会丢失么？"><a href="#12、Innodb的结构了解么？磁盘页和缓存区是怎么配合的？缓冲区和磁盘数据不一致怎么办，服务器突然宕机了数据会丢失么？" class="headerlink" title="12、Innodb的结构了解么？磁盘页和缓存区是怎么配合的？缓冲区和磁盘数据不一致怎么办，服务器突然宕机了数据会丢失么？"></a>12、Innodb的结构了解么？磁盘页和缓存区是怎么配合的？缓冲区和磁盘数据不一致怎么办，服务器突然宕机了数据会丢失么？</h3><p>MySQL底层架构，涉及到：</p>
<ul>
<li><strong>内存结构</strong>：<code>buffer pool</code>、<code>log buffer</code>、<code>change buffer</code>，buffer pool的页淘汰机制是怎样的；</li>
<li><strong>磁盘结构</strong>：<code>系统表空间</code>、<code>独立表空间</code>、<code>通用表空间</code>、<code>undo表空间</code>、<code>redo log</code>；</li>
<li>以及<code>IO</code>相关底层原理、查询<code>SQL执行流程</code>、数据<code>页结构</code>和<code>行结构</code>描述、<code>聚集索引</code>和<code>辅助索引</code>的底层数据组织方式、<code>MVCC</code>多版本并发控制的底层实现原理，以及可<code>重复读</code>、<code>读已提交</code>是怎么通过MVCC实现的。</li>
</ul>
<h3 id="13、InnoDB-索引为什使用B-树而不是用B树？"><a href="#13、InnoDB-索引为什使用B-树而不是用B树？" class="headerlink" title="13、InnoDB 索引为什使用B+树而不是用B树？"></a>13、InnoDB 索引为什使用B+树而不是用B树？</h3><p><strong>B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。</strong>所以从Mysql（Inoodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。 </p>
<p><strong>那么Mysql如何衡量查询效率呢？– 磁盘IO次数。</strong> B-树&#x2F;B+树 的特点就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。<strong>这是优点之一。</strong><br><strong>另一个优点是：</strong> B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是<strong>将所有的叶子节点用指针串起来</strong>。这样<strong>遍历</strong>叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。</p>
<p>B树相对于红黑树的区别</p>
<p><strong>AVL 数和红黑树基本都是存储在内存中才会使用的数据结构</strong>。在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据<strong>磁盘查找存取的次数往往由树的高度所决定</strong>，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<p><strong>数据库系统的设计者巧妙利用了磁盘预读原理</strong>，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证<strong>一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</p>
<h3 id="14、MySQL-分表是怎么实现的？跨库join如何解决？数据量突增怎么解决？"><a href="#14、MySQL-分表是怎么实现的？跨库join如何解决？数据量突增怎么解决？" class="headerlink" title="14、MySQL 分表是怎么实现的？跨库join如何解决？数据量突增怎么解决？"></a>14、MySQL 分表是怎么实现的？跨库join如何解决？数据量突增怎么解决？</h3><h3 id="15、数据库的隔离级别，怎么实现的？当前读，快照读？MVCC？"><a href="#15、数据库的隔离级别，怎么实现的？当前读，快照读？MVCC？" class="headerlink" title="15、数据库的隔离级别，怎么实现的？当前读，快照读？MVCC？"></a>15、数据库的隔离级别，怎么实现的？当前读，快照读？MVCC？</h3><h3 id="16、mysql优化的实践经验"><a href="#16、mysql优化的实践经验" class="headerlink" title="16、mysql优化的实践经验"></a>16、mysql优化的实践经验</h3><h3 id="17、分布式事务出现过不一致吗？为什么？怎么解决？有什么方法避免？怎么监控？监控到怎么处理？什么时候需要人工接入？"><a href="#17、分布式事务出现过不一致吗？为什么？怎么解决？有什么方法避免？怎么监控？监控到怎么处理？什么时候需要人工接入？" class="headerlink" title="17、分布式事务出现过不一致吗？为什么？怎么解决？有什么方法避免？怎么监控？监控到怎么处理？什么时候需要人工接入？"></a>17、分布式事务出现过不一致吗？为什么？怎么解决？有什么方法避免？怎么监控？监控到怎么处理？什么时候需要人工接入？</h3><h3 id="18、io模型了解么？多路复用？selete，poll，epoll，epoll的结构？怎么注册事件？"><a href="#18、io模型了解么？多路复用？selete，poll，epoll，epoll的结构？怎么注册事件？" class="headerlink" title="18、io模型了解么？多路复用？selete，poll，epoll，epoll的结构？怎么注册事件？"></a>18、io模型了解么？多路复用？selete，poll，epoll，epoll的结构？怎么注册事件？</h3><h3 id="19、你们用的什么消息中间件，kafka，为什么用kafka？kafka是怎么保证高吞吐量的？"><a href="#19、你们用的什么消息中间件，kafka，为什么用kafka？kafka是怎么保证高吞吐量的？" class="headerlink" title="19、你们用的什么消息中间件，kafka，为什么用kafka？kafka是怎么保证高吞吐量的？"></a>19、你们用的什么消息中间件，kafka，为什么用kafka？kafka是怎么保证高吞吐量的？</h3><p><strong>kafka是怎么保证高吞吐量的</strong></p>
<p><strong>1.顺序读写</strong></p>
<p>kafka的消息是不断追加到文件中的，这个特性使kafka可以充分利用磁盘的顺序读写性能。顺序读写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机读写。<br>生产者负责写入数据，Kafka会将消息持久化到磁盘，保证不会丢失数据，Kafka采用了俩个技术提高写入的速度。<br><strong>1.顺序写入</strong>：如果是随机IO，磁盘会进行频繁的寻址，导致写入速度下降。Kafka使用了顺序IO提高了磁盘的写入速度，Kafka会将数据顺序插入到文件末尾，消费者端通过控制<strong>偏移量</strong>来读取消息，这样做会导致数据无法删除，时间一长，磁盘空间会满，kafka提供了2种策略来删除数据：基于时间删除和基于partition文件的大小删除。<br><strong>2.Memory Mapped Files</strong>：这个和Java NIO中的内存映射基本相同，在大学的计算机原理里我们学过（划重点），mmf直接利用操作系统的Page来实现文件到物理内存的映射，完成之后对物理内存的操作会直接同步到硬盘。mmf通过内存映射的方式大大提高了IO速率，省去了用户空间到内核空间的复制。它的缺点显而易见–不可靠，当发生宕机而数据未同步到硬盘时，数据会丢失，Kafka提供了produce.type参数来控制是否主动的进行刷新，如果kafka写入到mmp后立即flush再返回给生产者则为同步模式，反之为异步模式。</p>
<p><strong>2.零拷贝</strong></p>
<p>在这之前先来了解一下零拷贝(直接让操作系统的 Cache 中的数据发送到网卡后传输给下游的消费者)：平时从服务器读取静态文件时，服务器先将文件从复制到内核空间，再复制到用户空间，最后再复制到内核空间并通过网卡发送出去，而零拷贝则是直接从内核到内核再到网卡，省去了用户空间的复制。<br>Kafka把所有的消息存放到一个文件中，当消费者需要数据的时候直接将文件发送给消费者，比如10W的消息共10M，全部发送给消费者，10M的消息在内网中传输是非常快的，假如需要1s，那么kafka的tps就是10w。Zero copy对应的是Linux中sendfile函数，这个函数会接受一个offsize来确定从哪里开始读取。现实中，不可能将整个文件全部发给消费者，他通过消费者传递过来的偏移量来使用零拷贝读取指定内容的数据返回给消费者。</p>
<p>在Linux kernel2.2 之后出现了一种叫做”零拷贝(zero-copy)”系统调用机制，就是跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到“用户态缓冲区”，系统上下文切换减少为2次，可以提升一倍的性能。</p>
<p><img src="/../../images/webp" alt="img"></p>
<p><strong>3.分区</strong></p>
<p>kafka中的topic中的内容可以被分为多分partition存在,每个partition又分为多个段segment,所以每次操作都是针对一小部分做操作，很轻便，并且增加<code>并行操作</code>的能力</p>
<p><strong>4.批量发送</strong></p>
<p>kafka允许进行批量发送消息，producter发送消息的时候，可以将消息缓存在本地,等到了固定条件发送到kafka</p>
<ol>
<li>等消息条数到固定条数</li>
<li>一段时间发送一次</li>
</ol>
<p><strong>5.数据压缩</strong></p>
<p>Kafka还支持对消息集合进行压缩，Producer可以通过GZIP或Snappy格式对消息集合进行压缩。<br>压缩的好处就是减少传输的数据量，减轻对网络传输的压力。</p>
<p>Producer压缩之后，在Consumer需进行解压，虽然增加了CPU的工作，但在对大数据处理上，瓶颈在网络上而不是CPU，所以这个成本很值得*<code>批量发送</code>和<code>数据压缩</code>一起使用,单条做数据压缩的话，效果不明显*</p>
<p>Kafka的设计目标是高吞吐量，它比其它消息系统快的原因体现在以下几方面：</p>
<p>1、Kafka操作的是序列文件I &#x2F; O（序列文件的特征是按顺序写，按顺序读），为保证顺序，Kafka强制点对点的按顺序传递消息，这意味着，一个consumer在消息流（或分区）中只有一个位置。</p>
<p>2、Kafka不保存消息的状态，即消息是否被“消费”。一般的消息系统需要保存消息的状态，并且还需要以随机访问的形式更新消息的状态。而Kafka 的做法是保存Consumer在Topic分区中的位置offset，在offset之前的消息是已被“消费”的，在offset之后则为未“消费”的，并且offset是可以任意移动的，这样就消除了大部分的随机IO。</p>
<p>3、Kafka支持点对点的批量消息传递。</p>
<p>4、Kafka的消息存储在OS pagecache（页缓存，page cache的大小为一页，通常为4K，在Linux读写文件时，它用于缓存文件的逻辑内容，从而加快对磁盘上映像和数据的访问）。</p>
<h3 id="20、kafka重平衡，重启服务怎么保证kafka不发生重平衡，有什么方案？"><a href="#20、kafka重平衡，重启服务怎么保证kafka不发生重平衡，有什么方案？" class="headerlink" title="20、kafka重平衡，重启服务怎么保证kafka不发生重平衡，有什么方案？"></a>20、kafka重平衡，重启服务怎么保证kafka不发生重平衡，有什么方案？</h3><h3 id="21、netty的原理和使用？tcp的连接过程？一台服务器能支持多少连接，为什么-？tcp各个参数怎么设置？"><a href="#21、netty的原理和使用？tcp的连接过程？一台服务器能支持多少连接，为什么-？tcp各个参数怎么设置？" class="headerlink" title="21、netty的原理和使用？tcp的连接过程？一台服务器能支持多少连接，为什么 ？tcp各个参数怎么设置？"></a>21、netty的原理和使用？tcp的连接过程？一台服务器能支持多少连接，为什么 ？tcp各个参数怎么设置？</h3><p><strong>服务端</strong></p>
<p>我们现在在来回头考虑服务器端。对于服务器来说，最大支持的并发连接是多少呢？就有人开始可爱地糊涂了：“服务器端理论也是端口限制吗？”。好，假设如果受影响的话，那我们的Nginx服务器只监听了一个80端口。那Nginx只能接受一个TCP连接喽？这明显是太荒唐了。</p>
<p>好，我们再看另外一个靠谱一点的答案。那就是一条TCP连接是由一个四元组组成的。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，对于我们这台Nginx Server来说，它的IP和端口是固定的。cp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的。它可能建立的最大的连接数是2的32次方（ip数）×2的16次方（port数）。这是2.8*10的14次方的一个大数字，两百万亿！！</p>
<p>Linux上除了监听80以外，还可以监听其它的端口，例如Mysql的3306, Redis的6339，当然所有65535个端口你都可以用来监听一遍。这样理论上线就到了2的32次方（ip数）×2的16次方（port数）×2的16次方（服务器port数）个。感兴趣你可以算一下，这个基本相当于无穷个了。</p>
<p>不过理想和实际总是会有差距的，因为Linux每维护一条TCP连接都要花费资源。处理连接请求，保活，数据的收发时需要消耗一些CPU，维持TCP连接主要消耗内存。我们题目的问题是考虑最大多少个连接，所以我们先不考虑数据的收发。那么TCP在静止的状态下，就不怎么消耗CPU了，主要消耗内存。而Linux上内存是有限的。<br>我们今天先直接把结论抛出来，一条TCP连接如果不发送数据的话，消耗内存是3.3K左右。如果有数据发送，需要为每条TCP分配发送缓存区，大小受你的参数net.ipv4.tcp_wmem配置影响，默认情况下最小是4K。如果发送结束，缓存区消耗的内存会被回收详细的分析过程敬请期待接下来的另一篇文章。</p>
<p><strong>假设你只保持连接不发送数据，那么你服务器可以建立的连接最大数量 &#x3D; 你的内存&#x2F;3.3K。</strong> 假如是4GB的内存，那么大约可接受的TCP连接数量是100万左右。</p>
<blockquote>
<p>这个例子里，我们考虑的前提是在一个进程下hold所有的服务器端连接。而在实际中的项目里，为了收发数据方便，很多网络IO模型还会为TCP连接再创建一个线程或协程。拿最轻量的golang来说，一个协程栈也需要2KB的内存开销。</p>
</blockquote>
<p><strong>结论</strong></p>
<p>一台机器最大究竟能支持多少个网络连接？这个简单的问题里其实埋了坑，导致无数的英雄好汉被困惑不解。就和树上九只鸟打死一只还剩几只的问题一样，没有和你说清楚树上是真鸟，还是假鸟。也没有说枪是有声还是无声的。通过今天的分析，相信你终于可以扬眉吐气把这个问题踩在脚下摩擦了。来，总结下：</p>
<ul>
<li><strong>TCP连接的客户端机：</strong>每一个ip可建立的TCP连接理论受限于内核net.ip_local_port_range参数，也受限于65535。但可以通过配置多ip的方式来加大自己的建立连接的能力。</li>
<li><strong>TCP连接的服务器机：</strong>每一个监听的端口虽然理论值很大，但这个数字没有实际意义。最大并发数取决你的内存大小，每一条静止状态的TCP连接大约需要吃3.3K的内存。</li>
</ul>
<h3 id="22、Sping的AOP实现原理，以及对象生成方式的种类，单例的还是原型的？"><a href="#22、Sping的AOP实现原理，以及对象生成方式的种类，单例的还是原型的？" class="headerlink" title="22、Sping的AOP实现原理，以及对象生成方式的种类，单例的还是原型的？"></a>22、Sping的AOP实现原理，以及对象生成方式的种类，单例的还是原型的？</h3><h3 id="23、讲讲调度接口是怎么实现的"><a href="#23、讲讲调度接口是怎么实现的" class="headerlink" title="23、讲讲调度接口是怎么实现的"></a>23、讲讲调度接口是怎么实现的</h3><p>Timer 的设计核心是一个 TaskQueue 和一个 TimerThread。Timer 将接收到的任务丢到自己的 TaskQueue中。TimerThread 在创建 Timer 时会启动成为一个守护线程。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread 被唤醒并执行该任务。之后 TimerThread 更新最近一个要执行的任务，继续休眠。</p>
<h3 id="24、分布式唯一ID是怎么实现的"><a href="#24、分布式唯一ID是怎么实现的" class="headerlink" title="24、分布式唯一ID是怎么实现的"></a>24、分布式唯一ID是怎么实现的</h3><h3 id="25、设计模式，以及自己使用的场景"><a href="#25、设计模式，以及自己使用的场景" class="headerlink" title="25、设计模式，以及自己使用的场景"></a>25、设计模式，以及自己使用的场景</h3><h3 id="26、有没有用过分布式锁，怎么实现的，讲讲原理"><a href="#26、有没有用过分布式锁，怎么实现的，讲讲原理" class="headerlink" title="26、有没有用过分布式锁，怎么实现的，讲讲原理"></a>26、有没有用过分布式锁，怎么实现的，讲讲原理</h3><h3 id="27、如何解决线上问题？cpu狂飙怎么办？频繁minor-gc怎么办？可能造成的原因是什么？如何避免？"><a href="#27、如何解决线上问题？cpu狂飙怎么办？频繁minor-gc怎么办？可能造成的原因是什么？如何避免？" class="headerlink" title="27、如何解决线上问题？cpu狂飙怎么办？频繁minor gc怎么办？可能造成的原因是什么？如何避免？"></a>27、如何解决线上问题？cpu狂飙怎么办？频繁minor gc怎么办？可能造成的原因是什么？如何避免？</h3><h3 id="28、怎么理解分布式和微服务，为什么要拆分服务，会产生什么问题，怎么解决这些问题-？"><a href="#28、怎么理解分布式和微服务，为什么要拆分服务，会产生什么问题，怎么解决这些问题-？" class="headerlink" title="28、怎么理解分布式和微服务，为什么要拆分服务，会产生什么问题，怎么解决这些问题 ？"></a>28、怎么理解分布式和微服务，为什么要拆分服务，会产生什么问题，怎么解决这些问题 ？</h3><p><strong>面试题剖析</strong></p>
<p><strong>为什么要将系统进行拆分？</strong></p>
<p>网上查查，答案极度零散和复杂，很琐碎，原因一大坨。但是我这里给大家直观的感受：</p>
<p>1.代码量大，容易冲突，合并非常耗费时间<br>2.不敢随意乱改技术。</p>
<p><strong>拆分了以后</strong>，每个人维护自己的服务就可以了。技术上想怎么升级就怎么升级，大幅度提升复杂系统大型团队的开发效率</p>
<p><strong>拆分后不用 dubbo 可以吗？</strong></p>
<p>当然可以了，大不了最次，就是各个系统之间，直接基于 spring mvc，就纯 http 接口互相通信呗，还能咋样。但是这个肯定是有问题的，因为 http 接口通信维护起来成本很高，你要考虑<strong>超时重试</strong>、<strong>负载均衡</strong>等等各种乱七八糟的问题，比如说你的订单系统调用商品系统，商品系统部署了 5 台机器，你怎么把请求均匀地甩给那 5 台机器？这不就是负载均衡？你要是都自己搞那是可以的，但是确实很痛苦。</p>
<p>所以 dubbo 说白了，是一种 rpc 框架，就是说本地就是进行接口调用，但是 dubbo 会代理这个调用请求，跟远程机器网络通信，给你处理掉负载均衡了、服务实例上下线自动感知了、超时重试了，等等乱七八糟的问题。那你就不用自己做了，用 dubbo 就可以了。</p>
<h3 id="29、怎么理解高可用，如何保证高可用，有什么弊端，熔断机制，怎么实现-？"><a href="#29、怎么理解高可用，如何保证高可用，有什么弊端，熔断机制，怎么实现-？" class="headerlink" title="29、怎么理解高可用，如何保证高可用，有什么弊端，熔断机制，怎么实现 ？"></a>29、怎么理解高可用，如何保证高可用，有什么弊端，熔断机制，怎么实现 ？</h3><h3 id="30、对于高并发怎么看，怎么算高并发，你们项目有么，如果有会产生什么问题，怎么解决"><a href="#30、对于高并发怎么看，怎么算高并发，你们项目有么，如果有会产生什么问题，怎么解决" class="headerlink" title="30、对于高并发怎么看，怎么算高并发，你们项目有么，如果有会产生什么问题，怎么解决"></a>30、对于高并发怎么看，怎么算高并发，你们项目有么，如果有会产生什么问题，怎么解决</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>31、有没有做过压测的项目？首页接口优化是怎么做的？<br>32、如何优雅的写代码？什么代码算做优雅？什么代码是规范？你们代码规范是什么样的？如何进行code review？<br>33、算法：给定一个长度为N的整形数组arr，其中有N个互不相等的自然数1-N，请实现arr的排序，但是不要把下标0∼N−1位置上的数通过直接赋值的方式替换成1∼N<br>34、算法：判断一个树是否是平衡二叉树<br>35、算法：给定一个二叉树，请计算节点值之和最大的路径的节点值之和是多少，这个路径的开始节点和结束节点可以是二叉树中的任意节点<br>36、算法：LRU 缓存<br>37、算法：实现带有getMin功能的栈，要求push，pop，getMin的时间复杂度都是O(1)<br>38、算法：两数之和<br>39、算法：实现二叉树先序，中序和后序遍历</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-07-14T07:55:12.000Z" title="2021/7/14 下午3:55:12">2021-07-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-14T07:55:12.000Z" title="2021/7/14 下午3:55:12">2021-07-14</time></span><span class="level-item">19 minutes read (About 2898 words)</span></div></div><div class="content"><h1 id="快速了解TCP的流量控制与拥塞控制"><a href="#快速了解TCP的流量控制与拥塞控制" class="headerlink" title="快速了解TCP的流量控制与拥塞控制"></a>快速了解TCP的流量控制与拥塞控制</h1><p>有关TCP你不能不知道的三次握手和四次挥手问题，<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6711623920568500743/?group_id=6711623920568500743">关于三次握手与四次挥手你要知道这些</a></p>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h1><p><strong>1. 滑动窗口</strong></p>
<p>数据的传送过程中很可能出现接收方来不及接收的情况，这时就需要对发送方进行控制以免数据丢失。利用滑动窗口机制可以很方便地在TCP连接上对发送方的流量进行控制。TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。</p>
<p><img src="/../../images/ccb76722b91244f693e996676dce228b.png" alt="快速了解TCP的流量控制与拥塞控制"></p>
<blockquote>
<p>TCP规定，即使设置为零窗口，也必须接收以下几种报文段：</p>
</blockquote>
<ul>
<li>零窗口探测报文段</li>
<li>确认报文段</li>
<li>携带紧急数据的报文段</li>
</ul>
<p><strong>确认丢失和确认迟到</strong></p>
<p><img src="https://p3-tt.byteimg.com/origin/pgc-image/ab58c573b8fa4009ad8f9217380def70.png?from=pc" alt="快速了解TCP的流量控制与拥塞控制"></p>
<p><strong>持续计时器</strong></p>
<p>存在这样一种情况：发送方接收到零窗口报文之后将发送窗口设置为0，停止发送数据。但等到接收方有足够缓存，发送了非零窗口大小的报文，但是这个报文中途丢失，那么发送方的发送窗口就一直为0导致死锁。</p>
<p>为此，TCP为每一个连接设有一个持续计时器(Persistence Timer)：当TCP连接的一方收到对方的零窗口通知时就启动持续计时器。若持续计时器时间到期，就发送一个零窗口探测报文段(携有1字节的数据)，那么收到这个报文段的一方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器；若窗口不是零，则死锁的僵局就可以打破了。</p>
<p><strong>2. 延迟ACK</strong></p>
<p>如果TCP对每个数据包都发送一个ACK确认，那么只是一个单独的数据包为了发送一个ACK代价比较高，所以TCP会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ACK，如果在延迟ACK定时器触发时候，发现ACK尚未发送，则立即单独发送；</p>
<p>延迟ACK好处：</p>
<ol>
<li>避免糊涂窗口综合症。</li>
<li>发送数据的时候将ACK捎带发送，不必单独发送ACK。如果延迟时间内有多个数据段到达，那么允许协议栈发送一个ACK确认多个报文段。减少流量消耗。</li>
</ol>
<blockquote>
<p>糊涂窗口综合症：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报为40字节的的话）。当发送方又发来1个字节的数据（发送方的IP数据报是41字节），接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段或者等到接收方缓存已有一半的空闲空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p>
</blockquote>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h1><blockquote>
<p>拥塞控制与流量控制的区别 :</p>
<p>拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。</p>
<p>流量控制是点对点通信量的控制，是一个端到端的问题，主要就是抑制发送端发送数据的速率，以便接收端来得及接收。</p>
</blockquote>
<p><strong>拥塞控制的作用</strong></p>
<p>拥塞控制是为了防止过多的数据注入到网络中，这样可以使网络中的路由器或者链路不至于过载。</p>
<p><img src="/../../images/51d23ca33a714286b4345a75a9ce02fa.png" alt="快速了解TCP的流量控制与拥塞控制"></p>
<p><strong>拥塞控制的算法</strong></p>
<p>我们假定:</p>
<ol>
<li>数据单方向传送，而另外一个方向只传送确认。</li>
<li>接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定。</li>
</ol>
<p>发送方的发送窗口的上限值应当取为接收方窗口rwnd和拥塞窗口cwnd这两个变量中较小的一个，即发送窗口的上限值为Min[rwnd, cwnd]</p>
<blockquote>
<p>当rwnd &lt; cwnd时，是接收方的接收能力限制发送窗口的最大值</p>
<p>当cwnd &lt; rwnd时，则是网络的拥塞限制发送窗口的最大值</p>
</blockquote>
<p>拥塞控制的过程一共涉及了4种算法:</p>
<ol>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ol>
<p><strong>1. 慢启动</strong></p>
<p>发送方维护一个拥塞窗口cwnd的状态变量，拥塞窗口的大小取决于网络的拥塞程度，动态变化。通过逐渐增加cwnd的大小来探测可用的网络容量，防止连接开始时采用不合适的发送量导致网络拥塞。</p>
<p>当主机开始发送数据时，如果通过较大的发送窗口立即将全部数据字节都注入到网络中，由于不清楚网络状况，有可能引起网络拥塞。较好的方法是试探，从小到大逐渐增大发送端拥塞窗口的cwnd数值。</p>
<p>例如：开始发送方先设置cwnd&#x3D;1，发送第一个报文段M1，接收方接收到M1后，ACK返回给发送端，发送端将cwnd增加到2，接着发送方发送M2，再次接受到ACK后将cwnd增加到4…慢启动算法每经过一个传输轮次，拥塞窗口cwnd就加倍。</p>
<p>当rwnd足够大时，为防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量，慢开始门限ssthresh</p>
<p>当cwnd＜ssthresh，使用慢开始算法</p>
<p>当cwnd&#x3D;ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</p>
<p>当cwnd＞ssthresh，使用拥塞避免算法</p>
<blockquote>
<p>首次慢启动的ssthresh值，可以参阅网上的各种讨论，限于篇幅，本文不作介绍~</p>
</blockquote>
<p><strong>2.拥塞避免</strong></p>
<p><img src="/../../images/a023d5495380449a9924f9cf5820ea00.png" alt="快速了解TCP的流量控制与拥塞控制"></p>
<p>控制过程:</p>
<ol>
<li>TCP连接初始化，将拥塞窗口cwnd设置为1个报文段，即cwnd&#x3D;1</li>
<li>执行慢开始算法，cwnd按指数规律增长，直到cwnd &#x3D;&#x3D; ssthresh时，开始拥塞避免算法，cwnd按线性规律增长</li>
<li>当网络发生阻塞，把ssthresh值更新为拥塞前cwnd的一半(12&#x3D;24&#x2F;2)，cwnd重新设置为1，再按照(2)执行</li>
</ol>
<p>让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1，而不是加倍。这样拥塞窗口cwnd线性缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢地多。</p>
<p>无论慢启动开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(没收到ACK)，就把慢启动门限ssthresh设置为出现拥塞时的cwnd的一半。然后把拥塞窗口cwnd重新设置为1，执行慢启动算法。这样做的目的是能迅速的减少主机向网络中传输数据，使发生拥塞的路由器能够把队列中堆积的分组处理完毕。拥塞窗口是按照线性的规律增长，比慢启动算法拥塞窗口增长快的多。</p>
<blockquote>
<p>拥塞避免是由指数增长拉低到线性增长，降低出现拥塞的可能，并不是能完全避免网络拥塞</p>
</blockquote>
<p><strong>3.快重传</strong></p>
<p>一条TCP连接有时会因等待重传计时器的超时而空闲较长的时间，慢开始和拥塞避免无法很好地解决这类问题，因此提出了快重传和快恢复的拥塞控制方法。</p>
<p>为使发送方及早知道有报文没有达到对方，快重传算法首先要求接受方每收到一个报文段后就立即发出重复确认。快重传算法并非取消了重传机制，只是在某些情况下更早地重传丢失的报文段。即，当TCP源端收到3个相同的ACK确认时，即认为有数据包丢失，则源端重传丢失的数据包，而不必等待RTO(Retransmission Timeout)超时。由于发送方尽早重传未被确认的报文段。因此，采用快重传后可以使整个网络吞吐量提高20%</p>
<p><img src="/../../images/f38247ae5cd644c68ea0ed878928c5dc.png" alt="快速了解TCP的流量控制与拥塞控制"></p>
<p>快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。接收方成功的接受了发送方发送来的M1、M2并且分别给发送了ACK，现在接收方没有收到M3，而接收到了M4，显然接收方不能确认M4，因为M4是失序的报文段。如果根据可靠性传输原理接收方什么都不做，但是按照快速重传算法，在收到M4、M5等报文段的时候，不断重复的向发送方发送M2的ACK,如果接收方一连收到三个重复的ACK,那么发送方不必等待重传计时器到期，由于发送方尽早重传未被确认的报文段。</p>
<p><strong>4.快恢复</strong></p>
<p><img src="/../../images/f1c1b0d8df804cd685c6ed1786d212f0.png" alt="快速了解TCP的流量控制与拥塞控制"></p>
<p>快恢复算法控制过程:</p>
<p>当发送方连续收到3个重复确认时，发送方认为网络很可能没有发生拥塞，因此不执行慢启动。而是把cwnd值设为新的门限值，然后执行拥塞避免算法，cwnd值线性增大，避免了当网络拥塞不够严重时采用”慢启动”算法而造成过大地减小发送窗口尺寸的现象，这就是快恢复。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-07-14T07:54:46.000Z" title="2021/7/14 下午3:54:46">2021-07-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-14T07:54:46.000Z" title="2021/7/14 下午3:54:46">2021-07-14</time></span><span class="level-item">11 minutes read (About 1582 words)</span></div></div><div class="content"><h1 id="TCP粘拆包详解与Netty代码示例"><a href="#TCP粘拆包详解与Netty代码示例" class="headerlink" title="TCP粘拆包详解与Netty代码示例"></a>TCP粘拆包详解与Netty代码示例</h1><p>TCP是个“流”协议，所谓流，就是没有界限的一串数据。可以想想河里的流水，是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</p>
<blockquote>
<p>有关TCP的详细讲解，可以点击<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6711623920568500743/?group_id=6711623920568500743">关于三次握手与四次挥手你要知道这些</a>和<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6711818943989809671/?group_id=6711818943989809671">快速了解TCP的流量控制与拥塞控制</a></p>
</blockquote>
<p><strong>TCP粘包或拆包的原因</strong></p>
<ol>
<li>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</li>
<li>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</li>
<li>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包。</li>
<li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li>
</ol>
<p><strong>拆包和粘包的形式</strong></p>
<p>第一种情况：接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。</p>
<p><img src="/../../images/bb8b60d1c9ae493dbe3557c0017ffa15.png" alt="TCP粘拆包详解与Netty代码示例"></p>
<p>发生拆包</p>
<p>第二种情况：接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p>
<p><img src="/../../images/fb71bd0fd3ed46d48eae951131744c1e.png" alt="TCP粘拆包详解与Netty代码示例"></p>
<p>发生粘包</p>
<p>第三种情况：这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p>
<p><img src="/../../images/5a0a8ba5a89143b688b0c90717c27f49.png" alt="TCP粘拆包详解与Netty代码示例"></p>
<p>发生拆包和粘包</p>
<p><img src="/../../images/8bbe54ff2fbd431e8fc9568c9bfad325.png" alt="TCP粘拆包详解与Netty代码示例"></p>
<p>发生拆包和粘包</p>
<p><strong>粘包和拆包的解决办法</strong></p>
<ol>
<li>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</li>
<li>发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li>
<li>可以在数据包之间设置边界，添加特殊符号（如：回车符），这样，接收端通过这个边界就可以将不同的数据包拆分开。</li>
</ol>
<p><strong>Netty中的代码示例</strong></p>
<p>Netty封装了JDK的NIO，是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。一般开发中并不会用JDK原生NIO，原因如下：</p>
<ol>
<li>使用JDK自带的NIO需要了解太多的概念，编程复杂，一不小心bug横飞</li>
<li>Netty底层IO模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从NIO模型变身为IO模型</li>
<li>Netty自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑</li>
<li>Netty解决了JDK的很多包括空轮询在内的bug</li>
<li>Netty底层对线程，selector做了很多细小的优化，精心设计的reactor线程模型做到非常高效的并发处理</li>
<li>自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手</li>
<li>Netty社区活跃，遇到问题随时邮件列表或者issue</li>
<li>Netty已经历各大rpc框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大</li>
</ol>
<p>所以，本文选择演示Netty的编解码代码。</p>
<p>在Netty中，我们定义MessageToByteEncoder<T>的继承类，重写其encode函数，来自定义编码器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;Packet&gt; &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, NetPacket msg, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="type">byte</span> body[] = msg.getBody();</span><br><span class="line">		<span class="type">int</span> <span class="variable">packetLen</span> <span class="operator">=</span> body.length;</span><br><span class="line"> 		<span class="comment">// 先设置包长度，然后写入二进制数据</span></span><br><span class="line"> 		byteBuf.writeInt(packetLen);</span><br><span class="line"> 		byteBuf.writeBytes(body);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Netty中，我们定义ByteToMessageDecoder的继承类，重写其decode函数，用来自定义解码器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="type">int</span> <span class="variable">bufLen</span> <span class="operator">=</span> byteBuf.readableBytes();</span><br><span class="line"> 		<span class="comment">// 解决粘包问题（不够一个包头的长度）</span></span><br><span class="line"> 		<span class="comment">// 4字节是报文中使用了一个int表示了报文长度</span></span><br><span class="line"> 		<span class="keyword">if</span> (bufLen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">			 <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="comment">// 标记一下当前的readIndex的位置</span></span><br><span class="line"> 		byteBuf.markReaderIndex();</span><br><span class="line"> 		<span class="type">int</span> <span class="variable">packetLength</span> <span class="operator">=</span> byteBuf.readInt();</span><br><span class="line"> 		<span class="comment">// 读到的消息体长度如果小于我们传送过来的消息长度，则resetReaderIndex。重置读索引,继续接收</span></span><br><span class="line"> 		<span class="keyword">if</span> (byteBuf.readableBytes() &lt; packetLength) &#123;</span><br><span class="line"> 			<span class="comment">// 配合markReaderIndex使用的。把readIndex重置到mark的地方</span></span><br><span class="line"> 			byteBuf.resetReaderIndex();</span><br><span class="line"> 			<span class="keyword">return</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="type">NetPacket</span> <span class="variable">netPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NetPacket</span>();</span><br><span class="line"> 		netPacket.setPacketLen(packetLength);</span><br><span class="line"> 		<span class="comment">// 传送过来数据的长度，满足我们的要求了</span></span><br><span class="line"> 		<span class="type">byte</span> body[] = <span class="keyword">new</span> <span class="title class_">byte</span>[packetLength];</span><br><span class="line"> 		byteBuf.readBytes(body);</span><br><span class="line"> 		netPacket.setBody(body);</span><br><span class="line"> 		list.add(netPacket);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-07-14T07:53:00.000Z" title="2021/7/14 下午3:53:00">2021-07-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-04T16:03:22.016Z" title="2022/5/5 上午12:03:22">2022-05-05</time></span><span class="level-item">18 minutes read (About 2766 words)</span></div></div><div class="content"><h1 id="彻底搞懂NIO效率高的原理"><a href="#彻底搞懂NIO效率高的原理" class="headerlink" title="彻底搞懂NIO效率高的原理"></a>彻底搞懂NIO效率高的原理</h1><p><strong>前言</strong></p>
<p>这篇文章读不懂的没关系，可以先收藏一下。笔者准备介绍完epoll和NIO等知识点，然后写一篇Java网络IO模型的介绍，这样可以使Java网络IO的知识体系更加地完整和严谨。初学者也可以等看完IO模型介绍的博客之后，再回头看这些博客，会更加有收获。</p>
<h1 id="NIO相比BIO的优势"><a href="#NIO相比BIO的优势" class="headerlink" title="NIO相比BIO的优势"></a><strong>NIO相比BIO的优势</strong></h1><p>NIO（Non-blocking I&#x2F;O，在Java领域，也称为New I&#x2F;O），是一种同步非阻塞的I&#x2F;O模型，也是I&#x2F;O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I&#x2F;O处理问题的有效方式。</p>
<p><img src="/../../images/f694de00677c45a1abf7d87aed6cc82a" alt="彻底搞懂NIO效率高的原理"></p>
<p><img src="/../../images/f694de00677c45a1abf7d87aed6cc82a" alt="彻底搞懂NIO效率高的原理"></p>
<p>bio与nio</p>
<p><strong>面向流与面向缓冲</strong></p>
<p>Java NIO和BIO之间第一个最大的区别是，BIO是面向流的，NIO是面向缓冲区的。 JavaIO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。Java NIO的缓冲读取方法略有不同。数据读取到一个缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<blockquote>
<p>有关面向缓冲读取数据的示例和注意点，可以点击查看<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6715713088542212622/?group_id=6715713088542212622">TCP粘拆包详解与Netty代码示例</a></p>
</blockquote>
<p><strong>阻塞IO与非阻塞IO</strong></p>
<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或write()时，该线程被阻塞，直到有数据被读取或者数据写入。该线程在阻塞期间不能做其他事情。而Java NIO的非阻塞模式，如果通道没有东西可读，或不可写，读写函数马上返回，而不会阻塞，这个线程可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程可以管理多个输入和输出通道（channel），即IO多路复用的原理。</p>
<p><strong>零拷贝</strong></p>
<p>在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数read()、write() ，此时调用此函数的进程（在JAVA中即java进程）由当前的用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。</p>
<p><img src="/../images/81a8c1b3ec94496db62c4460789e1d37" alt="彻底搞懂NIO效率高的原理"></p>
<p>IO</p>
<p>而NIO的零拷贝与传统的文件IO操作最大的不同之处就在于它虽然也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，这样直接从内存中读写文件，速度大幅度提升。</p>
<p><img src="/../images/5d63b9ca6ae44b93b8431d093ef8b615" alt="彻底搞懂NIO效率高的原理"></p>
<p>NIO</p>
<blockquote>
<p>详细的解析，之后会有单独的博客进行讲解</p>
</blockquote>
<h1 id="NIO的核心部分"><a href="#NIO的核心部分" class="headerlink" title="NIO的核心部分"></a><strong>NIO的核心部分</strong></h1><p>Java NIO主要由以下三个核心部分组成：</p>
<ul>
<li>Channel</li>
<li>Buffer</li>
<li>Selector</li>
</ul>
<p><strong>Channel</strong></p>
<p>基本上，所有的IO在NIO中都从一个Channel开始。数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。这里有个图示：</p>
<p><img src="/../../images/a1097d0cf9c6497389c7c3ce1e34d6d2" alt="彻底搞懂NIO效率高的原理"></p>
<p>channel与buffer</p>
<p>Channel和Buffer有好几种类型。下面是Java NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel(file)</li>
<li>DatagramChannel(UDP)</li>
<li>SocketChannel(TCP)</li>
<li>ServerSocketChannel(TCP)</li>
</ul>
<p>这些通道涵盖了UDP和TCP网络IO以及文件IO。</p>
<blockquote>
<p>最后两个channel的关系。通过<br>ServerSocketChannel.accept() 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。通常不会仅仅只监听一个连接,在while循环中调用 accept()方法.</p>
</blockquote>
<p>&#x2F;&#x2F;打开 ServerSocketChannel</p>
<p>ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</p>
<p>serverSocketChannel.socket().bind(new InetSocketAddress(9999));</p>
<p>while(true){</p>
<p>SocketChannel socketChannel &#x3D; serverSocketChannel.accept();</p>
<p>&#x2F;&#x2F;do something with socketChannel…</p>
<p>}</p>
<p>&#x2F;&#x2F;关闭ServerSocketChannel</p>
<p>serverSocketChannel.close();</p>
<p><strong>Buffer</strong></p>
<p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p>
<p>Java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer覆盖了你能通过IO发送的基本数据类型：byte、short、int、long、float、double和char。</p>
<p>为了理解Buffer的工作原理，需要熟悉它的三个属性：</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。</p>
<p><img src="/../../images/0f8892655d5141ed93e9a4442670f30b" alt="彻底搞懂NIO效率高的原理"></p>
<p>buffer模型</p>
<p><strong>capacity</strong></p>
<p>作为一个内存块，Buffer有个固定的最大值，就是capacity。Buffer只能写capacity个byte、long、char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p>
<p><strong>position</strong></p>
<p>当写数据到Buffer中时，position表示当前的位置。初始的position值为0。当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p>
<p>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0。 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p>
<p><strong>limit</strong></p>
<p>在写模式下，Buffer的limit表示最多能往Buffer里写多少数据。 写模式下，limit等于capacity。</p>
<p>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。</p>
<p><strong>Selector</strong></p>
<p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。</p>
<p>这是在一个单线程中使用一个Selector处理3个Channel的图示：</p>
<p><img src="/../../images/12d44b7ddffd4908bfe9627f63580ec1" alt="彻底搞懂NIO效率高的原理"></p>
<p>Selector</p>
<p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件例如有新连接进来，数据接收等。</p>
<p><strong>NIO与epoll的关系</strong></p>
<p>Java NIO根据操作系统不同， 针对NIO中的Selector有不同的实现：</p>
<ul>
<li>macosx:KQueueSelectorProvider</li>
<li>solaris:DevPollSelectorProvider</li>
<li>Linux:EPollSelectorProvider (Linux kernels &gt;&#x3D; 2.6)或PollSelectorProvider</li>
<li>windows:WindowsSelectorProvider</li>
</ul>
<p>所以不需要特别指定，Oracle JDK会自动选择合适的Selector。</p>
<p>如果想设置特定的Selector，可以设置属性，例如：</p>
<p>-Djava.nio.channels.spi.SelectorProvider&#x3D;sun.nio.ch.EPollSelectorProvider</p>
<p>JDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，所以Netty自4.0.16起, Netty为Linux通过JNI的方式提供了native socket transport。Netty重新实现了epoll机制，</p>
<ol>
<li>采用边缘触发方式</li>
<li>netty epoll transport暴露了更多的nio没有的配置参数，如 TCP_CORK, SO_REUSEADDR等等。</li>
<li>C代码，更少GC，更少synchronized</li>
</ol>
<p>使用native socket transport的方法很简单，只需将相应的类替换即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup → EpollEventLoopGroup</span><br><span class="line">NioEventLoop → EpollEventLoop</span><br><span class="line">NioServerSocketChannel → EpollServerSocketChannel</span><br><span class="line">NioSocketChannel → EpollSocketChannel </span><br></pre></td></tr></table></figure>

<p>有关epoll的详细讲解，可以点击查看<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6720907162404520456/?group_id=6720907162404520456">彻底搞懂epoll高效运行的原理</a></p>
<h1 id="NIO处理消息的核心思路"><a href="#NIO处理消息的核心思路" class="headerlink" title="NIO处理消息的核心思路"></a><strong>NIO处理消息的核心思路</strong></h1><p>结合示例代码，总结NIO的核心思路：</p>
<ol>
<li>NIO 模型中通常会有两个线程，每个线程绑定一个轮询器 selector ，在上面例子中serverSelector负责轮询是否有新的连接，clientSelector负责轮询连接是否有数据可读</li>
<li>服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到clientSelector上，这样就不用BIO模型中1w 个while循环在阻塞，参见(1)</li>
<li>clientSelector被一个 while 死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过clientSelector.select(1)方法可以轮询出来，进而批量处理，参见(2)</li>
<li>数据的读写面向 Buffer，参见(3)</li>
</ol>
<p><strong>NIO的示例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class NIOServer &#123;</span><br><span class="line"> public static void main(String[] args) throws IOException &#123;</span><br><span class="line"> Selector serverSelector = Selector.open();</span><br><span class="line"> Selector clientSelector = Selector.open();</span><br><span class="line"> new Thread(() -&gt; &#123;</span><br><span class="line"> try &#123;</span><br><span class="line"> // 对应IO编程中服务端启动</span><br><span class="line"> ServerSocketChannel listenerChannel = ServerSocketChannel.open();</span><br><span class="line"> listenerChannel.socket().bind(new InetSocketAddress(8000));</span><br><span class="line"> listenerChannel.configureBlocking(false);</span><br><span class="line"> listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"> while (true) &#123;</span><br><span class="line"> // 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms</span><br><span class="line"> if (serverSelector.select(1) &gt; 0) &#123;</span><br><span class="line"> Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();</span><br><span class="line"> Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line"> while (keyIterator.hasNext()) &#123;</span><br><span class="line"> SelectionKey key = keyIterator.next();</span><br><span class="line"> if (key.isAcceptable()) &#123;</span><br><span class="line"> try &#123;</span><br><span class="line"> // (1) 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector</span><br><span class="line"> SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line"> clientChannel.configureBlocking(false);</span><br><span class="line"> clientChannel.register(clientSelector, SelectionKey.OP_READ);</span><br><span class="line"> &#125; finally &#123;</span><br><span class="line"> keyIterator.remove();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; catch (IOException ignored) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;).start();</span><br><span class="line"> new Thread(() -&gt; &#123;</span><br><span class="line"> try &#123;</span><br><span class="line"> while (true) &#123;</span><br><span class="line"> // (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms</span><br><span class="line"> if (clientSelector.select(1) &gt; 0) &#123;</span><br><span class="line"> Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();</span><br><span class="line"> Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line"> while (keyIterator.hasNext()) &#123;</span><br><span class="line"> SelectionKey key = keyIterator.next();</span><br><span class="line"> if (key.isReadable()) &#123;</span><br><span class="line"> try &#123;</span><br><span class="line"> SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line"> ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</span><br><span class="line"> // (3) 面向 Buffer</span><br><span class="line"> clientChannel.read(byteBuffer);</span><br><span class="line"> byteBuffer.flip();</span><br><span class="line"> System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer)</span><br><span class="line"> .toString());</span><br><span class="line"> &#125; finally &#123;</span><br><span class="line"> keyIterator.remove();</span><br><span class="line"> key.interestOps(SelectionKey.OP_READ);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; catch (IOException ignored) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多内容，欢迎关注微信公众号：全菜工程师小辉~</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-07-14T02:50:33.000Z" title="2021/7/14 上午10:50:33">2021-07-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-14T02:50:33.000Z" title="2021/7/14 上午10:50:33">2021-07-14</time></span><span class="level-item">5 minutes read (About 796 words)</span></div></div><div class="content"><h2 id="服务端如何防止重复支付"><a href="#服务端如何防止重复支付" class="headerlink" title="服务端如何防止重复支付"></a>服务端如何防止重复支付</h2><p><img src="/../../images/image-20210714103550351.png" alt="image-20210714103550351"></p>
<p>如图是一个简化的下单流程，首先是提交订单，然后是支付。支付的话，一般是走支付网关（支付中心），然后支付中心与第三方支付渠道（微信、支付宝、银联）交互，支付成功以后，异步通知支付中心，支付中心更新自身支付订单状态，再通知业务应用，各业务再更新各自订单状态。</p>
<p>这个过程中经常可能遇到的问题是掉单，无论是超时未收到回调通知也好，还是程序自身报错也好，总之由于各种各样的原因，没有如期收到通知并正确的处理后续逻辑等等，都会造成用户支付成功了，但是服务端这边订单状态没更新，这个时候有可能产生投诉，或者用户重复支付。</p>
<p>由于③⑤造成的掉单称之为外部掉单，由④⑥造成的掉单我们称之为内部掉单</p>
<p>为了防止掉单，这里可以这样处理：</p>
<p>1、支付订单增加一个中间状态“支付中”，当同一个订单去支付的时候，先检查有没有状态为“支付中”的支付流水，当然支付（prepay）的时候要加个锁。支付完成以后更新支付流水状态的时候再讲其改成“支付成功”状态。</p>
<p>2、支付中心这边要自己定义一个超时时间（比如：30秒），在此时间范围内如果没有收到支付成功回调，则应调用接口主动查询支付结果，比如10s、20s、30s查一次，如果在最大查询次数内没有查到结果，应做异常处理</p>
<p>3、支付中心收到支付结果以后，将结果同步给业务系统，可以发MQ，也可以直接调用，直接调用的话要加重试（比如：SpringBoot Retry）</p>
<p>4、无论是支付中心，还是业务应用，在接收支付结果通知时都要考虑接口幂等性，消息只处理一次，其余的忽略</p>
<p>5、业务应用也应做超时主动查询支付结果</p>
<p>对于上面说的超时主动查询可以在发起支付的时候将这些支付订单放到一张表中，用定时任务去扫</p>
<p>为了防止订单重复提交，可以这样处理：</p>
<p>1、创建订单的时候，用订单信息计算一个哈希值，判断redis中是否有key，有则不允许重复提交，没有则生成一个新key，放到redis中设置个过期时间，然后创建订单。其实就是在一段时间内不可重复相同的操作</p>
<p>附上微信支付最佳实践：</p>
<p><img src="/../../images/image-20210714103728658.png" alt="image-20210714103728658"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-07-02T10:38:58.000Z" title="2021/7/2 下午6:38:58">2021-07-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-02T10:38:58.000Z" title="2021/7/2 下午6:38:58">2021-07-02</time></span><span class="level-item">12 minutes read (About 1808 words)</span></div></div><div class="content"><p>[toc]</p>
<h1 id="「DUBBO系列」责任链模式实现原理与源码分析"><a href="#「DUBBO系列」责任链模式实现原理与源码分析" class="headerlink" title="「DUBBO系列」责任链模式实现原理与源码分析"></a>「DUBBO系列」责任链模式实现原理与源码分析</h1><h2 id="1-文章概述"><a href="#1-文章概述" class="headerlink" title="1 文章概述"></a>1 文章概述</h2><p>责任链模式将请求发送和接收解耦，让多个接收对象都有机会处理这个请求。这些接收对象串成一条链路并沿着这条链路传递这个请求，直到链路上某个接收对象能够处理它。本文我们介绍责任链模式两种应用场景和四种代码实现方式，最后介绍了DUBBO如何应用责任链构建过滤器链路。</p>
<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a>2 应用场景</h2><h3 id="2-1-命中立即中断"><a href="#2-1-命中立即中断" class="headerlink" title="2.1 命中立即中断"></a>2.1 命中立即中断</h3><p>我们实现一个关键词过滤功能。系统设置三个关键词过滤器，输入内容命中任何一个过滤器规则就返回校验不通过，链路立即中断无需继续进行。</p>
<h4 id="1-实现方式一"><a href="#1-实现方式一" class="headerlink" title="(1) 实现方式一"></a>(1) 实现方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContentFilter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(String content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AaaContentFilter</span> <span class="keyword">implements</span> <span class="title class_">ContentFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">KEY_CONTENT</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(content)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isValid;</span><br><span class="line">        &#125;</span><br><span class="line">        isValid = !content.contains(KEY_CONTENT);</span><br><span class="line">        <span class="keyword">return</span> isValid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BbbContentFilter</span> <span class="keyword">implements</span> <span class="title class_">ContentFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">KEY_CONTENT</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(content)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isValid;</span><br><span class="line">        &#125;</span><br><span class="line">        isValid = !content.contains(KEY_CONTENT);</span><br><span class="line">        <span class="keyword">return</span> isValid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CccContentFilter</span> <span class="keyword">implements</span> <span class="title class_">ContentFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">KEY_CONTENT</span> <span class="operator">=</span> <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(content)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isValid;</span><br><span class="line">        &#125;</span><br><span class="line">        isValid = !content.contains(KEY_CONTENT);</span><br><span class="line">        <span class="keyword">return</span> isValid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体过滤器已经编写完成，接下来构造过滤器责任链路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterHandlerChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FilterHandler</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FilterHandler</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FilterHandler</span> <span class="variable">aaaHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AaaContentFilter</span>();</span><br><span class="line">        <span class="type">FilterHandler</span> <span class="variable">bbbHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BbbContentFilter</span>();</span><br><span class="line">        addHandler(aaaHandler);</span><br><span class="line">        addHandler(bbbHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(FilterHandler handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = tail = handler;</span><br><span class="line">            head.setSuccessor(tail);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 设置当前tail继任者 **/</span></span><br><span class="line">        tail.setSuccessor(handler);</span><br><span class="line">        <span class="comment">/** 指针重新指向tail **/</span></span><br><span class="line">        tail = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;FilterHandlerChain is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** head发起调用 **/</span></span><br><span class="line">        <span class="keyword">return</span> head.filter(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;classpath*:META-INF/chain/spring-core.xml&quot;</span> &#125;);</span><br><span class="line">        <span class="type">FilterHandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> (FilterHandlerChain) context.getBean(<span class="string">&quot;filterHandlerChain&quot;</span>);</span><br><span class="line">        System.out.println(context);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> chain.filter(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> chain.filter(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;校验结果1=&quot;</span> + result1);</span><br><span class="line">        System.out.println(<span class="string">&quot;校验结果2=&quot;</span> + result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-实现方式二"><a href="#2-实现方式二" class="headerlink" title="(2) 实现方式二"></a>(2) 实现方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FilterHandler</span> &#123;</span><br><span class="line"><span class="comment">/** 下一个节点 **/</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">FilterHandler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(FilterHandler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="comment">/** 执行自身方法 **/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> doFilter(content);</span><br><span class="line">        <span class="keyword">if</span> (!isValid) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;校验不通过&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> isValid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 执行下一个节点链路 **/</span></span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span> != successor) &#123;</span><br><span class="line">            isValid = successor.filter(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 每个节点过滤方法 **/</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(String content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AaaContentFilterHandler</span> <span class="keyword">extends</span> <span class="title class_">FilterHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">KEY_CONTENT</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(content)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isValid;</span><br><span class="line">        &#125;</span><br><span class="line">        isValid = !content.contains(KEY_CONTENT);</span><br><span class="line">        <span class="keyword">return</span> isValid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它过滤器代码</span></span><br></pre></td></tr></table></figure>

<p>具体过滤器已经编写完成，接下来构造过滤器责任链路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterHandlerChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FilterHandler</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FilterHandler</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FilterHandler</span> <span class="variable">aaaHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AaaContentFilterHandler</span>();</span><br><span class="line">        <span class="type">FilterHandler</span> <span class="variable">bbbHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BbbContentFilterHandler</span>();</span><br><span class="line">        <span class="type">FilterHandler</span> <span class="variable">cccHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CccContentFilterHandler</span>();</span><br><span class="line">        addHandler(aaaHandler);</span><br><span class="line">        addHandler(bbbHandler);</span><br><span class="line">        addHandler(cccHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(FilterHandler handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = tail = handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 设置当前tail继任者 **/</span></span><br><span class="line">        tail.setSuccessor(handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 指针重新指向tail **/</span></span><br><span class="line">        tail = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;FilterHandlerChain is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** head发起调用 **/</span></span><br><span class="line">        <span class="keyword">return</span> head.filter(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;classpath*:META-INF/chain/spring-core.xml&quot;</span> &#125;);</span><br><span class="line">        <span class="type">FilterHandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> (FilterHandlerChain) context.getBean(<span class="string">&quot;filterHandlerChain&quot;</span>);</span><br><span class="line">        System.out.println(context);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> chain.filter(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> chain.filter(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;校验结果1=&quot;</span> + result1);</span><br><span class="line">        System.out.println(<span class="string">&quot;校验结果2=&quot;</span> + result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-全链路执行"><a href="#2-2-全链路执行" class="headerlink" title="2.2 全链路执行"></a>2.2 全链路执行</h3><p>我们实现一个考题生成功能。在线考试系统根据不同年级生成不同考题。系统设置三个考题生成器，每个生成器都会执行，根据学生年级决定是否生成考题，无需生成则执行下一个生成器。</p>
<h4 id="1-实现方式一-1"><a href="#1-实现方式一-1" class="headerlink" title="(1) 实现方式一"></a>(1) 实现方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">QuestionGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Question <span class="title function_">generateQuestion</span><span class="params">(String gradeInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AaaQuestionGenerator</span> <span class="keyword">implements</span> <span class="title class_">QuestionGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Question <span class="title function_">generateQuestion</span><span class="params">(String gradeInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!gradeInfo.equals(<span class="string">&quot;一年级&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Question</span> <span class="variable">question</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Question</span>();</span><br><span class="line">        question.setId(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        question.setScore(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> question;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它生成器代码</span></span><br></pre></td></tr></table></figure>

<p>具体生成器已经编写完成，接下来构造生成器责任链路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuestionChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;QuestionGenerator&gt; generators = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;QuestionGenerator&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QuestionGenerator</span> <span class="variable">aaaQuestionGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AaaQuestionGenerator</span>();</span><br><span class="line">        <span class="type">QuestionGenerator</span> <span class="variable">bbbQuestionGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BbbQuestionGenerator</span>();</span><br><span class="line">        <span class="type">QuestionGenerator</span> <span class="variable">cccQuestionGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CccQuestionGenerator</span>();</span><br><span class="line">        generators.add(aaaQuestionGenerator);</span><br><span class="line">        generators.add(bbbQuestionGenerator);</span><br><span class="line">        generators.add(cccQuestionGenerator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Question&gt; <span class="title function_">generate</span><span class="params">(String gradeInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(generators)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;QuestionChain is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Question&gt; questions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Question&gt;();</span><br><span class="line">        <span class="keyword">for</span> (QuestionGenerator generator : generators) &#123;</span><br><span class="line">            <span class="type">Question</span> <span class="variable">question</span> <span class="operator">=</span> generator.generateQuestion(gradeInfo);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == question) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            questions.add(question);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> questions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;classpath*:META-INF/chain/spring-core.xml&quot;</span> &#125;);</span><br><span class="line">        System.out.println(context);</span><br><span class="line">        <span class="type">QuestionChain</span> <span class="variable">chain</span> <span class="operator">=</span> (QuestionChain) context.getBean(<span class="string">&quot;questionChain&quot;</span>);</span><br><span class="line">        List&lt;Question&gt; questions = chain.generate(<span class="string">&quot;一年级&quot;</span>);</span><br><span class="line">        System.out.println(questions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-实现方式二-1"><a href="#2-实现方式二-1" class="headerlink" title="(2) 实现方式二"></a>(2) 实现方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GenerateHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一个节点 **/</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">GenerateHandler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(GenerateHandler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> List&lt;Question&gt; <span class="title function_">generate</span><span class="params">(String gradeInfo)</span> &#123;</span><br><span class="line">        List&lt;Question&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Question&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 执行自身方法 **/</span></span><br><span class="line">        <span class="type">Question</span> <span class="variable">question</span> <span class="operator">=</span> doGenerate(gradeInfo);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != question) &#123;</span><br><span class="line">            result.add(question);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 执行下一个节点链路 **/</span></span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span> != successor) &#123;</span><br><span class="line">            List&lt;Question&gt; successorQuestions = successor.generate(gradeInfo);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != successorQuestions) &#123;</span><br><span class="line">                result.addAll(successorQuestions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 每个节点生成方法 **/</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Question <span class="title function_">doGenerate</span><span class="params">(String gradeInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AaaGenerateHandler</span> <span class="keyword">extends</span> <span class="title class_">GenerateHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Question <span class="title function_">doGenerate</span><span class="params">(String gradeInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!gradeInfo.equals(<span class="string">&quot;一年级&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Question</span> <span class="variable">question</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Question</span>();</span><br><span class="line">        question.setId(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        question.setScore(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> question;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它生成器代码</span></span><br></pre></td></tr></table></figure>

<p>具体生成器已经编写完成，接下来构造生成器责任链路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">GenerateHandler</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">GenerateHandler</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GenerateHandler</span> <span class="variable">aaaHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AaaGenerateHandler</span>();</span><br><span class="line">        <span class="type">GenerateHandler</span> <span class="variable">bbbHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BbbGenerateHandler</span>();</span><br><span class="line">        <span class="type">GenerateHandler</span> <span class="variable">cccHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CccGenerateHandler</span>();</span><br><span class="line">        addHandler(aaaHandler);</span><br><span class="line">        addHandler(bbbHandler);</span><br><span class="line">        addHandler(cccHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(GenerateHandler handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = tail = handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 设置当前tail继任者 **/</span></span><br><span class="line">        tail.setSuccessor(handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 指针重新指向tail **/</span></span><br><span class="line">        tail = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Question&gt; <span class="title function_">generate</span><span class="params">(String gradeInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;GenerateChain is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** head发起调用 **/</span></span><br><span class="line">        <span class="keyword">return</span> head.generate(gradeInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;classpath*:META-INF/chain/spring-core.xml&quot;</span> &#125;);</span><br><span class="line">        <span class="type">GenerateChain</span> <span class="variable">chain</span> <span class="operator">=</span> (GenerateChain) context.getBean(<span class="string">&quot;generateChain&quot;</span>);</span><br><span class="line">        System.out.println(context);</span><br><span class="line">        List&lt;Question&gt; result = chain.generate(<span class="string">&quot;一年级&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-DUBBO构建过滤器链"><a href="#3-DUBBO构建过滤器链" class="headerlink" title="3 DUBBO构建过滤器链"></a>3 DUBBO构建过滤器链</h2><p>生产者和消费者最终执行对象都是过滤器链路最后一个节点，整个链路包含多个过滤器进行业务处理。我们看看生产者和消费者默认过滤器链路。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 生产者过滤器链路</span><br><span class="line">EchoFilter &gt; ClassloaderFilter &gt; GenericFilter &gt; ContextFilter &gt; </span><br><span class="line">TraceFilter &gt; TimeoutFilter &gt; MonitorFilter &gt; ExceptionFilter &gt; AbstractProxyInvoker</span><br><span class="line"></span><br><span class="line"># 消费者过滤器链路</span><br><span class="line">ConsumerContextFilter &gt; FutureFilter &gt; MonitorFilter &gt; DubboInvoker</span><br></pre></td></tr></table></figure>

<p>ProtocolFilterWrapper作为链路生成核心通过匿名类方式构建过滤器链路，我们以消费者构建过滤器链路为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invoker = DubboInvoker</span></span><br><span class="line">        Invoker&lt;T&gt; last = invoker;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询符合条件过滤器列表</span></span><br><span class="line">        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">        <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filters.get(i);</span><br><span class="line">                <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构造一个简化Invoker</span></span><br><span class="line">                last = <span class="keyword">new</span> <span class="title class_">Invoker</span>&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Class&lt;T&gt; <span class="title function_">getInterface</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> URL <span class="title function_">getUrl</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.getUrl();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAvailable</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Result <span class="title function_">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">                        <span class="comment">// 构造过滤器链路</span></span><br><span class="line">                        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> filter.invoke(next, invocation);</span><br><span class="line">                        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> AsyncRpcResult) &#123;</span><br><span class="line">                            <span class="type">AsyncRpcResult</span> <span class="variable">asyncResult</span> <span class="operator">=</span> (AsyncRpcResult) result;</span><br><span class="line">                            asyncResult.thenApplyWithContext(r -&gt; filter.onResponse(r, invoker, invocation));</span><br><span class="line">                            <span class="keyword">return</span> asyncResult;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> filter.onResponse(result, invoker, invocation);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">                        invoker.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// RegistryProtocol不构造过滤器链路</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.refer(type, url);</span><br><span class="line">        &#125;</span><br><span class="line">        Invoker&lt;T&gt; invoker = protocol.refer(type, url);</span><br><span class="line">        <span class="keyword">return</span> buildInvokerChain(invoker, Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-文章总结"><a href="#4-文章总结" class="headerlink" title="4 文章总结"></a>4 文章总结</h2><p>面向对象设计有一个重要原则：对扩展开放对修改关闭，我认为这是最重要的面向对象设计原则，责任链模式非常好得体现了这个原则，有助于代码维护和处理复杂场景。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-07-02T09:27:08.000Z" title="2021/7/2 下午5:27:08">2021-07-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-02T09:27:08.000Z" title="2021/7/2 下午5:27:08">2021-07-02</time></span><span class="level-item">a few seconds read (About 5 words)</span></div></div><div class="content"><p>责任链模式 </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-06-28T10:50:40.000Z" title="2021/6/28 下午6:50:40">2021-06-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-06-28T10:50:40.000Z" title="2021/6/28 下午6:50:40">2021-06-28</time></span><span class="level-item">21 minutes read (About 3117 words)</span></div></div><div class="content"><h2 id="阿里巴巴开源限流系统-Sentinel-全解析"><a href="#阿里巴巴开源限流系统-Sentinel-全解析" class="headerlink" title="阿里巴巴开源限流系统 Sentinel 全解析"></a>阿里巴巴开源限流系统 Sentinel 全解析</h2><h2 id="Sentinel-入门"><a href="#Sentinel-入门" class="headerlink" title="Sentinel 入门"></a>Sentinel 入门</h2><p>首先，Sentinel 不算一个特别复杂的系统 ，普通技术开发者也可以轻松理解它的原理和结构。你别看架构图上 Sentinel 的周边是一系列的其它高大山的开源中间件，这不过是一种华丽的包装，其内核 Sentinel Core 确实是非常轻巧的。</p>
<p>首先我们从它的 Hello World 开始，通过深入理解这段入门代码就可以洞悉其架构原理。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>限流分为单机和分布式两种，单机限流是指限定当前进程里面的某个代码片段的 QPS 或者 并发线程数 或者 整个机器负载指数，一旦超出规则配置的数值就会抛出异常或者返回 false。我把这里的被限流的代码片段称为「临界区」。</p>
<p><img src="/../../images/640-4876551.png" alt="图片">图片</p>
<p>而分布式则需要另启一个集中的发票服务器，这个服务器针对每个指定的资源每秒只会生成一定量的票数，在执行临界区的代码之前先去集中的发票服务领票，如果领成功了就可以执行，否则就会抛出限流异常。所以分布式限流代价较高，需要多一次网络读写操作。如果读者阅读了我的小册《Redis 深度历险》，里面就提到了 Redis 的限流模块，Sentinel 限流的原理和它是类似的，只不过 Sentinel 的发票服务器是自研的，使用了 Netty 框架。</p>
<p>Sentinel 在使用上提供了两种形式，一种是异常捕获形式，一种是布尔形式。也就是当限流被触发时，是抛出异常来还是返回一个 false。下面我们看看它的异常捕获形式，这是单机版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.Entry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.SphU;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置规则</span></span><br><span class="line">        List&lt;FlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">FlowRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">        rule.setResource(<span class="string">&quot;tutorial&quot;</span>);</span><br><span class="line">        <span class="comment">// QPS 不得超出 1</span></span><br><span class="line">        rule.setCount(<span class="number">1</span>);</span><br><span class="line">        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">        rule.setLimitApp(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        rules.add(rule);</span><br><span class="line">        <span class="comment">// 加载规则</span></span><br><span class="line">        FlowRuleManager.loadRules(rules);</span><br><span class="line">        <span class="comment">// 下面开始运行被限流作用域保护的代码</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                entry = SphU.entry(<span class="string">&quot;tutorial&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;blocked&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                    entry.exit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用 Sentinel 需要我们提供限流规则，在规则的基础上，将临界区代码使用限流作用域结构包裹起来。在上面的例子中限定了 tutorial 资源的单机 QPS 不得超出 1，但是实际上它的运行 QPS 是 2，这多出来的执行逻辑就会被限制，对应的 Sphu.entry() 方法就会抛出限流异常 BlockException。下面是它的运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INFO: <span class="built_in">log</span> base <span class="built_in">dir</span> is: /Users/qianwp/logs/csp/</span><br><span class="line">INFO: <span class="built_in">log</span> name use pid is: <span class="literal">false</span></span><br><span class="line">hello world</span><br><span class="line">blocked</span><br><span class="line">hello world</span><br><span class="line">blocked</span><br><span class="line">hello world</span><br><span class="line">blocked</span><br><span class="line">hello world</span><br><span class="line">blocked</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<p>从输出中可以看出 Sentinel 在本地文件中记录了详细的限流日志，可以将这部分日志收集起来作为报警的数据源。</p>
<p>我们再看看它的 bool 形式，使用也是很简单，大同小异。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.SphO;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置规则</span></span><br><span class="line">        List&lt;FlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">FlowRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">        rule.setResource(<span class="string">&quot;tutorial&quot;</span>);</span><br><span class="line">        <span class="comment">// QPS 不得超出 1</span></span><br><span class="line">        rule.setCount(<span class="number">1</span>);</span><br><span class="line">        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">        rule.setLimitApp(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        rules.add(rule);</span><br><span class="line">        FlowRuleManager.loadRules(rules);</span><br><span class="line">        <span class="comment">// 运行被限流作用域保护的代码</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (SphO.entry(<span class="string">&quot;tutorial&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    SphO.exit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;blocked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="规则控制"><a href="#规则控制" class="headerlink" title="规则控制"></a>规则控制</h2><p>上面的例子中规则都是通过代码写死的，在实际的项目中，规则应该需要支持动态配置。这就需要有一个规则配置源，它可以是 Redis、Zookeeper 等数据库，还需要有一个规则变更通知机制和规则配置后台，允许管理人员可以在后台动态配置规则并实时下发到业务服务器进行控制。</p>
<p><img src="/../../images/640-20210628183551240.png" alt="图片"></p>
<p>有一些规则源存储不支持事件通知机制，比如关系数据库，Sentinel 也提供了定时刷新规则，比如每隔几秒来刷新内存里面的限流规则。下面是 redis 规则源定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis 地址</span></span><br><span class="line"><span class="type">RedisConnectionConfig</span> <span class="variable">redisConf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisConnectionConfig</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 反序列化算法</span></span><br><span class="line">Converter&lt;String, List&lt;FlowRule&gt;&gt; converter = r -&gt; JSON.parseArray(r, FlowRule.class);</span><br><span class="line"><span class="comment">// 定义规则源，包含全量和增量部分</span></span><br><span class="line"><span class="comment">// 全量是一个字符串key，增量是 pubsub channel key</span></span><br><span class="line">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; redisDataSource = <span class="keyword">new</span> <span class="title class_">RedisDataSource</span>&lt;List&lt;FlowRule&gt;&gt;(redisConf,<span class="string">&quot;app_key&quot;</span>, <span class="string">&quot;app_pubsub_key&quot;</span>, converter);</span><br><span class="line">FlowRuleManager.register2Property(redisDataSource.getProperty());</span><br></pre></td></tr></table></figure>

<h2 id="健康状态上报与检查"><a href="#健康状态上报与检查" class="headerlink" title="健康状态上报与检查"></a>健康状态上报与检查</h2><p>接入 Sentinel 的应用服务器需要将自己的限流状态上报到 Dashboard，这样就可以在后台实时呈现所有服务的限流状态。Sentinel 使用拉模型来上报状态，它在当前进程注册了一个 HTTP 服务，Dashboard 会定时来访问这个 HTTP 服务来获取每个服务进程的健康状况和限流信息。</p>
<p><img src="/../../images/640-20210628183551234.png" alt="图片"><br>Sentinel 需要将服务的地址以心跳包的形式上报给 Dashboard，如此 Dashboard 才知道每个服务进程的 HTTP 健康服务的具体地址。如果进程下线了，心跳包就停止了，那么对应的地址信息也会过期，如此Dashboard 就能准实时知道当前的有效进程服务列表。</p>
<p>当前版本开源的 Dashboard 不具备持久化能力，当管理员在后台修改了规则时，它会直接通过 HTTP 健康服务地址来同步服务限流规则直接控制具体服务进程。如果应用重启，规则将自动重置。如果你希望通过 Redis 来持久化规则源，那就需要自己定制 Dashboard。定制不难，实现它内置的持久化接口即可。</p>
<h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><p>前面我们说到分布式限流需要另起一个 Ticket Server，由它来分发 Ticket，能够获取到 Ticket 的请求才可以允许执行临界区代码，Ticket 服务器也需要提供规则输入源。</p>
<p><img src="/../../images/640-20210628184734252" alt="图片"></p>
<p>Ticket Server 是单点的，如果 Ticket Server 挂掉了，应用服务器限流将自动退化为本地模式。</p>
<h2 id="框架适配"><a href="#框架适配" class="headerlink" title="框架适配"></a>框架适配</h2><p>Sentinel 保护的临界区是代码块，通过拓展临界区的边界就可以直接适配各种框架，比如 Dubbo、SpringBoot 、GRPC 和消息队列等。每一种框架的适配器会在请求边界处统一定义临界区作用域，用户就可以完全不必手工添加熔断保护性代码，在毫无感知的情况下就自动植入了限流保护功能。</p>
<h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>限流在于限制流量，也就是 QPS 或者线程的并发数，还有一种情况是请求处理不稳定或者服务损坏，导致请求处理时间过长或者老是频繁抛出异常，这时就需要对服务进行降级处理。所谓的降级处理和限流处理在形式上没有明显差异，也是以同样的形式定义一个临界区，区别是需要对抛出来的异常需要进行统计，这样才可以知道请求异常的频率，有了这个指标才会触发降级。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义降级规则</span></span><br><span class="line">List&lt;DegradeRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">DegradeRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DegradeRule</span>();</span><br><span class="line">rule.setResource(<span class="string">&quot;tutorial&quot;</span>);</span><br><span class="line"><span class="comment">// 5s内异常不得超出10</span></span><br><span class="line">rule.setCount(<span class="number">10</span>);</span><br><span class="line">rule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT);</span><br><span class="line">rule.setLimitApp(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">rules.add(rule);</span><br><span class="line">DegradeRuleManager.loadRules(rules);</span><br><span class="line"></span><br><span class="line"><span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  entry = SphU.entry(key);</span><br><span class="line">  <span class="comment">// 业务代码在这里</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">  <span class="comment">// 记录异常</span></span><br><span class="line">  <span class="keyword">if</span> (!BlockException.isBlockException(t)) &#123;</span><br><span class="line">    Tracer.trace(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>触发限流时会抛出 FlowException，触发熔断时会抛出 DegradeException，这两个异常都继承自 BlockException。</p>
<h2 id="热点限流"><a href="#热点限流" class="headerlink" title="热点限流"></a>热点限流</h2><p>还有一种特殊的动态限流规则，用于限制动态的热点资源。内部采用 LRU 算法计算出 topn 热点资源，然后对 topn 的资源进行限流，同时还提供特殊资源特殊对待的参数设置。<br>比如在下面的例子中限定了同一个用户的访问频次，同时也限定了同一本书的访问频次，但是对于某个特殊用户和某个特殊的书进行了特殊的频次设置。</p>
<p><img src="/../../images/640-4876551.jpeg" alt="图片">图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ParamFlowRule</span> <span class="variable">ruleUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParamFlowRule</span>();</span><br><span class="line"><span class="comment">// 同样的 userId QPS 不得超过 10</span></span><br><span class="line">ruleUser.setParamIdx(<span class="number">0</span>).setCount(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// qianwp用户特殊对待，QPS 上限是 100</span></span><br><span class="line"><span class="type">ParamFlowItem</span> <span class="variable">uitem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParamFlowItem</span>(<span class="string">&quot;qianwp&quot;</span>, <span class="number">100</span>, String.class);</span><br><span class="line">ruleUser.setParamFlowItemList(Collections.singletonList(uitem));</span><br><span class="line"></span><br><span class="line"><span class="type">ParamFlowRule</span> <span class="variable">ruleBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParamFlowRule</span>();</span><br><span class="line"><span class="comment">// 同样的 bookId QPS 不得超过 20</span></span><br><span class="line">ruleBook.setParamIdx(<span class="number">1</span>).setCount(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// redis 的书特殊对待，QPS 上限是 100</span></span><br><span class="line"><span class="type">ParamFlowItem</span> <span class="variable">bitem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParamFlowItem</span>(<span class="string">&quot;redis&quot;</span>, <span class="number">100</span>, String.class);</span><br><span class="line">ruleBook.setParamFlowItemList(Collections.singletonList(item));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载规则</span></span><br><span class="line">List&lt;ParamFlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">rules.add(ruleUser);</span><br><span class="line">rules.add(ruleBook);</span><br><span class="line">ParamFlowRuleManager.loadRules(rules)；</span><br><span class="line"></span><br><span class="line"><span class="comment">// userId的用户访问bookId的书</span></span><br><span class="line"><span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> Sphu.entry(key, EntryType.IN, <span class="number">1</span>, userId, bookId);</span><br></pre></td></tr></table></figure>


<p>热点限流的难点在于如何统计定长滑动窗口时间内的热点资源的访问量，Sentinel 设计了一个特别的数据结构叫 LeapArray，内部有较为复杂的算法设计后续需要单独分析。</p>
<h2 id="系统自适应限流-——-过载保护"><a href="#系统自适应限流-——-过载保护" class="headerlink" title="系统自适应限流 —— 过载保护"></a>系统自适应限流 —— 过载保护</h2><p>当系统的负载较高时，为了避免系统被洪水般的请求冲垮，需要对当前的系统进行限流保护。保护的方式是逐步限制 QPS，观察到系统负载恢复后，再逐渐放开 QPS，如果系统的负载又下降了，就再逐步降低 QPS。如此达到一种动态的平衡，这里面涉及到一个特殊的保持平衡的算法。系统的负载指数存在一个问题，它取自操作系统负载的 load1 参数，load1 参数更新的实时性不足，从 load1 超标到恢复的过程存在一个较长的过渡时间，如果使用一刀切方案，在这段恢复时间内阻止任何请求，待 load1 恢复后又立即放开请求，势必会导致负载的大起大落，服务处理的时断时开。为此作者将 TCP 拥塞控制算法的思想移植到这里实现了系统平滑的过载保护功能。这个算法很精巧，代码实现并不复杂，效果却是非常显著。</p>
<p>算法定义了一个稳态公式，稳态一旦打破，系统负载就会出现波动。算法的本质就是当稳态被打破时，通过持续调整相关参数来重新建立稳态。</p>
<p><img src="/../../images/640-20210628183551258" alt="图片">图片</p>
<p>稳态公式很简单：ThreadNum * (1&#x2F;ResponseTime) &#x3D; QPS，这个公式很好理解，就是系统的 QPS 等于线程数乘以单个线程每秒可以执行的请求数量。系统会实时采样统计所有临界区的 QPS 和 ResponseTime，就可以计算出相应的稳态并发线程数。当负载超标时，通过判定当前的线程数是否超出稳态线程数就可以明确是否需要拒绝当前的请求。</p>
<p>定义自适应限流规则需要提供多个参数</p>
<ol>
<li><p>系统的负载水平线，超过这个值时触发过载保护功能</p>
</li>
<li><p>当过载保护超标时，允许的最大线程数、最长响应时间和最大 QPS，可以不设置</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SystemRule&gt; rules = new ArrayList&lt;SystemRule&gt;();</span><br><span class="line">SystemRule rule = new SystemRule();</span><br><span class="line">rule.setHighestSystemLoad(3.0);</span><br><span class="line">rule.setAvgRt(10);</span><br><span class="line">rule.setQps(20);</span><br><span class="line">rule.setMaxThread(10);</span><br><span class="line">rules.add(rule);</span><br><span class="line">SystemRuleManager.loadRules(Collections.singletonList(rule));</span><br></pre></td></tr></table></figure>


<p>从代码中也可以看出系统自适应限流规则不需要定义资源名称，因为它是全局的规则，会自动应用到所有的临界区。如果当负载超标时，所有临界区资源将一起勒紧裤腰带渡过难关。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-06-28T10:35:23.000Z" title="2021/6/28 下午6:35:23">2021-06-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-06-28T10:35:23.000Z" title="2021/6/28 下午6:35:23">2021-06-28</time></span><span class="level-item">2 minutes read (About 346 words)</span></div></div><div class="content"><h1 id="2-4-60中间件介绍"><a href="#2-4-60中间件介绍" class="headerlink" title="2.4.60中间件介绍"></a>2.4.60中间件介绍</h1><h2 id="一、分布式消息中间件"><a href="#一、分布式消息中间件" class="headerlink" title="一、分布式消息中间件"></a>一、分布式消息中间件</h2><h4 id="1-1ActiveMQ"><a href="#1-1ActiveMQ" class="headerlink" title="1.1ActiveMQ -"></a>1.1ActiveMQ -</h4><h4 id="1-2RabbitMQ"><a href="#1-2RabbitMQ" class="headerlink" title="1.2RabbitMQ"></a>1.2RabbitMQ</h4><h4 id="1-3Kafka-性能最高，不支持事务，持久化"><a href="#1-3Kafka-性能最高，不支持事务，持久化" class="headerlink" title="1.3Kafka - 性能最高，不支持事务，持久化"></a>1.3Kafka - 性能最高，不支持事务，持久化</h4><h4 id="1-4RocketMQ-阿里滴滴开发，后续不一定会更新"><a href="#1-4RocketMQ-阿里滴滴开发，后续不一定会更新" class="headerlink" title="1.4RocketMQ - 阿里滴滴开发，后续不一定会更新"></a>1.4RocketMQ - 阿里滴滴开发，后续不一定会更新</h4><p><strong>使用场景：</strong></p>
<p>​	消息中间件监控数据<br>​	异步数据传输场景<br>​	削峰填谷<br>​	任务调度<br>​	海量数据同步场景<br>​	分布式事务场景<br>​	日志管理场景<br>​	大数据分析场景</p>
<h2 id="二、负载均衡"><a href="#二、负载均衡" class="headerlink" title="二、负载均衡"></a>二、负载均衡</h2><p>1.Nginx</p>
<p>2.LVS负载均衡</p>
<p>3.KeepAlive</p>
<p>4.CDN</p>
<h2 id="三、缓存中间件"><a href="#三、缓存中间件" class="headerlink" title="三、缓存中间件"></a>三、缓存中间件</h2><p>1.MemCache </p>
<p>2.Redis - 分布式架构</p>
<h2 id="四、数据库中间件"><a href="#四、数据库中间件" class="headerlink" title="四、数据库中间件"></a>四、数据库中间件</h2><p>1.Mycat</p>
<p>2.ShardingJDBC</p>
<h2 id="五、案例分析"><a href="#五、案例分析" class="headerlink" title="五、案例分析"></a>五、案例分析</h2><p>算法数据保存<br>订单数据的消息分发<br>分布式事务<br>海量的容错<br>分布式锁<br>分布式会话<br>分库分表</p>
<h3 id="何谓分布式系统呢？"><a href="#何谓分布式系统呢？" class="headerlink" title="何谓分布式系统呢？"></a>何谓分布式系统呢？</h3><p>就是一个请求由服务器端的多个服务协同处理完成。和单体架构不同的是，单体架构是一个请求发起jvm调度线程（确切的是tomcat线程池）分配线程Thread来处理请求直到释放，而分布式系统：一个请求是有多个系统共同来协同完成，jvm和环境都是独立的。</p>
<h3 id="如何选择一个中间件？"><a href="#如何选择一个中间件？" class="headerlink" title="如何选择一个中间件？"></a>如何选择一个中间件？</h3><p>1.是否支持集群 - 高可用<br>2.是否跨平台 -<br>3.持久化功能 - 高可靠</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/6/">Previous</a></div><div class="pagination-next"><a href="/page/8/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/6/">6</a></li><li><a class="pagination-link is-current" href="/page/7/">7</a></li><li><a class="pagination-link" href="/page/8/">8</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/14/">14</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Tonygeli"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tonygeli</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SH</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">133</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tonygeli" target="_blank" rel="noopener">Follow</a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-06T10:22:12.940Z">2022-05-06</time></p><p class="title"><a href="/2022/05/06/90002%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">90002 快速了解TCP的流量控制与拥塞控制</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-06T10:05:30.000Z">2022-05-06</time></p><p class="title"><a href="/2022/05/06/90001%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">90001 分布式事务</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-05T16:00:00.000Z">2022-05-06</time></p><p class="title"><a href="/2022/05/06/90000Hexo%E9%85%8D%E7%BD%AE%E4%B8%8EIcarus%E4%B8%BB%E9%A2%98/">Hexo配置与Icarus主题</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-05T16:00:00.000Z">2022-05-06</time></p><p class="title"><a href="/2022/05/06/213Linux/Docker/Ubuntu%20LNMP/">Ubuntu LNMP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-04T16:29:42.493Z">2022-05-05</time></p><p class="title"><a href="/2022/05/05/90000%E6%96%87%E7%AB%A0/Stream%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"> </a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">September 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">July 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">June 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">May 2021</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">April 2021</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">March 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">February 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">November 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus/"><span class="tag">Icarus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8B%E5%8A%A1/"><span class="tag">事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2022 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>