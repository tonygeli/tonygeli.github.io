<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>LILAIQUN</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LILAIQUN"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LILAIQUN"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="LILAIQUN"><meta property="og:url" content="https://tonygeli.github.io/"><meta property="og:site_name" content="LILAIQUN"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tonygeli.github.io/img/og_image.png"><meta property="article:author" content="Tonygeli"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonygeli.github.io"},"headline":"LILAIQUN","image":["https://tonygeli.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tonygeli"},"publisher":{"@type":"Organization","name":"LILAIQUN","logo":{"@type":"ImageObject","url":"https://tonygeli.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?1ecc72096a22e2426f0bc13519c3c3c7";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/article-17">Share</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-14T02:54:36.000Z" title="2021/5/14 上午10:54:36">2021-05-14</time>发表</span><span class="level-item"><time dateTime="2021-05-14T02:54:36.000Z" title="2021/5/14 上午10:54:36">2021-05-14</time>更新</span><span class="level-item">8 分钟读完 (大约1270个字)</span></div></div><div class="content"><h1 id="2-4-2-Spring-Bean依赖注入"><a href="#2-4-2-Spring-Bean依赖注入" class="headerlink" title="2.4.2 Spring Bean依赖注入"></a>2.4.2 Spring Bean依赖注入</h1><h2 id="一、什么是Spring中的依赖注入？"><a href="#一、什么是Spring中的依赖注入？" class="headerlink" title="一、什么是Spring中的依赖注入？"></a>一、什么是Spring中的依赖注入？</h2><p>依赖注入是控制反转（IoC）的一个方面，它是一个通用概念，它可以用许多不同的方式表达。这个概念说你不创建你的对象，而是描述它们应该如何创建。您不能在代码中直接连接组件和服务，而是描述配置文件中哪些组件需要哪些服务。然后，一个容器（IOC容器）负责将其全部挂起。</p>
<h2 id="二、有哪些不同类型的IoC（依赖注入）？"><a href="#二、有哪些不同类型的IoC（依赖注入）？" class="headerlink" title="二、有哪些不同类型的IoC（依赖注入）？"></a>二、有哪些不同类型的IoC（依赖注入）？</h2><p>1.构造函数的依赖注入：当容器调用具有许多参数的类构造函数时，完成基于构造函数的DI，每个参数表示对其他类的依赖。<br>2.Setter的依赖注入：基于Setter的DI是在调用无参数构造函数或无参数静态工厂方法来实例化bean之后，通过容器调用bean上的setter方法来完成的。</p>
<h2 id="三、Spring-bean是什么？"><a href="#三、Spring-bean是什么？" class="headerlink" title="三、Spring bean是什么？"></a>三、Spring bean是什么？</h2><p>Spring Beans是构成Spring应用程序主干的Java对象。它们由Spring IoC容器实例化，组装和管理。这些bean是使用提供给容器的配置元数据创建的（以XML定义、注解）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;testController&quot;</span> class=<span class="string">&quot;com.**.TestController&quot;</span> scope=<span class="string">&quot;prototype&quot;</span> init-method=<span class="string">&quot;init&quot;</span> destroy-method=<span class="string">&quot;destory&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span>			<span class="comment">// 创建多实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="meta">@PreDestory</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scope属性：<br>1.singleton： 表示在spring容器中的单例，通过spring容器获得该bean时总是返回唯一的实例；<br>2.prototype：与单例模式相反，表示为每一个bean请求都会提供一个实例；<br>3.request：在请求范围内会为每一个来自客户端的网络请求提供一个实例，在请求完成后，bean会失效并被垃圾回收器回收；<br>4.session：与请求范围类似，表示确保每个session中有个Bean的实例，在session过期后随之消失；<br>5.global-session：表示在全局会话内有效。</p>
<h2 id="四、有三种方式向Spring-容器提供元数据"><a href="#四、有三种方式向Spring-容器提供元数据" class="headerlink" title="四、有三种方式向Spring 容器提供元数据:"></a>四、有三种方式向Spring 容器提供元数据:</h2><p>1.XML配置文件<br>2.基于注解配置<br>3.基于Java的配置</p>
<p>基于Java类定义Bean配置元数据，其实就是通过Java类定义Spring配置元数据，且直接消除XML配置文件。<br>首先让我们看一下基于Java类如何定义Bean配置元数据，具体步骤如下：<br>  1.使用@Configuration注解需要作为配置的类，表示该类将定义Bean的元数据<br>  2.使用@Bean注解相应的方法，该方法名默认就是Bean的名称，该方法返回值就是Bean的对象。<br>  3.AnnotationConfigApplicationContext或子类进行加载基于java类的配置<br><strong>注意</strong>：<strong>使用bean注解的方法不能是private、final、static的。</strong></p>
<p>基于Java方式的配置方式不是为了完全替代基于XML方式的配置，两者可以结合使用，因此可以有两种结合使用方式：<br>    <strong>1.在基于Java方式的配置类中引入基于XML方式的配置文件</strong>	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;message&quot;</span> class=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg index=<span class="string">&quot;0&quot;</span> value=<span class="string">&quot;test&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration(&quot;ctxConfig&quot;)</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:com/jike/***/appCtx.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在java程序中使用**@** <strong>ImportResource</strong>导入了XML的配置文件</p>
<p>​	<strong>2.在基于XML方式的配置文件中中引入基于Java方式的配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;context:annotation-config/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;ctxConfig&quot;</span> class=“com.jike.***..ApplicationContextConfig<span class="string">&quot;/&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">//测试类</span></span><br><span class="line"><span class="string">public void testXmlConfig() &#123;</span></span><br><span class="line"><span class="string">  String configLocations[] = &#123;&quot;</span> classpath:com/jike<span class="comment">/***/</span>appCtx.xml<span class="string">&quot;&#125;;</span></span><br><span class="line"><span class="string">  ApplicationContext ctx = new ClassPathXmlApplicationContext(configLocations);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到在XML的配置文件当中将java的配置类当中Bean来声明，第一行的是开启注解驱动支持。<br>值得注意的是必须得配置 <a href="context:annotation-config/">context:annotation-config/</a> 在XML配置文件中。</p>
<p>Spring提供了一个AnnotationConfigApplicanContext类，能够直接通过标注@Configuration的Java类启动Spring容器：<br><strong>通过构造函数加载配置类:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConf.class);</span><br></pre></td></tr></table></figure>

<p><strong>通过编码方式注册配置类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">ctx.register(DaoConfig.class);</span><br><span class="line">ctx.register(ServiceConfig.class);</span><br><span class="line">ctx.refresh();</span><br></pre></td></tr></table></figure>

<p>可以看到ctx注册了多个configuration类，然后通过refresh类来刷新容器以应用这些配置文件。<br>可以通过代码一个个的引入配置类，当然也可以使用**@Import**注解来引入配置类</p>
<p><strong>引入多个配置类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(DaoConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：不同配置方式比较</strong></p>
<table>
<thead>
<tr>
<th>Bean</th>
<th>XML配置文件</th>
<th>注解配置</th>
<th>Java的配置</th>
</tr>
</thead>
<tbody><tr>
<td>Bean定义</td>
<td><bean id=""></bean></td>
<td>@Component</td>
<td>标注了@Configuration的java类中，类方法上标注了@Bean</td>
</tr>
<tr>
<td>Bean名称</td>
<td>id或name&#x3D;”userDao”</td>
<td>@Component(“userDao”)</td>
<td>@Bean(“userDao”)</td>
</tr>
<tr>
<td>Bean注入</td>
<td>通过<property>子元素或通过p命名空间的动态属性注入</td>
<td>通过标出@Autowired，按类型匹配自动,配合@Qualifier按名称匹配</td>
<td>1.@Autowired方法入参绑定Bean 2.配置类的@Bean方法注入</td>
</tr>
<tr>
<td>生命过程方法</td>
<td>通过<bean>的init-method和destory-method属性指定Bean实现类方法名</td>
<td>@PostContruct和@PreDestroy</td>
<td>@Bean(initMethod &#x3D; “”, destroyMethod &#x3D; “”)</td>
</tr>
<tr>
<td>作用范围</td>
<td><bean>的scope属性</td>
<td>@Scope</td>
<td>@Scope</td>
</tr>
<tr>
<td>延迟初始化</td>
<td>Lazy-init,默认为default</td>
<td>@Lazy</td>
<td>@Lazy</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-13T11:17:55.000Z" title="2021/5/13 下午7:17:55">2021-05-13</time>发表</span><span class="level-item"><time dateTime="2021-05-13T11:17:55.000Z" title="2021/5/13 下午7:17:55">2021-05-13</time>更新</span><span class="level-item">41 分钟读完 (大约6162个字)</span></div></div><div class="content"><h1 id="2-4-3-Spring注解"><a href="#2-4-3-Spring注解" class="headerlink" title="2.4.3 Spring注解"></a>2.4.3 Spring注解</h1><p>注解是个好东西，但好东西我们也是看见过，整理过，理解过，用过才知道好。不求我们每个都记住，但求保有印象，在需要的时候能提取出来再查找相关资料，平时工作就不会显得那么被动了。</p>
<h2 id="1-Configuration注解"><a href="#1-Configuration注解" class="headerlink" title="1.@Configuration注解"></a>1.@Configuration注解</h2><p>该类等价 与XML中配置beans，相当于Ioc容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean，与xml中配置的bean意思一样。</p>
<p>@Configuration注解的类必需使用<code>context:component-scanbase-package=&quot;XXX&quot;</code>扫描.如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;</span><br><span class="line">	<span class="comment">//在properties文件里配置  </span></span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;wx_appid&#125;&quot;)</span> </span><br><span class="line">  <span class="keyword">public</span> String appid;</span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">MainConfig</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> WxMpService <span class="title function_">wxMpService</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="type">WxMpService</span> <span class="variable">wxMpService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WxMpServiceImpl</span>();</span><br><span class="line">    wxMpService.setWxMpConfigStorage(wxMpConfigStorage());    </span><br><span class="line">    <span class="keyword">return</span> wxMpService;</span><br><span class="line">	&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个MainConfig，用@Configuration注解，那MainConfig相当于xml里的beans,里面用@Bean注解的和xml里定义的bean等价，用<code>context:component-scanbase-package=”XXX”</code>扫描该类，最终我们可以在程序里用<code>@AutoWired</code>或<code>@Resource</code>注解取得用<code>@Bean</code>注解的<code>bean</code>，和用xml先配置bean然后在程序里自动注入一样。目的是减少xml里配置。</p>
<h2 id="2-Value注解"><a href="#2-Value注解" class="headerlink" title="2.@Value注解"></a>2.@Value注解</h2><p>为了简化从properties里取配置，可以使用@Value, 可以在properties文件中的配置值。在dispatcher-servlet.xml里引入properties文件。在程序里使用@Value:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;wx_appid&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String appid；</span><br></pre></td></tr></table></figure>

<p>即使给变量赋了初值也会以配置文件的值为准。</p>
<h2 id="3-Controller-Service-Repository-Component"><a href="#3-Controller-Service-Repository-Component" class="headerlink" title="3.@Controller,@Service,@Repository,@Component"></a>3.@Controller,@Service,@Repository,@Component</h2><p>目前4种注解意思是一样，并没有什么区别，区别只是名字不同。使用方法：</p>
<p>​	1.使用context:component-scanbase-package&#x3D;”XXX”&#x2F;扫描被注解的类<br>​	2.在类上写注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-PostConstruct-和-PreDestory"><a href="#4-PostConstruct-和-PreDestory" class="headerlink" title="4.@PostConstruct 和 @PreDestory"></a>4.@PostConstruct 和 @PreDestory</h2><p>实现初始化和销毁bean之前进行的操作，只能有一个方法可以用此注释进行注释，方法不能有参数，返回值必需是void,方法需要是非静态的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line">	<span class="meta">@PostConstruct</span>  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;		<span class="comment">// 在构造方法和init方法(如果有的话)之间得到调用，且只会执行一次。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;初始化&quot;</span>);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@PreDestroy</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">dostory</span><span class="params">()</span>&#123;		<span class="comment">// 注解的方法在destory()方法调用后得到执行。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;销毁&quot;</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程图：</p>
<p><img src="/../../images/2e803639d7ea863b9cdcc0abde546050.png" alt="2e803639d7ea863b9cdcc0abde546050.png"></p>
<p>引深一点，Spring 容器中的 Bean 是有生命周期的，Spring 允许在 Bean 在初始化完成后以及 Bean 销毁前执行特定的操作，常用的设定方式有以下三种：</p>
<p>1.通过实现 InitializingBean&#x2F;DisposableBean 接口来定制初始化之后&#x2F;销毁之前的操作方法；</p>
<p>2.通过 元素的 init-method&#x2F;destroy-method属性指定初始化之后 &#x2F;销毁之前调用的操作方法；</p>
<p>3.在指定方法上加上@PostConstruct 或@PreDestroy注解来制定该方法是在初始化之后还是销毁之前调用</p>
<p>但他们之前并不等价。即使3个方法都用上了，也有先后顺序.</p>
<p>Constructor &gt; @PostConstruct &gt;InitializingBean &gt; init-method</p>
<ol start="5">
<li>@Primary<br>自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常。</li>
</ol>
<p>例如：</p>
<p>@Component public class Apple implements Fruit{<br>@Override  public String hello() {      return “我是苹果”;  }<br>}</p>
<p>@Component @Primary public class Pear implements Fruit{<br>@Override  public String hello(String lyrics) {      return “梨子”;  }<br>}</p>
<p>public class FruitService {<br>&#x2F;&#x2F;Fruit有2个实例子类，因为梨子用@Primary，那么会使用Pear注入  @Autowired  private Fruit fruit;</p>
<p>public String hello(){      return fruit.hello();  }<br>}</p>
<ol start="6">
<li><p>@Lazy(true)<br>用于指定该Bean是否取消预初始化，用于注解类，延迟初始化。</p>
</li>
<li><p>@Autowired<br>Autowired默认先按byType，如果发现找到多个bean，则，又按照byName方式比对，如果还有多个，则报出异常。</p>
</li>
</ol>
<p>1.可以手动指定按byName方式注入，使用@Qualifier。</p>
<p>&#x2F;&#x2F;通过此注解完成从spring配置文件中 查找满足Fruit的bean,然后按&#x2F;&#x2F;@Qualifier指定pean</p>
<p>@Autowired</p>
<p>@Qualifier(“pean”)</p>
<p>public Fruit fruit;</p>
<p>2.如果要允许null 值，可以设置它的required属性为false，如：</p>
<p>@Autowired(required&#x3D;false)</p>
<p>public Fruit fruit;</p>
<ol start="8">
<li>@Resource<br>默认按 byName自动注入,如果找不到再按byType找bean,如果还是找不到则抛异常，无论按byName还是byType如果找到多个，则抛异常。</li>
</ol>
<p>可以手动指定bean,它有2个属性分别是name和type，使用name属性，则使用byName的自动注入，而使用type属性时则使用byType自动注入。</p>
<p>@Resource(name&#x3D;”bean名字”)</p>
<p>或</p>
<p>@Resource(type&#x3D;”bean的class”)</p>
<p>这个注解是属于J2EE的，减少了与spring的耦合。</p>
<ol start="9">
<li>@Async<br>java里使用线程用3种方法：</li>
</ol>
<p>继承Thread，重写run方法<br>实现Runnable,重写run方法<br>使用Callable和Future接口创建线程，并能得到返回值。<br>前2种简单，第3种方式特别提示一下，例子如下：</p>
<p>class MyCallable implements Callable {  private int i &#x3D; 0;  &#x2F;&#x2F; 与run()方法不同的是，call()方法具有返回值  @Override  public Integer call() {  int sum &#x3D; 0;  for (; i &lt; 100; i++) {  System.out.println(Thread.currentThread().getName() + “ “ + i);  sum +&#x3D; i;  }  return sum;  } }</p>
<p>main方法：</p>
<p>public static void main(String[] args) {  Callable myCallable &#x3D; new MyCallable(); &#x2F;&#x2F; 创建MyCallable对象  FutureTask ft &#x3D; new FutureTask(myCallable); &#x2F;&#x2F;使用FutureTask来包装MyCallable对象  for (int i &#x3D; 0; i &lt; 100; i++) {  System.out.println(Thread.currentThread().getName() + “ “ + i);  if (i &#x3D;&#x3D; 30) {  Thread thread &#x3D; new Thread(ft); &#x2F;&#x2F;FutureTask对象作为Thread对象的target创建新的线程  thread.start(); &#x2F;&#x2F;线程进入到就绪状态  }  }  System.out.println(“主线程for循环执行完毕..”);  try {  int sum &#x3D; ft.get(); &#x2F;&#x2F;取得新创建的新线程中的call()方法返回的结果  System.out.println(“sum &#x3D; “ + sum);  } catch (InterruptedException e) {  e.printStackTrace();  } catch (ExecutionException e) {  e.printStackTrace();  } }</p>
<p>而使用@Async可视为第4种方法。基于@Async标注的方法，称之为异步方法,这个注解用于标注某个方法或某个类里面的所有方法都是需要异步处理的。被注解的方法被调用的时候，会在新线程中执行，而调用它的方法会在原来的线程中执行。</p>
<p>application.xml形势的配置：</p>
<p>第一步配置XML。</p>
<p>参数解读：</p>
<p>配置参数：</p>
<p>id：当配置多个executor时，被@Async(“id”)指定使用；也被作为线程名的前缀。</p>
<p>pool-size：</p>
<p>core size：最小的线程数，缺省：1</p>
<p>max size：最大的线程数，缺省：Integer.MAX_VALUE</p>
<p>queue-capacity：当最小的线程数已经被占用满后，新的任务会被放进queue里面，当这个queue的capacity也被占满之后，pool里面会创建新线程处理这个任务，直到总线程数达到了max size，这时系统会拒绝这个任务并抛出TaskRejectedException异常(缺省配置的情况下，可以通过rejection-policy来决定如何处理这种情况)。缺省值为：Integer.MAX_VALUE</p>
<p>keep-alive：超过core size的那些线程，任务完成后，再经过这个时长(秒)会被结束掉</p>
<p>rejection-policy：当pool已经达到max size的时候，如何处理新任务</p>
<p>ABORT(缺省)：抛出TaskRejectedException异常，然后不执行DISCARD：不执行，也不抛出异常</p>
<p>DISCARD_OLDEST：丢弃queue中最旧的那个任务</p>
<p>CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</p>
<p>第二步在类或方法上添加@Async，当调用该方法时，则该方法即是用异常执行的方法单独开个新线程执行。</p>
<p>@Async(“可以指定执行器id，也可以不指定”)  public static void testAsyncVoid (){  try {  &#x2F;&#x2F;让程序暂停100秒，相当于执行一个很耗时的任务  System.out.println(“异常执行打印字符串”);  Thread.sleep(100000);  } catch (InterruptedException e) {  e.printStackTrace();  }  }</p>
<p>当在外部调用testAsync方法时即在新线程中执行，由上面执行器去维护线程。</p>
<p>总结：先用context:component-scan去扫描注解，让spring能识别到@Async注解，然后task:annotation-driven去驱动@Async注解，并可以指定默认的线程执行器executor。那么当用@Async注解的方法或类得到调用时，线程执行器会创建新的线程去执行。</p>
<p>上面方法是无返回值的情况，还有异常方法有返回值的例子。</p>
<p>@Async public Future testAsyncReturn () {  System.out.println(“Execute method asynchronously - “  + Thread.currentThread().getName());  try {  Thread.sleep(5000);  return new AsyncResult(“hello world !!!!”);  } catch (InterruptedException e) {  &#x2F;&#x2F;  }  return null; }</p>
<p>返回的数据类型为Future类型，接口实现类是AsyncResult.</p>
<p>调用方法如下：</p>
<p>public void test(){  Future future &#x3D; cc.testAsyncReturn();  while (true) { &#x2F;&#x2F;&#x2F;这里使用了循环判断，等待获取结果信息  if (future.isDone()) { &#x2F;&#x2F;判断是否执行完毕  System.out.println(“Result from asynchronous process - “ + future.get());  break;  }  System.out.println(“Continue doing something else. “);  Thread.sleep(1000);  } }</p>
<p>通过不停的检查Future的状态来获取当前的异步方法是否执行完毕</p>
<p>参考文章</p>
<p>编程的方式使用@Async:</p>
<p>@Configuration @EnableAsync public class SpringConfig {  private int corePoolSize &#x3D; 10; private int maxPoolSize &#x3D; 200; private int queueCapacity &#x3D; 10; private String ThreadNamePrefix &#x3D; “MyLogExecutor-“;</p>
<p>@Bean  public Executor logExecutor() {      ThreadPoolTaskExecutor executor &#x3D; new ThreadPoolTaskExecutor();      executor.setCorePoolSize(corePoolSize);      executor.setMaxPoolSize(maxPoolSize);      executor.setQueueCapacity(queueCapacity);      executor.setThreadNamePrefix(ThreadNamePrefix);      &#x2F;&#x2F; rejection-policy：当pool已经达到max size的时候，如何处理新任务      &#x2F;&#x2F; CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行      executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());      executor.initialize();      return executor;  }<br>}</p>
<p>10.@Named<br>@Named和Spring的@Component功能相同。@Named可以有值，如果没有值生成的Bean名称默认和类名相同。比如</p>
<p>@Named</p>
<p>public class Person</p>
<p>或</p>
<p>@Named(“cc”)</p>
<p>public class Person</p>
<ol start="11">
<li>@Inject<br>使用@Inject需要引用javax.inject.jar，它与Spring没有关系，是jsr330规范。</li>
</ol>
<p>与@Autowired有互换性。</p>
<ol start="12">
<li>@Singleton<br>只要在类上加上这个注解，就可以实现一个单例类，不需要自己手动编写单例实现类。</li>
</ol>
<p>13.@Valid,@Valided<br>@Valid</p>
<p>网上一大片使用@Valid失效不能用的情况。为什么呢？</p>
<p>1.@Valid必需使用在以@RequestBody接收参数的情况下。</p>
<p>2.使用ajax以POST方式提示数据，禁止用Fiddler以及浏览器直接访问的方式测试接口</p>
<p>3.用添加注解驱动。</p>
<p>4.@Valid是应用在javabean上的校验。</p>
<ol start="5">
<li>org.hibernate  hibernate-validator  4.2.0.Final   com.fasterxml.jackson.core  jackson-annotations  2.5.3    com.fasterxml.jackson.core  jackson-core  2.5.3    com.fasterxml.jackson.core  jackson-databind  2.5.3    org.codehaus.jackson  jackson-mapper-asl  1.9.8    com.fasterxml.jackson.module  jackson-module-jaxb-annotations  2.5.3</li>
</ol>
<p>这些jar包是需要的。@Valid是使用hibernate validation的时候使用，可参数下面介绍的@RequestBody</p>
<p>6.@Valid下后面紧跟BindingResult result，验证结果保存在result</p>
<p>例如：</p>
<p>@RequestMapping(“&#x2F;test”)  public String testValid(@Valid User user, BindingResult result){  if (result.hasErrors()){  List errorList &#x3D; result.getAllErrors();  for(ObjectError error : errorList){  System.out.println(error.getDefaultMessage());  }  }  return “test”; }</p>
<p>在入参User上添加了@Valid做校验，在User类里属性上实行实际的特定校验。</p>
<p>例如在User的name属性上加</p>
<p>@NotBlank</p>
<p>private String name;</p>
<p>全部参数校验如下：</p>
<p>空检查</p>
<p>@Null 验证对象是否为null</p>
<p>@NotNull 验证对象是否不为null, 无法查检长度为0的字符串</p>
<p>@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.</p>
<p>@NotEmpty 检查约束元素是否为NULL或者是EMPTY.</p>
<p>Booelan检查</p>
<p>@AssertTrue 验证 Boolean 对象是否为 true</p>
<p>@AssertFalse 验证 Boolean 对象是否为 false</p>
<p>长度检查</p>
<p>@Size(min&#x3D;, max&#x3D;) 验证对象(Array,Collection,Map,String)长度是否在给定的范围之内</p>
<p>@Length(min&#x3D;, max&#x3D;)验证注解的元素值长度在min和max区间内</p>
<p>日期检查</p>
<p>@Past 验证 Date 和 Calendar 对象是否在当前时间之前</p>
<p>@Future 验证 Date 和 Calendar 对象是否在当前时间之后</p>
<p>@Pattern 验证 String 对象是否符合正则表达式的规则</p>
<p>数值检查，建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为””,Integer为null</p>
<p>@Min(value&#x3D;””) 验证 Number 和 String 对象是否大等于指定的值</p>
<p>@Max(value&#x3D;””) 验证 Number 和 String 对象是否小等于指定的值</p>
<p>@DecimalMax(value&#x3D;值) 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度</p>
<p>@DecimalMin(value&#x3D;值) 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度</p>
<p>@Digits 验证 Number 和 String 的构成是否合法</p>
<p>@Digits(integer&#x3D;,fraction&#x3D;)验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。</p>
<p>@Range(min&#x3D;, max&#x3D;) 检查数字是否介于min和max之间.</p>
<p>@Range(min&#x3D;10000,max&#x3D;50000,message&#x3D;”range.bean.wage”)</p>
<p>private BigDecimal wage;</p>
<p>@Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)</p>
<p>@CreditCardNumber信用卡验证</p>
<p>@Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。</p>
<p>@ScriptAssert(lang&#x3D;,script&#x3D;, alias&#x3D;)</p>
<p>@URL(protocol&#x3D;,host&#x3D;,port&#x3D;,regexp&#x3D;, flags&#x3D;)</p>
<p>@Validated</p>
<p>@Valid是对javabean的校验，如果想对使用@RequestParam方式接收参数方式校验使用@Validated</p>
<p>使用@Validated的步骤：</p>
<p>第一步：定义全局异常，让该全局异常处理器能处理所以验证失败的情况，并返回给前台失败提示数据。如下，该类不用在任何xml里配置。 import javax.validation.ValidationException;</p>
<p>import org.springframework.context.annotation.Bean; import org.springframework.http.HttpStatus; import org.springframework.stereotype.Component; import org.springframework.validation.beanvalidation.MethodValidationPostProcessor; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.ResponseStatus;</p>
<p>@ControllerAdvice @Component public class GlobalExceptionHandler {  @Bean  public MethodValidationPostProcessor methodValidationPostProcessor() {  return new MethodValidationPostProcessor();  }</p>
<p>@ExceptionHandler@ResponseBody@ResponseStatus(HttpStatus.BAD_REQUEST)public String handle(ValidationException exception) {    System.out.println(“bad request, “ + exception.getMessage());    return “bad request, “ + exception.getMessage();}<br>} 第二步。在XXController.java头上添加@Validated，然后在@RequestParam后台使用上面介绍的验证注解，比如@NotBlank,@Rank.</p>
<p>如下：</p>
<p>@Controller @RequestMapping(“&#x2F;test”) @Validated public class TestController extends BaseController {<br>@RequestMapping(value &#x3D; “testValidated”, method &#x3D; RequestMethod.GET)@ResponseBody@ResponseStatus(HttpStatus.BAD_REQUEST)public Object testValidated(@RequestParam(value &#x3D; “pk”, required &#x3D; true) @Size(min &#x3D; 1, max &#x3D; 3) String pk,        @RequestParam(value &#x3D; “age”, required &#x3D; false) @Range(min &#x3D; 1, max &#x3D; 3) String age) {    try {        return “pk:” + pk + “,age&#x3D;” + age;    } catch (Throwable t) {                return buildFailure(“消息列表查询失败”);    }}<br>}</p>
<p>当入非法参数是，会被全局处理器拦截到，(Spring切面编程方式)，如果参数非法即刻给前台返回错误数据。</p>
<p>测试：<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/TestValidate/test/testValidated?pk=2&amp;age=12">http://127.0.0.1:8080/TestValidate/test/testValidated?pk=2&amp;age=12</a></p>
<p>返回：</p>
<p>注意</p>
<p>@Valid是使用hibernateValidation.jar做校验</p>
<p>@Validated是只用springValidator校验机制使用</p>
<p>gitHub下载地址</p>
<p>@Validated与@RequestBody结合使用时，在接口方法里要增加@Valid。例如：</p>
<p>public Object edit(@Valid @RequestBody AddrRo addrRo) {…..}</p>
<p>14.@RequestBody<br>@RequestBody(required&#x3D;true)</p>
<p>:有个默认属性required,默认是true,当body里没内容时抛异常。</p>
<p>application&#x2F;x-www-form-urlencoded：窗体数据被编码为名称&#x2F;值对。这是标准的编码格式。这是默认的方式 multipart&#x2F;form-data：窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。二进制数据传输方式，主要用于上传文件</p>
<p>注意：必需使用POST方式提交参数，需要使用ajax方式请求，用Fiddler去模拟post请求不能。</p>
<p>引用jar包：</p>
<p>Spring相关jar包。</p>
<p>以及</p>
<p> com.fasterxml.jackson.core  jackson-annotations  2.5.3    com.fasterxml.jackson.core  jackson-core  2.5.3    com.fasterxml.jackson.core  jackson-databind  2.5.3 </p>
<p>dispatchServlet-mvc.xml配置 第一种，直接配置MappingJackson2HttpMessageCoverter：</p>
<p>​    </p>
<p>第二种：mvc:annotation-driven&#x2F; 就不用配置上面bean,默认会配好。</p>
<p>Ajax请求：</p>
<p>function testRequestBody() {  var o &#x3D; {“status”:9};  jQuery.ajax({  type: “POST”,  url: “<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/TestValidate/test/testValid&quot;">http://127.0.0.1:8080/TestValidate/test/testValid&quot;</a>,  xhrFields:{  withCredentials:true  },  data: JSON.stringify(o),  contentType: “application&#x2F;json”,  dataType: “json”,  async: false,  success:function (data) {  console.log(data);  },</p>
<pre><code>    error: function(res) &#123;         console.log(res);        &#125;    &#125;);
</code></pre>
<p>}</p>
<p>后台XXXcontroller.java:</p>
<p>@RequestMapping(value&#x3D;”&#x2F; testValid “,method&#x3D;RequestMethod.POST) @ResponseBody public Object setOrderInfo(@RequestBody InfoVO infoVO,HttpServletRequest request, HttpServletResponse response){  InfoVO cVo &#x3D; getInfoVo(infoVO);  return “success”;  } 开发时，不是报415，就是400错误，头都大了。还是细节没做到位，注意下面几个要点：</p>
<p>Content-Type必需是application&#x2F;json</p>
<p>需要jackson-databind.jar</p>
<p>mvc:annotation-driven&#x2F;要配置或直接配置bean</p>
<p>XXXController.jar在post方式接收数据</p>
<p>最最重要的，使用ajax以post方式请求。不能用Fiddler模拟,不然会出错。</p>
<p>15.@CrossOrigin<br>是Cross-Origin ResourceSharing(跨域资源共享)的简写</p>
<p>作用是解决跨域访问的问题，在Spring4.2以上的版本可直接使用。在类上或方法上添加该注解</p>
<p>例如：</p>
<p>@CrossOrigin public class TestController extends BaseController {<br>XXXX<br>}</p>
<p>如果失效则可能方法没解决是GET还是POST方式，指定即可解决问题。</p>
<p>16.@RequestParam<br>作用是提取和解析请求中的参数。@RequestParam支持类型转换，类型转换目前支持所有的基本Java类型</p>
<p>@RequestParam([value&#x3D;”number”], [required&#x3D;false]) String number</p>
<p>将请求中参数为number映射到方法的number上。required&#x3D;false表示该参数不是必需的，请求上可带可不带。</p>
<p>17.@PathVariable，@RequestHeader，@CookieValue，@RequestParam, @RequestBody，@SessionAttributes, @ModelAttribute<br>@PathVariable：处理requet uri部分,当使用@RequestMapping URI template 样式映射时， 即someUrl&#x2F;{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上</p>
<p>例如：</p>
<p>@Controller @RequestMapping(“&#x2F;owners&#x2F;{a}”) public class RelativePathUriTemplateController { @RequestMapping(“&#x2F;pets&#x2F;{b}”) public void findPet(@PathVariable(“a”) String a,@PathVariable String b, Model model) {  &#x2F;&#x2F; implementation omitted } }</p>
<p>@RequestHeader，@CookieValue: 处理request header部分的注解</p>
<p>将头部信息绑定到方法参数上：</p>
<p>@RequestMapping(“&#x2F;test”) public void displayHeaderInfo(@RequestHeader(“Accept-Encoding”) String encoding,  @RequestHeader(“Keep-Alive”)long keepAlive) {<br>&#x2F;&#x2F;…</p>
<p>}</p>
<p>&#x2F;&#x2F;将cookie里JSESSIONID绑定到方法参数上</p>
<p>@RequestMapping(“&#x2F;test”) public void displayHeaderInfo(@CookieValue(“JSESSIONID”) String cookie) {<br>&#x2F;&#x2F;…</p>
<p>}</p>
<p>18.@Scope<br>配置bean的作用域。</p>
<p>@Controller</p>
<p>@RequestMapping(“&#x2F;test”)</p>
<p>@Scope(“prototype”)</p>
<p>public class TestController {<br>}</p>
<p>默认是单例模式，即@Scope(“singleton”),</p>
<p>singleton：单例，即容器里只有一个实例对象。</p>
<p>prototype：多对象，每一次请求都会产生一个新的bean实例，Spring不无法对一个prototype bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，由程序员负责销毁该对象，不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用</p>
<p>request：对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效</p>
<p>web.xml增加如下配置： org.springframework.web.context.request.RequestContextListener session：该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效。也要在web.xml配置如下代码： org.springframework.web.context.request.RequestContextListener</p>
<p>global session：作用不大，可不用管他。</p>
<p>19.@ResponseStatus<br>@ResponseStatus用于修饰一个类或者一个方法，修饰一个类的时候，一般修饰的是一个异常类,当处理器的方法被调用时，@ResponseStatus指定的code和reason会被返回给前端。value属性是http状态码，比如404，500等。reason是错误信息</p>
<p>当修改类或方法时，只要该类得到调用，那么value和reason都会被添加到response里</p>
<p>例如：</p>
<p>@ResponseStatus(value&#x3D;HttpStatus.FORBIDDEN, reason&#x3D;”出现了错误”) public class UserException extends RuntimeException{<br>XXXXX<br>}</p>
<p>当某处抛出UserException时，则会把value和reason返回给前端。</p>
<p>@RequestMapping(“&#x2F;testResponseStatus”)  public String testResponseStatus(int i){  if(i&#x3D;&#x3D;0)  throw new UserNotMatchException();  return “hello”; }</p>
<p>修改方法：</p>
<p>@ControllerAdvice @Component public class GlobalExceptionHandler {  @Bean  public MethodValidationPostProcessor methodValidationPostProcessor() {  return new MethodValidationPostProcessor();  }</p>
<p>@ExceptionHandler@ResponseBody@ResponseStatus(value&#x3D;HttpStatus.BAD_REQUEST,reason&#x3D;”哈哈”)public String handle(ValidationException exception) {System.out.println(“bad request, “ + exception.getMessage());return “bad request, “ + exception.getMessage();}<br>}</p>
<p>结果如下：</p>
<p>正如上面所说，该方法得到调用，不论是否抛异常，都会把value和reason添加到response里。</p>
<p>总结：@ResponseStatus是为了在方法或类得到调用时将指定的code和reason添加到response里返前端，就像服务器常给我们报的404错误一样，我们可以自己指定高逼格错误提示。</p>
<p>20.@RestController<br>@RestController &#x3D; @Controller + @ResponseBody。</p>
<p>是2个注解的合并效果，即指定了该controller是组件，又指定方法返回的是String或json类型数据，不会解决成jsp页面，注定不够灵活，如果一个Controller即有SpringMVC返回视图的方法，又有返回json数据的方法即使用@RestController太死板。</p>
<p>灵活的作法是：定义controller的时候，直接使用@Controller，如果需要返回json可以直接在方法中添加@ResponseBody</p>
<p>21.@ControllerAdvice<br>官方解释是：It is typically used todefine@ExceptionHandler,</p>
<p>@InitBinder, and@ModelAttribute methods that apply to all@RequestMapping methods</p>
<p>意思是：即把@ControllerAdvice注解内部使用@ExceptionHandler、@InitBinder、@ModelAttribute注解的方法应用到所有的 @RequestMapping注解的方法。非常简单，不过只有当使用@ExceptionHandler最有用，另外两个用处不大。</p>
<p>@ControllerAdvice public class GlobalExceptionHandler {  @ExceptionHandler(SQLException.class)  @ResponseStatus(value&#x3D;HttpStatus.INTERNAL_SERVER_ERROR,reason&#x3D;”sql查询错误”)  @ResponseBody  public ExceptionResponse handleSQLException(HttpServletRequest request, Exception ex) {  String message &#x3D; ex.getMessage();  return ExceptionResponse.create(HttpStatus.INTERNAL_SERVER_ERROR.value(), message);  } }</p>
<p>即表示让Spring捕获到所有抛出的SQLException异常，并交由这个被注解的handleSQLException方法处理，同时使用@ResponseStatus指定了code和reason写到response上，返回给前端。</p>
<p>22.元注解包括 @Retention @Target @Document @Inherited四种<br>元注解是指注解的注解，比如我们看到的ControllerAdvice注解定义如下。</p>
<p>@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface ControllerAdvice {  XXX }</p>
<p>@Retention: 定义注解的保留策略：</p>
<p>@Retention(RetentionPolicy.SOURCE) &#x2F;&#x2F;注解仅存在于源码中，在class字节码文件中不包含</p>
<p>@Retention(RetentionPolicy.CLASS) &#x2F;&#x2F;默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，</p>
<p>@Retention(RetentionPolicy.RUNTIME) &#x2F;&#x2F;注解会在class字节码文件中存在，在运行时可以通过反射获取到</p>
<p>@Target：定义注解的作用目标:</p>
<p>@Target(ElementType.TYPE) &#x2F;&#x2F;接口、类、枚举、注解</p>
<p>@Target(ElementType.FIELD) &#x2F;&#x2F;字段、枚举的常量</p>
<p>@Target(ElementType.METHOD) &#x2F;&#x2F;方法</p>
<p>@Target(ElementType.PARAMETER) &#x2F;&#x2F;方法参数</p>
<p>@Target(ElementType.CONSTRUCTOR) &#x2F;&#x2F;构造函数</p>
<p>@Target(ElementType.LOCAL_VARIABLE)&#x2F;&#x2F;局部变量</p>
<p>@Target(ElementType.ANNOTATION_TYPE)&#x2F;&#x2F;注解</p>
<p>@Target(ElementType.PACKAGE) &#x2F;&#x2F;&#x2F;包</p>
<p>由以上的源码可以知道，他的elementType 可以有多个，一个注解可以为类的，方法的，字段的等等</p>
<p>@Document：说明该注解将被包含在javadoc中</p>
<p>@Inherited：说明子类可以继承父类中的该注解</p>
<p>比如@Valid注解定义是</p>
<p>表示该注解只能用在方法，属性，构造函数及方法参数上。该注意会被编译到class里可通过反射得到。</p>
<p>23.@RequestMapping<br>处理映射请求的注解。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。有6个属性。</p>
<p>1、 value， method: value：指定请求的实际地址，指定的地址可以是URI Template 模式； method：指定请求的method类型， GET、POST、PUT、DELETE等； 比如： @RequestMapping(value &#x3D; “&#x2F;testValid”, method &#x3D; RequestMethod.POST) @ResponseBody public Object testValid(@RequestBody @Valid Test test,BindingResult result, HttpServletRequest request, HttpServletResponse response) {  XXX }</p>
<p>value的uri值为以下三类： A) 可以指定为普通的具体值；如@RequestMapping(value &#x3D;”&#x2F;testValid”) B) 可以指定为含有某变量的一类值;如@RequestMapping(value&#x3D;”&#x2F;{day}”) C) 可以指定为含正则表达式的一类值;如@RequestMapping(value&#x3D;”&#x2F;{textualPart:[a-z-]+}.{numericPart:[d]+}”) 可以匹配..&#x2F;chenyuan122912请求。</p>
<p>2、 consumes，produces： consumes： 指定处理请求的提交内容类型(Content-Type)，例如@RequestMapping(value &#x3D; “&#x2F;test”, consumes&#x3D;”application&#x2F;json”)处理application&#x2F;json内容类型</p>
<p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p>
<p>3 params、headers： params： 指定request中必须包含某些参数值是，才让该方法处理。</p>
<p>例如：</p>
<p>@RequestMapping(value &#x3D; “&#x2F;test”, method &#x3D; RequestMethod.GET, params&#x3D;”name&#x3D;chenyuan”) public void findOrd(String name) {  &#x2F;&#x2F; implementation omitted }</p>
<p>仅处理请求中包含了名为“name”，值为“chenyuan”的请求.</p>
<p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<p>@RequestMapping(value &#x3D; “&#x2F;test”, method &#x3D; RequestMethod.GET, headers&#x3D;”Referer&#x3D;<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">www.baidu.com&quot;</a>) public void findOrd(String name) {  &#x2F;&#x2F; implementation omitted }</p>
<p>仅处理request的header中包含了指定“Refer”请求头和对应值为“<a target="_blank" rel="noopener" href="http://www.baidu.com”的请求/">www.baidu.com”的请求</a></p>
<ol start="24">
<li><p>@GetMapping和@PostMapping</p>
<p>@GetMapping(value &#x3D; “page”)等价于@RequestMapping(value &#x3D; “page”, method &#x3D; RequestMethod.GET)</p>
</li>
</ol>
<p>@PostMapping(value &#x3D; “page”)等价于@RequestMapping(value &#x3D; “page”, method &#x3D; RequestMethod.POST)</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-13T10:55:12.000Z" title="2021/5/13 下午6:55:12">2021-05-13</time>发表</span><span class="level-item"><time dateTime="2021-05-13T10:55:12.000Z" title="2021/5/13 下午6:55:12">2021-05-13</time>更新</span><span class="level-item">3 分钟读完 (大约413个字)</span></div></div><div class="content"><h1 id="2-4-1-ApplicationContext"><a href="#2-4-1-ApplicationContext" class="headerlink" title="2.4.1 ApplicationContext"></a>2.4.1 ApplicationContext</h1><h2 id="SpringBoot中获取ApplicationContext的三种方式"><a href="#SpringBoot中获取ApplicationContext的三种方式" class="headerlink" title="SpringBoot中获取ApplicationContext的三种方式"></a>SpringBoot中获取ApplicationContext的三种方式</h2><blockquote>
<p>ApplicationContext是什么？</p>
<p>简单来说就是Spring中的容器，可以用来获取容器中的各种bean组件，注册监听事件，加载资源文件等功能。</p>
</blockquote>
<h2 id="一、Application-Context获取的几种方式"><a href="#一、Application-Context获取的几种方式" class="headerlink" title="一、Application Context获取的几种方式"></a>一、Application Context获取的几种方式</h2><h3 id="1-直接使用Autowired注入"><a href="#1-直接使用Autowired注入" class="headerlink" title="1 直接使用Autowired注入"></a>1 直接使用Autowired注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(applicationContext.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-利用-spring4-3-的新特性"><a href="#2-利用-spring4-3-的新特性" class="headerlink" title="2 利用 spring4.3 的新特性"></a>2 利用 spring4.3 的新特性</h3><p>使用spring4.3新特性但是存在一定的局限性，必须满足以下两点：<br>1 构造函数只能有一个，如果有多个，就必须有一个无参数的构造函数，此时，spring会调用无参的构造函数<br>2 构造函数的参数，必须在spring容器中存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book2</span><span class="params">(ApplicationContext applicationContext)</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getClass());</span><br><span class="line">        <span class="built_in">this</span>.applicationContext=applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现spring提供的接口-ApplicationContextAware"><a href="#3-实现spring提供的接口-ApplicationContextAware" class="headerlink" title="3 实现spring提供的接口 ApplicationContextAware"></a>3 实现spring提供的接口 ApplicationContextAware</h3><p>spring 在bean 初始化后会判断是不是<code>ApplicationContextAware</code>的子类，调用<code>setApplicationContext()</code>方法， 会将容器中<code>ApplicationContext</code>传入进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book3</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、ApplicationContext的常见实现是什么？"><a href="#二、ApplicationContext的常见实现是什么？" class="headerlink" title="二、ApplicationContext的常见实现是什么？"></a>二、ApplicationContext的常见实现是什么？</h2><p>1.FileSystemXmlApplicationContext来容器从XML文件加载bean的定义。必须将XML bean配置文件的完整路径提供给构造函数。</p>
<p>2.ClassPathXmlApplicationContext的容器还加载从XML文件java bean的定义。在这里，您需要正确设置CLASSPATH，因为此容器将在CLASSPATH中查找bean配置XML文件。</p>
<p>3.WebXmlApplicationContext：容器从Web应用程序中加载的所有bean类定义的XML文件。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-12T02:38:21.000Z" title="2021/5/12 上午10:38:21">2021-05-12</time>发表</span><span class="level-item"><time dateTime="2021-05-12T02:38:21.000Z" title="2021/5/12 上午10:38:21">2021-05-12</time>更新</span><span class="level-item">2 分钟读完 (大约354个字)</span></div></div><div class="content"><h2 id="Mac环境目录"><a href="#Mac环境目录" class="headerlink" title="Mac环境目录"></a>Mac环境目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 通过phpinfo()打印页面</span><br><span class="line"></span><br><span class="line">1. php.ini文件目录</span><br><span class="line">Loaded Configuration File</span><br><span class="line">/usr/local/etc/php/7.1/php.ini</span><br><span class="line"></span><br><span class="line">2.扩展存放目录</span><br><span class="line">extension_dir</span><br><span class="line">/usr/local/lib/php/pecl/20160303</span><br></pre></td></tr></table></figure>

<h2 id="安装apcu"><a href="#安装apcu" class="headerlink" title="安装apcu"></a>安装apcu</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1.下载源码  </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/krakjoe/apcu</span><br><span class="line">// 2.编译安装  </span><br><span class="line"><span class="built_in">cd</span> apcu</span><br><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">// 3. 修改php.ini文件</span><br><span class="line">extension=apcu</span><br><span class="line"></span><br><span class="line">php --ini</span><br><span class="line">// apcu.so目录</span><br><span class="line">/opt/homebrew/Cellar/php@7.4/7.4.16/pecl/20190902</span><br></pre></td></tr></table></figure>



<h2 id="MacOs"><a href="#MacOs" class="headerlink" title="MacOs"></a>MacOs</h2><blockquote>
<p>OS11.1 Install Nginx</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br><span class="line"><span class="comment"># Docroot is:</span></span><br><span class="line">/opt/homebrew/var/www</span><br><span class="line"><span class="comment"># Config files</span></span><br><span class="line">/opt/homebrew/etc/nginx/servers/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>OS11.1 配置php-fpm</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ php-fpm</span><br><span class="line">ERROR: failed to load configuration file <span class="string">&#x27;/private/etc/php-fpm.conf&#x27;</span></span><br><span class="line">ERROR: FPM initialization failed</span><br><span class="line">$ <span class="built_in">cd</span> /private/etc</span><br><span class="line">$ sudo <span class="built_in">cp</span> php-fpm.conf.default php-fpm.conf</span><br><span class="line">$ php-fpm</span><br><span class="line">WARNING: Nothing matches the include pattern <span class="string">&#x27;/private/etc/php-fpm.d/*.conf&#x27;</span> from /private/etc/php-fpm.conf at line 143</span><br><span class="line">ERROR: failed to open error_log (/usr/var/log/php-fpm.log): No such file or directory (2)</span><br><span class="line">ERROR: failed to post process the configuration</span><br><span class="line">ERROR: FPM initialization failed</span><br><span class="line"><span class="comment"># cd /usr/var/log 发现根本没有这个目录，甚至连 var 目录都没有，加上为了避免权限问题，干脆配置到 /usr/local/var/log 目录。</span></span><br><span class="line"><span class="comment"># 修改 php-fpm.conf error_log 配置为 /usr/local/var/log/php-fpm.log，并把 user 和 group 改为和当前用户一样。</span></span><br><span class="line">$ php-fpm</span><br><span class="line">WARNING: Nothing matches the include pattern <span class="string">&#x27;/private/etc/php-fpm.d/*.conf&#x27;</span> from /private/etc/php-fpm.conf at line 143.</span><br><span class="line">ERROR: No pool defined. at least one pool section must be specified <span class="keyword">in</span> config file</span><br><span class="line">$ <span class="built_in">cd</span> /private/etc/php-fpm.d</span><br><span class="line">$ <span class="built_in">cp</span> www.conf.default www.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>异常</p>
<p>1.fatal error: ‘pcre2.h’ file not found #include “pcre2.h”</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cp</span> /opt/homebrew/Cellar/pcre2/10.36/include/pcre2.h /opt/homebrew/Cellar/php\@7.4/7.4.16/include/php/ext/pcre/pcre2.h</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-28T01:54:13.000Z" title="2021/4/28 上午9:54:13">2021-04-28</time>发表</span><span class="level-item"><time dateTime="2021-04-28T01:54:13.000Z" title="2021/4/28 上午9:54:13">2021-04-28</time>更新</span><span class="level-item">41 分钟读完 (大约6201个字)</span></div></div><div class="content"><p><img src="/../../images/640.png" alt="图片"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>什么是分布式消息中间件？</li>
<li>消息中间件的作用是什么？</li>
<li>消息中间件的使用场景是什么？</li>
<li>消息中间件选型？</li>
</ul>
<p>分布式消息是一种通信机制，和 RPC、HTTP、RMI 等不一样，消息中间件采用分布式中间代理的方式进行通信。如图所示，采用了消息中间件之后，上游业务系统发送消息，先存储在消息中间件，然后由消息中间件将消息分发到对应的业务模块应用（分布式生产者 - 消费者模式）。这种异步的方式，减少了服务之间的耦合程度。</p>
<p><img src="/../../images/640" alt="图片"></p>
<p><strong>定义消息中间件：</strong></p>
<ul>
<li>利用高效可靠的消息传递机制进行平台无关的数据交流</li>
<li>基于数据通信，来进行分布式系统的集成</li>
<li>通过提供消息传递和消息排队模型，可以在分布式环境下扩展进程间的通信</li>
</ul>
<p>在系统架构中引用额外的组件，必然提高系统的架构复杂度和运维的难度，那么<strong>在系统中使用分布式消息中间件有什么优势呢？消息中间件在系统中起的作用又是什么呢？</strong></p>
<ul>
<li>解耦</li>
<li>冗余（存储）</li>
<li>扩展性</li>
<li>削峰</li>
<li>可恢复性</li>
<li>顺序保证</li>
<li>缓冲</li>
<li>异步通信</li>
</ul>
<p>面试时，面试官经常会关心面试者对开源组件的选型能力，这既可以考验面试者知识的广度，也可以考验面试者对某类系统的知识的认识深度，而且也可以看出面试者对系统整体把握和系统架构设计的能力。开源分布式消息系统有很多，不同的消息系统的特性也不一样，选择怎样的消息系统，不仅需要对各消息系统有一定的了解，也需要对自身系统需求有清晰的认识。</p>
<p><strong>下面是常见的几种分布式消息系统的对比：</strong><br><img src="/../../images/640-20210428095405910" alt="图片">选择</p>
<h3 id="答案关键字"><a href="#答案关键字" class="headerlink" title="答案关键字"></a>答案关键字</h3><ul>
<li>什么是分布式消息中间件？通信，队列，分布式，生产消费者模式。</li>
<li>消息中间件的作用是什么？解耦、峰值处理、异步通信、缓冲。</li>
<li>消息中间件的使用场景是什么？异步通信，消息存储处理。</li>
<li>消息中间件选型？语言，协议、HA、数据可靠性、性能、事务、生态、简易、推拉模式。</li>
</ul>
<h2 id="Kafka-基本概念和架构"><a href="#Kafka-基本概念和架构" class="headerlink" title="Kafka 基本概念和架构"></a>Kafka 基本概念和架构</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li>简单讲下 Kafka 的架构？</li>
<li>Kafka 是推模式还是拉模式，推拉的区别是什么？</li>
<li>Kafka 如何广播消息？</li>
<li>Kafka 的消息是否是有序的？</li>
<li>Kafka 是否支持读写分离？</li>
<li>Kafka 如何保证数据高可用？</li>
<li>Kafka 中 zookeeper 的作用？</li>
<li>是否支持事务？</li>
<li>分区数是否可以减少？</li>
</ul>
<p><strong>Kafka 架构中的一般概念：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/FbXJ7UCc6O1oicl7z78fR9ibRGPNMBfV0ezicXtDDiaMbIKIjibSf05dOIKmBzicuuEhrRkbuESn0DNrfEFOCsTtYTTw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">架构</p>
<ul>
<li>Producer：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其发送到 Kafka。</li>
<li>Consumer：消费者，也就是接受消息的一方。消费者连接到 Kafka 上并接收消息，进而进行相应的业务逻辑处理。</li>
<li>Consumer Group：一个消费者组可以包含一个或多个消费者。使用多分区 + 多消费者方式可以极大提高数据下游的处理速度，同一消费组中的消费者不会重复消费消息，同样的，不同消费组中的消费者消息消息时互不影响。Kafka 就是通过消费组的方式来实现消息 P2P 模式和广播模式。</li>
<li>Broker：服务代理节点。Broker 是 Kafka 的服务节点，即 Kafka 的服务器。</li>
<li>Topic：Kafka 中的消息以 Topic 为单位进行划分，生产者将消息发送到特定的 Topic，而消费者负责订阅 Topic 的消息并进行消费。</li>
<li>Partition：Topic 是一个逻辑的概念，它可以细分为多个分区，每个分区只属于单个主题。同一个主题下不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。</li>
<li>Offset：offset 是消息在分区中的唯一标识，Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，Kafka 保证的是分区有序性而不是主题有序性。</li>
<li>Replication：副本，是 Kafka 保证数据高可用的方式，Kafka 同一 Partition 的数据可以在多 Broker 上存在多个副本，通常只有主副本对外提供读写服务，当主副本所在 broker 崩溃或发生网络一场，Kafka 会在 Controller 的管理下会重新选择新的 Leader 副本对外提供读写服务。</li>
<li>Record：实际写入 Kafka 中并可以被读取的消息记录。每个 record 包含了 key、value 和 timestamp。</li>
</ul>
<p><strong>Kafka Topic Partitions Layout</strong></p>
<p><img src="/../../images/640-20210428095405405" alt="图片">主题</p>
<p>Kafka 将 Topic 进行分区，分区可以并发读写。</p>
<p><strong>Kafka Consumer Offset</strong></p>
<p><img src="/../../images/640-20210428095405632" alt="图片">consumer offset</p>
<h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p><img src="/../../images/640-20210428095405909.png" alt="图片">zookeeper</p>
<ul>
<li>Broker 注册：Broker 是分布式部署并且之间相互独立，Zookeeper 用来管理注册到集群的所有 Broker 节点。</li>
<li>Topic 注册：在 Kafka 中，同一个 Topic 的消息会被分成多个分区并将其分布在多个 Broker 上，这些分区信息及与 Broker 的对应关系也都是由 Zookeeper 在维护</li>
<li>生产者负载均衡：由于同一个 Topic 消息会被分区并将其分布在多个 Broker 上，因此，生产者需要将消息合理地发送到这些分布式的 Broker 上。</li>
<li>消费者负载均衡：与生产者类似，Kafka 中的消费者同样需要进行负载均衡来实现多个消费者合理地从对应的 Broker 服务器上接收消息，每个消费者分组包含若干消费者，每条消息都只会发送给分组中的一个消费者，不同的消费者分组消费自己特定的 Topic 下面的消息，互不干扰。</li>
</ul>
<h3 id="答案关键字-1"><a href="#答案关键字-1" class="headerlink" title="答案关键字"></a>答案关键字</h3><ul>
<li><p>简单讲下 Kafka 的架构？</p>
<blockquote>
<p>Producer、Consumer、Consumer Group、Topic、Partition</p>
</blockquote>
</li>
<li><p>Kafka 是推模式还是拉模式，推拉的区别是什么？</p>
<blockquote>
<p>Kafka Producer 向 Broker 发送消息使用 Push 模式，Consumer 消费采用的 Pull 模式。拉取模式，让 consumer 自己管理 offset，可以提供读取性能</p>
</blockquote>
</li>
<li><p>Kafka 如何广播消息？</p>
<blockquote>
<p>Consumer group</p>
</blockquote>
</li>
<li><p>Kafka 的消息是否是有序的？</p>
<blockquote>
<p>Topic 级别无序，Partition 有序</p>
</blockquote>
</li>
<li><p>Kafka 是否支持读写分离？</p>
<blockquote>
<p>不支持，只有 Leader 对外提供读写服务</p>
</blockquote>
</li>
<li><p>Kafka 如何保证数据高可用？</p>
<blockquote>
<p>副本，ack，HW</p>
</blockquote>
</li>
<li><p>Kafka 中 zookeeper 的作用？</p>
<blockquote>
<p>集群管理，元数据管理</p>
</blockquote>
</li>
<li><p>是否支持事务？</p>
<blockquote>
<p>0.11 后支持事务，可以实现”exactly once“</p>
</blockquote>
</li>
<li><p>分区数是否可以减少？</p>
<blockquote>
<p>不可以，会丢失数据</p>
</blockquote>
</li>
</ul>
<h2 id="Kafka-使用"><a href="#Kafka-使用" class="headerlink" title="Kafka 使用"></a>Kafka 使用</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ul>
<li>Kafka 有哪些命令行工具？你用过哪些？</li>
<li>Kafka Producer 的执行过程？</li>
<li>Kafka Producer 有哪些常见配置？</li>
<li>如何让 Kafka 的消息有序？</li>
<li>Producer 如何保证数据发送不丢失？</li>
<li>如何提升 Producer 的性能？</li>
<li>如果同一 group 下 consumer 的数量大于 part 的数量，kafka 如何处理？</li>
<li>Kafka Consumer 是否是线程安全的？</li>
<li>讲一下你使用 Kafka Consumer 消费消息时的线程模型，为何如此设计？</li>
<li>Kafka Consumer 的常见配置？</li>
<li>Consumer 什么时候会被踢出集群？</li>
<li>当有 Consumer 加入或退出时，Kafka 会作何反应？</li>
<li>什么是 Rebalance，何时会发生 Rebalance？</li>
</ul>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>Kafka 的命令行工具在 Kafka 包的<code>/bin</code>目录下，主要包括服务和集群管理脚本，配置脚本，信息查看脚本，Topic 脚本，客户端脚本等。</p>
<ul>
<li>kafka-configs.sh：配置管理脚本</li>
<li>kafka-console-consumer.sh：kafka 消费者控制台</li>
<li>kafka-console-producer.sh：kafka 生产者控制台</li>
<li>kafka-consumer-groups.sh：kafka 消费者组相关信息</li>
<li>kafka-delete-records.sh：删除低水位的日志文件</li>
<li>kafka-log-dirs.sh：kafka 消息日志目录信息</li>
<li>kafka-mirror-maker.sh：不同数据中心 kafka 集群复制工具</li>
<li>kafka-preferred-replica-election.sh：触发 preferred replica 选举</li>
<li>kafka-producer-perf-test.sh：kafka 生产者性能测试脚本</li>
<li>kafka-reassign-partitions.sh：分区重分配脚本</li>
<li>kafka-replica-verification.sh：复制进度验证脚本</li>
<li>kafka-server-start.sh：启动 kafka 服务</li>
<li>kafka-server-stop.sh：停止 kafka 服务</li>
<li>kafka-topics.sh：topic 管理脚本</li>
<li>kafka-verifiable-consumer.sh：可检验的 kafka 消费者</li>
<li>kafka-verifiable-producer.sh：可检验的 kafka 生产者</li>
<li>zookeeper-server-start.sh：启动 zk 服务</li>
<li>zookeeper-server-stop.sh：停止 zk 服务</li>
<li>zookeeper-shell.sh：zk 客户端</li>
</ul>
<p>我们通常可以使用<code>kafka-console-consumer.sh</code>和<code>kafka-console-producer.sh</code>脚本来测试 Kafka 生产和消费，<code>kafka-consumer-groups.sh</code>可以查看和管理集群中的 Topic，<code>kafka-topics.sh</code>通常用于查看 Kafka 的消费组情况。</p>
<h3 id="Kafka-Producer"><a href="#Kafka-Producer" class="headerlink" title="Kafka Producer"></a>Kafka Producer</h3><p>Kafka producer 的正常生产逻辑包含以下几个步骤：</p>
<ol>
<li>配置生产者客户端参数常见生产者实例。</li>
<li>构建待发送的消息。</li>
<li>发送消息。</li>
<li>关闭生产者实例。</li>
</ol>
<p>Producer 发送消息的过程如下图所示，需要经过<code>拦截器</code>，<code>序列化器</code>和<code>分区器</code>，最终由<code>累加器</code>批量发送至 Broker。</p>
<p><img src="/../../images/640-20210428095405435.png" alt="图片">producer</p>
<p>Kafka Producer 需要以下必要参数：</p>
<ul>
<li>bootstrap.server：指定 Kafka 的 Broker 的地址</li>
<li>key.serializer：key 序列化器</li>
<li>value.serializer：value 序列化器</li>
</ul>
<p>常见参数：</p>
<ul>
<li><p>batch.num.messages</p>
<blockquote>
<p>默认值：200，每次批量消息的数量，只对 asyc 起作用。</p>
</blockquote>
</li>
<li><p>request.required.acks</p>
<blockquote>
<p>默认值：0，0 表示 producer 毋须等待 leader 的确认，1 代表需要 leader 确认写入它的本地 log 并立即确认，-1 代表所有的备份都完成后确认。只对 async 模式起作用，这个参数的调整是数据不丢失和发送效率的 tradeoff，如果对数据丢失不敏感而在乎效率的场景可以考虑设置为 0，这样可以大大提高 producer 发送数据的效率。</p>
</blockquote>
</li>
<li><p>request.timeout.ms</p>
<blockquote>
<p>默认值：10000，确认超时时间。</p>
</blockquote>
</li>
<li><p>partitioner.class</p>
<blockquote>
<p>默认值：kafka.producer.DefaultPartitioner，必须实现 kafka.producer.Partitioner，根据 Key 提供一个分区策略。<em>有时候我们需要相同类型的消息必须顺序处理，这样我们就必须自定义分配策略，从而将相同类型的数据分配到同一个分区中。</em></p>
</blockquote>
</li>
<li><p>producer.type</p>
<blockquote>
<p>默认值：sync，指定消息发送是同步还是异步。异步 asyc 成批发送用 kafka.producer.AyncProducer， 同步 sync 用 kafka.producer.SyncProducer。同步和异步发送也会影响消息生产的效率。</p>
</blockquote>
</li>
<li><p>compression.topic</p>
<blockquote>
<p>默认值：none，消息压缩，默认不压缩。其余压缩方式还有，”gzip”、”snappy”和”lz4”。对消息的压缩可以极大地减少网络传输量、降低网络 IO，从而提高整体性能。</p>
</blockquote>
</li>
<li><p>compressed.topics</p>
<blockquote>
<p>默认值：null，在设置了压缩的情况下，可以指定特定的 topic 压缩，未指定则全部压缩。</p>
</blockquote>
</li>
<li><p>message.send.max.retries</p>
<blockquote>
<p>默认值：3，消息发送最大尝试次数。</p>
</blockquote>
</li>
<li><p>retry.backoff.ms</p>
<blockquote>
<p>默认值：300，每次尝试增加的额外的间隔时间。</p>
</blockquote>
</li>
<li><p>topic.metadata.refresh.interval.ms</p>
<blockquote>
<p>默认值：600000，定期的获取元数据的时间。当分区丢失，leader 不可用时 producer 也会主动获取元数据，如果为 0，则每次发送完消息就获取元数据，不推荐。如果为负值，则只有在失败的情况下获取元数据。</p>
</blockquote>
</li>
<li><p>queue.buffering.max.ms</p>
<blockquote>
<p>默认值：5000，在 producer queue 的缓存的数据最大时间，仅仅 for asyc。</p>
</blockquote>
</li>
<li><p>queue.buffering.max.message</p>
<blockquote>
<p>默认值：10000，producer 缓存的消息的最大数量，仅仅 for asyc。</p>
</blockquote>
</li>
<li><p>queue.enqueue.timeout.ms</p>
<blockquote>
<p>默认值：-1，0 当 queue 满时丢掉，负值是 queue 满时 block, 正值是 queue 满时 block 相应的时间，仅仅 for asyc。</p>
</blockquote>
</li>
</ul>
<h3 id="Kafka-Consumer"><a href="#Kafka-Consumer" class="headerlink" title="Kafka Consumer"></a>Kafka Consumer</h3><p>Kafka 有消费组的概念，每个消费者只能消费所分配到的分区的消息，每一个分区只能被一个消费组中的一个消费者所消费，所以同一个消费组中消费者的数量如果超过了分区的数量，将会出现有些消费者分配不到消费的分区。消费组与消费者关系如下图所示：</p>
<p><img src="/../../images/640-20210428095405419" alt="图片">consumer group</p>
<p>Kafka Consumer Client 消费消息通常包含以下步骤：</p>
<ol>
<li>配置客户端，创建消费者</li>
<li>订阅主题</li>
<li>拉去消息并消费</li>
<li>提交消费位移</li>
<li>关闭消费者实例</li>
</ol>
<p><img src="/../../images/640-20210428095405428" alt="图片">过程</p>
<p>因为 Kafka 的 Consumer 客户端是线程不安全的，为了保证线程安全，并提升消费性能，可以在 Consumer 端采用类似 Reactor 的线程模型来消费数据。</p>
<p><img src="/../../images/640-20210428095405430" alt="图片">消费模型</p>
<h4 id="Kafka-consumer-参数"><a href="#Kafka-consumer-参数" class="headerlink" title="Kafka consumer 参数"></a>Kafka consumer 参数</h4><ul>
<li>bootstrap.servers：连接 broker 地址，<code>host：port</code> 格式。</li>
<li>group.id：消费者隶属的消费组。</li>
<li>key.deserializer：与生产者的<code>key.serializer</code>对应，key 的反序列化方式。</li>
<li>value.deserializer：与生产者的<code>value.serializer</code>对应，value 的反序列化方式。</li>
<li>session.timeout.ms：coordinator 检测失败的时间。默认 10s 该参数是 Consumer Group 主动检测 （组内成员 comsummer) 崩溃的时间间隔，类似于心跳过期时间。</li>
<li>auto.offset.reset：该属性指定了消费者在读取一个没有偏移量后者偏移量无效（消费者长时间失效当前的偏移量已经过时并且被删除了）的分区的情况下，应该作何处理，默认值是 latest，也就是从最新记录读取数据（消费者启动之后生成的记录），另一个值是 earliest，意思是在偏移量无效的情况下，消费者从起始位置开始读取数据。</li>
<li>enable.auto.commit：否自动提交位移，如果为<code>false</code>，则需要在程序中手动提交位移。对于精确到一次的语义，最好手动提交位移</li>
<li>fetch.max.bytes：单次拉取数据的最大字节数量</li>
<li>max.poll.records：单次 poll 调用返回的最大消息数，如果处理逻辑很轻量，可以适当提高该值。但是<code>max.poll.records</code>条数据需要在在 session.timeout.ms 这个时间内处理完 。默认值为 500</li>
<li>request.timeout.ms：一次请求响应的最长等待时间。如果在超时时间内未得到响应，kafka 要么重发这条消息，要么超过重试次数的情况下直接置为失败。</li>
</ul>
<h4 id="Kafka-Rebalance"><a href="#Kafka-Rebalance" class="headerlink" title="Kafka Rebalance"></a>Kafka Rebalance</h4><p>rebalance 本质上是一种协议，规定了一个 consumer group 下的所有 consumer 如何达成一致来分配订阅 topic 的每个分区。比如某个 group 下有 20 个 consumer，它订阅了一个具有 100 个分区的 topic。正常情况下，Kafka 平均会为每个 consumer 分配 5 个分区。这个分配的过程就叫 rebalance。</p>
<p><strong>什么时候 rebalance？</strong></p>
<p>这也是经常被提及的一个问题。rebalance 的触发条件有三种：</p>
<ul>
<li>组成员发生变更（新 consumer 加入组、已有 consumer 主动离开组或已有 consumer 崩溃了——这两者的区别后面会谈到）</li>
<li>订阅主题数发生变更</li>
<li>订阅主题的分区数发生变更</li>
</ul>
<p><strong>如何进行组内分区分配？</strong></p>
<p>Kafka 默认提供了两种分配策略：Range 和 Round-Robin。当然 Kafka 采用了可插拔式的分配策略，你可以创建自己的分配器以实现不同的分配策略。</p>
<h3 id="答案关键字-2"><a href="#答案关键字-2" class="headerlink" title="答案关键字"></a>答案关键字</h3><ul>
<li>Kafka 有哪些命令行工具？你用过哪些？<code>/bin</code>目录，管理 kafka 集群、管理 topic、生产和消费 kafka</li>
<li>Kafka Producer 的执行过程？拦截器，序列化器，分区器和累加器</li>
<li>Kafka Producer 有哪些常见配置？broker 配置，ack 配置，网络和发送参数，压缩参数，ack 参数</li>
<li>如何让 Kafka 的消息有序？Kafka 在 Topic 级别本身是无序的，只有 partition 上才有序，所以为了保证处理顺序，可以自定义分区器，将需顺序处理的数据发送到同一个 partition</li>
<li>Producer 如何保证数据发送不丢失？ack 机制，重试机制</li>
<li>如何提升 Producer 的性能？批量，异步，压缩</li>
<li>如果同一 group 下 consumer 的数量大于 part 的数量，kafka 如何处理？多余的 Part 将处于无用状态，不消费数据</li>
<li>Kafka Consumer 是否是线程安全的？不安全，单线程消费，多线程处理</li>
<li>讲一下你使用 Kafka Consumer 消费消息时的线程模型，为何如此设计？拉取和处理分离</li>
<li>Kafka Consumer 的常见配置？broker, 网络和拉取参数，心跳参数</li>
<li>Consumer 什么时候会被踢出集群？奔溃，网络异常，处理时间过长提交位移超时</li>
<li>当有 Consumer 加入或退出时，Kafka 会作何反应？进行 Rebalance</li>
<li>什么是 Rebalance，何时会发生 Rebalance？topic 变化，consumer 变化</li>
</ul>
<h2 id="高可用和性能"><a href="#高可用和性能" class="headerlink" title="高可用和性能"></a>高可用和性能</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><ul>
<li>Kafka 如何保证高可用？</li>
<li>Kafka 的交付语义？</li>
<li>Replic 的作用？</li>
<li>什么事 AR，ISR？</li>
<li>Leader 和 Flower 是什么？</li>
<li>Kafka 中的 HW、LEO、LSO、LW 等分别代表什么？</li>
<li>Kafka 为保证优越的性能做了哪些处理？</li>
</ul>
<h3 id="分区与副本"><a href="#分区与副本" class="headerlink" title="分区与副本"></a>分区与副本</h3><p><img src="/../../images/640-20210428095405441" alt="图片">分区副本</p>
<p>在分布式数据系统中，通常使用分区来提高系统的处理能力，通过副本来保证数据的高可用性。多分区意味着并发处理的能力，这多个副本中，只有一个是 leader，而其他的都是 follower 副本。仅有 leader 副本可以对外提供服务。多个 follower 副本通常存放在和 leader 副本不同的 broker 中。通过这样的机制实现了高可用，当某台机器挂掉后，其他 follower 副本也能迅速”转正“，开始对外提供服务。</p>
<p><strong>为什么 follower 副本不提供读服务？</strong></p>
<p>这个问题本质上是对性能和一致性的取舍。试想一下，如果 follower 副本也对外提供服务那会怎么样呢？首先，性能是肯定会有所提升的。但同时，会出现一系列问题。类似数据库事务中的幻读，脏读。比如你现在写入一条数据到 kafka 主题 a，消费者 b 从主题 a 消费数据，却发现消费不到，因为消费者 b 去读取的那个分区副本中，最新消息还没写入。而这个时候，另一个消费者 c 却可以消费到最新那条数据，因为它消费了 leader 副本。Kafka 通过 WH 和 Offset 的管理来决定 Consumer 可以消费哪些数据，已经当前写入的数据。</p>
<p><img src="/../../images/640-20210428095405438" alt="图片">watermark</p>
<p><strong>只有 Leader 可以对外提供读服务，那如何选举 Leader</strong></p>
<p>kafka 会将与 leader 副本保持同步的副本放到 ISR 副本集合中。当然，leader 副本是一直存在于 ISR 副本集合中的，在某些特殊情况下，ISR 副本中甚至只有 leader 一个副本。当 leader 挂掉时，kakfa 通过 zookeeper 感知到这一情况，在 ISR 副本中选取新的副本成为 leader，对外提供服务。但这样还有一个问题，前面提到过，有可能 ISR 副本集合中，只有 leader，当 leader 副本挂掉后，ISR 集合就为空，这时候怎么办呢？这时候如果设置 unclean.leader.election.enable 参数为 true，那么 kafka 会在非同步，也就是不在 ISR 副本集合中的副本中，选取出副本成为 leader。</p>
<p><strong>副本的存在就会出现副本同步问题</strong></p>
<p>Kafka 在所有分配的副本 (AR) 中维护一个可用的副本列表 (ISR)，Producer 向 Broker 发送消息时会根据<code>ack</code>配置来确定需要等待几个副本已经同步了消息才相应成功，Broker 内部会<code>ReplicaManager</code>服务来管理 flower 与 leader 之间的数据同步。</p>
<p><img src="/../../images/640-20210428095405450" alt="图片">sync</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li>partition 并发</li>
<li>顺序读写磁盘</li>
<li>page cache：按页读写</li>
<li>预读：Kafka 会将将要消费的消息提前读入内存</li>
<li>高性能序列化（二进制）</li>
<li>内存映射</li>
<li>无锁 offset 管理：提高并发能力</li>
<li>Java NIO 模型</li>
<li>批量：批量读写</li>
<li>压缩：消息压缩，存储压缩，减小网络和 IO 开销</li>
</ul>
<h4 id="Partition-并发"><a href="#Partition-并发" class="headerlink" title="Partition 并发"></a>Partition 并发</h4><p>一方面，由于不同 Partition 可位于不同机器，因此可以充分利用集群优势，实现机器间的并行处理。另一方面，由于 Partition 在物理上对应一个文件夹，即使多个 Partition 位于同一个节点，也可通过配置让同一节点上的不同 Partition 置于不同的 disk drive 上，从而实现磁盘间的并行处理，充分发挥多磁盘的优势。</p>
<h4 id="顺序读写"><a href="#顺序读写" class="headerlink" title="顺序读写"></a>顺序读写</h4><p>Kafka 每一个 partition 目录下的文件被平均切割成大小相等（默认一个文件是 500 兆，可以手动去设置）的数据文件， 每一个数据文件都被称为一个段（segment file）, 每个 segment 都采用 append 的方式追加数据。</p>
<p><img src="/../../images/640-20210428095405444.png" alt="图片">追加数据</p>
<h3 id="答案关键字-3"><a href="#答案关键字-3" class="headerlink" title="答案关键字"></a>答案关键字</h3><ul>
<li><p>Kafka 如何保证高可用？</p>
<blockquote>
<p>通过副本来保证数据的高可用，producer ack、重试、自动 Leader 选举，Consumer 自平衡</p>
</blockquote>
</li>
<li><p>Kafka 的交付语义？</p>
<blockquote>
<p>交付语义一般有<code>at least once</code>、<code>at most once</code>和<code>exactly once</code>。kafka 通过 ack 的配置来实现前两种。</p>
</blockquote>
</li>
<li><p>Replic 的作用？</p>
<blockquote>
<p>实现数据的高可用</p>
</blockquote>
</li>
<li><p>什么是 AR，ISR？</p>
<blockquote>
<p>AR：Assigned Replicas。AR 是主题被创建后，分区创建时被分配的副本集合，副本个 数由副本因子决定。ISR：In-Sync Replicas。Kafka 中特别重要的概念，指代的是 AR 中那些与 Leader 保 持同步的副本集合。在 AR 中的副本可能不在 ISR 中，但 Leader 副本天然就包含在 ISR 中。关于 ISR，还有一个常见的面试题目是如何判断副本是否应该属于 ISR。目前的判断 依据是：Follower 副本的 LEO 落后 Leader LEO 的时间，是否超过了 Broker 端参数 replica.lag.time.max.ms 值。如果超过了，副本就会被从 ISR 中移除。</p>
</blockquote>
</li>
<li><p>Leader 和 Flower 是什么？</p>
</li>
<li><p>Kafka 中的 HW 代表什么？</p>
<blockquote>
<p>高水位值 (High watermark)。这是控制消费者可读取消息范围的重要字段。一 个普通消费者只能“看到”Leader 副本上介于 Log Start Offset 和 HW（不含）之间的 所有消息。水位以上的消息是对消费者不可见的。</p>
</blockquote>
</li>
<li><p>Kafka 为保证优越的性能做了哪些处理？</p>
<blockquote>
<p>partition 并发、顺序读写磁盘、page cache 压缩、高性能序列化（二进制）、内存映射 无锁 offset 管理、Java NIO 模型</p>
</blockquote>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-25T07:12:36.000Z" title="2021/4/25 下午3:12:36">2021-04-25</time>发表</span><span class="level-item"><time dateTime="2022-05-10T06:52:17.986Z" title="2022/5/10 下午2:52:17">2022-05-10</time>更新</span><span class="level-item">5 分钟读完 (大约709个字)</span></div></div><div class="content"><p>[TOC]</p>
<h2 id="从ReentrantLock的实现看AQS的原理及应用"><a href="#从ReentrantLock的实现看AQS的原理及应用" class="headerlink" title="从ReentrantLock的实现看AQS的原理及应用"></a>从ReentrantLock的实现看AQS的原理及应用</h2><h3 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1 ReentrantLock"></a>1 ReentrantLock</h3><p><strong>1.1 ReentrantLock特性概览</strong></p>
<p><img src="/../../images/412d294ff5535bbcddc0d979b2a339e6102264.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **************************Synchronized的使用方式**************************</span></span><br><span class="line"><span class="comment">// 1.用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 2.用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="comment">// 3.用于方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 4.可重入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **************************ReentrantLock的使用方式**************************</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span> <span class="keyword">throw</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 1.初始化选择公平锁、非公平锁</span></span><br><span class="line">	<span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">	<span class="comment">// 2.可用于代码块</span></span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span></span><br><span class="line">			<span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 4.手动释放锁</span></span><br><span class="line">			lock.unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.2 ReentrantLock与AQS的关联</strong></p>
<p>ReentrantLock支持公平锁和非公平锁，并且ReentrantLock的底层就是由AQS来实现的。<br>非公平锁源码中的加锁流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#NonfairSync</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">			setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			acquire(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块代码的含义为：</p>
<ul>
<li>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</li>
<li>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</li>
</ul>
<p>平锁源码中获锁的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#FairSync</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">  ...  </span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">		acquire(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-原理概览"><a href="#2-1-原理概览" class="headerlink" title="2.1 原理概览"></a>2.1 原理概览</h3><p><img src="/../../images/7132e4cef44c26f62835b197b239147b18062.png" alt="img"></p>
<p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<p><strong>2.1.1 AQS数据结构</strong></p>
<p>AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p>
<p>解释一下几个方法和属性值的含义：</p>
<table>
<thead>
<tr>
<th align="left">方法和属性值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">waitStatus</td>
<td align="left">当前节点在队列中的状态</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示处于该节点的线程</td>
</tr>
<tr>
<td align="left">prev</td>
<td align="left">前驱指针</td>
</tr>
<tr>
<td align="left">predecessor</td>
<td align="left">返回前驱节点，没有的话抛出npe</td>
</tr>
<tr>
<td align="left">nextWaiter</td>
<td align="left">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td>
</tr>
<tr>
<td align="left">next</td>
<td align="left">后继指针</td>
</tr>
</tbody></table>
<p>线程两种锁的模式：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHARED</td>
<td align="left">表示线程以共享的模式等待锁</td>
</tr>
<tr>
<td align="left">EXCLUSIVE</td>
<td align="left">表示线程正在以独占的方式等待锁</td>
</tr>
</tbody></table>
<p>waitStatus有下面几个枚举值：</p>
<table>
<thead>
<tr>
<th align="left">枚举</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">当一个Node被初始化的时候的默认值</td>
</tr>
<tr>
<td align="left">CANCELLED</td>
<td align="left">为1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td align="left">CONDITION</td>
<td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td align="left">PROPAGATE</td>
<td align="left">为-3，当前线程处在SHARED情况下，该字段才会使用</td>
</tr>
<tr>
<td align="left">SIGNAL</td>
<td align="left">为-1，表示线程已经准备好了，就等资源释放了</td>
</tr>
</tbody></table>
<h4 id="2-1-2-同步状态State"><a href="#2-1-2-同步状态State" class="headerlink" title="2.1.2 同步状态State"></a>2.1.2 同步状态State</h4></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-16T09:42:56.000Z" title="2021/4/16 下午5:42:56">2021-04-16</time>发表</span><span class="level-item"><time dateTime="2021-04-16T09:42:56.000Z" title="2021/4/16 下午5:42:56">2021-04-16</time>更新</span><span class="level-item">几秒读完 (大约67个字)</span></div></div><div class="content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM composer:2.0</span><br><span class="line"></span><br><span class="line">RUN docker-php-source extract \</span><br><span class="line">    &amp;&amp; apk add --no-cache --virtual .phpize-deps-configure $PHPIZE_DEPS \</span><br><span class="line">    &amp;&amp; pecl install channel://pecl.php.net/apcu-5.1.20 \</span><br><span class="line">    &amp;&amp; pecl install channel://pecl.php.net/yac-2.3.0 \</span><br><span class="line">    &amp;&amp; docker-php-ext-enable apcu \</span><br><span class="line">    &amp;&amp; docker-php-ext-enable yac \</span><br><span class="line">    &amp;&amp; apk del .phpize-deps-configure \</span><br><span class="line">    &amp;&amp; docker-php-source delete</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it -v <span class="string">&quot;<span class="variable">$PWD</span>:/app&quot;</span> -v <span class="string">&quot;<span class="variable">$HOME</span>/.ssh:/root/.ssh&quot;</span> xiongyouli/composer composer  install</span><br></pre></td></tr></table></figure>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-14T06:00:40.000Z" title="2021/4/14 下午2:00:40">2021-04-14</time>发表</span><span class="level-item"><time dateTime="2022-04-05T09:21:16.015Z" title="2022/4/5 下午5:21:16">2022-04-05</time>更新</span><span class="level-item">4 分钟读完 (大约623个字)</span></div></div><div class="content"><p>[TOC]</p>
<h2 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">macOS Mojave</span><br><span class="line">10.14.6</span><br></pre></td></tr></table></figure>

<h2 id="安装PHP7-4"><a href="#安装PHP7-4" class="headerlink" title="安装PHP7.4"></a>安装PHP7.4</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">brew install php@7.4</span><br><span class="line"></span><br><span class="line">Now homebrew-php has been migrated to homebrew-core and by default, PECL should be installed along with your PHP.</span><br><span class="line">现在，homebrew php已经迁移到homebrew core，默认情况下，PECL应该与php一起安装。</span><br><span class="line">To install PHP extensions, you need to use PECL as a recommended way. </span><br><span class="line">要安装PHP扩展，建议使用PECL。</span><br><span class="line">For example: pecl install apc or pecl install xdebug.</span><br><span class="line"></span><br><span class="line">查找apcu扩展</span><br><span class="line">pecl search apcu</span><br><span class="line">sudo pecl install APCu</span><br></pre></td></tr></table></figure>

<h2 id="Mac环境目录"><a href="#Mac环境目录" class="headerlink" title="Mac环境目录"></a>Mac环境目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 通过phpinfo()打印页面</span><br><span class="line"></span><br><span class="line">1. php.ini文件目录</span><br><span class="line">Loaded Configuration File</span><br><span class="line">/usr/local/etc/php/7.1/php.ini</span><br><span class="line"></span><br><span class="line">2.扩展存放目录</span><br><span class="line">extension_dir</span><br><span class="line">/usr/local/lib/php/pecl/20160303</span><br></pre></td></tr></table></figure>

<h2 id="安装apcu"><a href="#安装apcu" class="headerlink" title="安装apcu"></a>安装apcu</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1.下载源码  </span><br><span class="line">git clone https://github.com/krakjoe/apcu</span><br><span class="line">// 2.编译安装  </span><br><span class="line">cd apcu</span><br><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">// 3. 修改php.ini文件</span><br><span class="line">extension=apcu.so</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Installing shared extensions:     /usr/lib/php/extensions/no-debug-non-zts-20160303/</span><br></pre></td></tr></table></figure>

<h2 id="phpize编译提示Cannot-find-autoconf解决办法"><a href="#phpize编译提示Cannot-find-autoconf解决办法" class="headerlink" title="phpize编译提示Cannot find autoconf解决办法"></a>phpize编译提示Cannot find autoconf解决办法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install autoconf</span><br></pre></td></tr></table></figure>

<h2 id="make命令-x2F-apc-h-67-10-fatal-error-‘php-h’-file-not-found"><a href="#make命令-x2F-apc-h-67-10-fatal-error-‘php-h’-file-not-found" class="headerlink" title="make命令 .&#x2F;apc.h:67:10: fatal error: ‘php.h’ file not found"></a>make命令 .&#x2F;apc.h:67:10: fatal error: ‘php.h’ file not found</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg</span><br></pre></td></tr></table></figure>

<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">装不了php的扩展，make install失败</span><br><span class="line"></span><br><span class="line">RudonMacBook:igbinary-master rudon$ make install</span><br><span class="line">Installing shared extensions:   /usr/lib/php/extensions/no-debug-non-zts-20131226/</span><br><span class="line">cp: /usr/lib/php/extensions/no-debug-non-zts-20131226/#INST@12567#: Operation not permitted</span><br><span class="line">make: *** [install-modules] Error 1</span><br><span class="line"></span><br><span class="line">cp: /usr/lib/php/extensions/no-debug-non-zts-20121212/#INST@17000#: Operation not permitted</span><br></pre></td></tr></table></figure>

<p>原来是OSX 10.11 El Capitan（或更高）新添加了一个新的安全机制叫系统完整性保护System Integrity Protection (SIP)，所以对于目录<br>&#x2F;System<br>&#x2F;sbin<br>&#x2F;usr<br>不包含(&#x2F;usr&#x2F;local&#x2F;)<br>仅仅供系统使用，其它用户或者程序无法直接使用，而我们的&#x2F;usr&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;刚好在受保护范围内</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>所以解决方法就是禁掉SIP保护机制，步骤是：</p>
<ul>
<li>重启系统</li>
<li>按住Command + R  （重新亮屏之后就开始按，象征地按几秒再松开，出现苹果标志，ok）</li>
<li>菜单“实用工具” &#x3D;&#x3D;&gt;&gt; “终端” &#x3D;&#x3D;&gt;&gt; 输入<strong>csrutil disable</strong>；执行后会输出：Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect.</li>
<li>再次重启系统</li>
</ul>
<p>禁止掉SIP后，就可以顺利的安装了，当然装完了以后你可以重新打开SIP，方法同上，只是命令是csrutil enable</p>
<h3 id="错误’pcre2-h’-file-not-found"><a href="#错误’pcre2-h’-file-not-found" class="headerlink" title="错误’pcre2.h’ file not found"></a>错误’pcre2.h’ file not found</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/opt/homebrew/Cellar/php@7.4/7.4.16/include/php/ext/pcre/php_pcre.h:25:10: fatal error: &#x27;pcre2.h&#x27; file not found</span><br><span class="line">#include &quot;pcre2.h&quot;</span><br><span class="line">         ^~~~~~~~~</span><br><span class="line">1 error generated.</span><br><span class="line">make: *** [php_apc.lo] Error 1</span><br><span class="line">ERROR: `make&#x27; failed</span><br></pre></td></tr></table></figure>

<p>.&#x2F;configure --with-php-config&#x3D;&#x2F;opt&#x2F;homebrew&#x2F;opt&#x2F;<a href="mailto:&#112;&#104;&#112;&#x40;&#x37;&#46;&#x34;">&#112;&#104;&#112;&#x40;&#x37;&#46;&#x34;</a>&#x2F;bin&#x2F;php-config</p>
<h3 id="112-104-x70-64-55-46-50-安装php-redis"><a href="#112-104-x70-64-55-46-50-安装php-redis" class="headerlink" title="&#112;&#104;&#x70;&#64;&#55;&#46;&#50;安装php-redis"></a><a href="mailto:&#112;&#104;&#x70;&#64;&#55;&#46;&#50;">&#112;&#104;&#x70;&#64;&#55;&#46;&#50;</a>安装php-redis</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/opt/php@7.2/bin/php-config</span><br><span class="line"></span><br><span class="line">git clone https://www.github.com/phpredis/phpredis.git</span><br><span class="line">phpize &amp;&amp; ./configure  --with-php-config=/usr/local/etc/php/7.2 &amp;&amp; make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line">Installing shared extensions:     /usr/local/Cellar/php@7.2/7.2.34_4/pecl/20170718/</span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2021/04/14/15000%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4/15001%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2docker%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%A1%88/"><img class="fill" src="/../../images/cover1.jpg" alt="离线部署docker项目方案"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-14T05:12:40.000Z" title="2021/4/14 下午1:12:40">2021-04-14</time>发表</span><span class="level-item"><time dateTime="2022-05-08T11:51:23.192Z" title="2022/5/8 下午7:51:23">2022-05-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">10 分钟读完 (大约1539个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/14/15000%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4/15001%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2docker%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%A1%88/">离线部署docker项目方案</a></h1><div class="content"><h1 id="离线部署docker项目方案"><a href="#离线部署docker项目方案" class="headerlink" title="离线部署docker项目方案"></a>离线部署docker项目方案</h1><h2 id="1-项目背景"><a href="#1-项目背景" class="headerlink" title="1. 项目背景"></a>1. 项目背景</h2><p>​    目前我行的信用卡项目使用docker部署，由于生产环境不能联网，因此不能通过dockerfile来进行构建并部署。本文主要介绍在离线环境下运行docker项目的方法，为项目的部署和实施提供参考。</p></div><a class="article-more button is-small is-size-7" href="/2021/04/14/15000%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4/15001%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2docker%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%A1%88/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-14T05:11:35.000Z" title="2021/4/14 下午1:11:35">2021-04-14</time>发表</span><span class="level-item"><time dateTime="2021-04-14T05:11:35.000Z" title="2021/4/14 下午1:11:35">2021-04-14</time>更新</span><span class="level-item">15 分钟读完 (大约2297个字)</span></div></div><div class="content"><table>
<thead>
<tr>
<th>Docker Index(Host)</th>
</tr>
</thead>
<tbody><tr>
<td>Docker Daemon</td>
</tr>
<tr>
<td>Container 1</td>
</tr>
<tr>
<td>Container 2</td>
</tr>
<tr>
<td>Container 3</td>
</tr>
</tbody></table>
<p>Docker ClientDocker Indexdocker pulldocker rundocker …Docker ClientDocker Index</p>
<blockquote>
<p>The Docker daemon<br>如上图所示，daemon在主机上面执行。用户只能通过client同daemon通讯。<br>The Docker client<br>Docker client是用户与Docker之间的重要接口。它从用户那里接受命令，并且将daemon的返回数据展现出来。 Inside Docker<br>为了深入理解docker的内部机制，需要了解以下三个组件：<br>Docker images.(镜像)<br>Docker registries.(仓库)<br>Docker containers.(容器)</p>
</blockquote>
<h3 id="So-how-does-Docker-work"><a href="#So-how-does-Docker-work" class="headerlink" title="So how does Docker work?"></a>So how does Docker work?</h3><p>目前为止，我们已经可以完成以下几个工作：</p>
<p>1、创建一个包含你需要执行应用的镜像。<br>2、根据这个镜像，你可以创建一个容器。<br>3、你可以将这个容器上传到仓库中提供给其他人使用。</p>
<p>下面，我们看一下如何执行Docker。</p>
<h3 id="How-does-a-Docker-Image-work"><a href="#How-does-a-Docker-Image-work" class="headerlink" title="How does a Docker Image work?"></a>How does a Docker Image work?</h3><p>我们知道Docker containers启动时所以来的Docker images其实是一个只读性质的模板。每个模板都包含若干层。Docker采取了 union file systems 的机制将这些曾聚合为一个image。Union file systems 允许物理隔离的文件或者目录，相互重叠覆盖，形成线性的文件系统。</p>
<p>Docker也正是基于上述层的实现方式而做到了轻量级。当你修改一个image时，docker并没有修改原有的image数据，而是新建了一个数据层。当你在docker中修改整个image或者重建实体时，原有数据都没有变化，只是若干层发生了变化。所以当image发生了变化时，不需要重新同步整个image，而只要将发生变化的层同步一次就可以。这样就使docker image做的快速并且简单。</p>
<p>每个image都是从base image演变过来的。你可以创建你的base image。如果你有apache的image，就可以把这个镜像作为你应用程序的base image。</p>
<p>Note：Docker 一般都是从Dock Hub上面获取base images。</p>
<p>Docker通过一些很简单的步骤就可以依据base images创建新的image。每执行一个步骤，新的image就会创建一个新层(layer)。基本的步骤如下：</p>
<ul>
<li>Run a command.</li>
<li>Add a file or directory.</li>
<li>Create an environment variable.</li>
<li>What process to run when launching a container from this image.</li>
</ul>
<p>这些命令可以再Dockerfile中定义。当你需要新建一个image是，docker可以自动读取Dockerfile中的命令，并且执行这些命令。最终生成一个新的image。</p>
<h3 id="How-does-a-Docker-registry-work"><a href="#How-does-a-Docker-registry-work" class="headerlink" title="How does a Docker registry work?"></a>How does a Docker registry work?</h3><p>Docker registry是用来保存images的。当你新建好image后，就可以将image上传到Dock Hub或者你私有的store中。</p>
<p>借助于Docker client，你可以在Dock Hub检索你所需的image，同时将这些image下载到本地。</p>
<p>同时Dock Hub也提供公开和私有两种模式，处于公开模式下的image，所有人都可以下载和使用这些image。而处于私有模式下的image，只有本人或者经过授权后的人才能下载并且使用这些image。</p>
<h3 id="How-does-a-container-work"><a href="#How-does-a-container-work" class="headerlink" title="How does a container work?"></a>How does a container work?</h3><p>一个标准容器包括：操作系统，用户自定义的文件和原数据。正如我们所知的那样，每个容器都是由image所创建的。image告诉docker，这个容器运行时，应该有哪些进程和应该有哪些配置参数。因为image是只读的，所以容器在运行时会在image原有层的基础上面创建一些可读可写的新层。而你的应用运行所需的数据将会被记录到这些数据层中。</p>
<h3 id="What-happens-when-you-run-a-container"><a href="#What-happens-when-you-run-a-container" class="headerlink" title="What happens when you run a container?"></a>What happens when you run a container?</h3><p>不论是使用docker程序或者API，docker client都会通知docker daemon如何操作容器。</p>
<p>当我们执行如下命令时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>docker client会启动，然后使用后面的run参数来通知docker daemon启动一个新容器。这个简短的命令将会通知docker daemon以下信息：</p>
<p>1.容器所需的image在哪里，这里image名称是ubuntu，是一个base image。<br>2.当容器启动时，你想让容器初始化的动作，这里我们需要容器启动时自动切换到&#x2F;bin&#x2F;bash下面。</p>
<p>所以当我们敲下回车后，docker将会如何处理呢？</p>
<ul>
<li><strong>Pulls the ubuntu image:</strong><br>Docker检测image是否存在，如果本地不存在，则默认从Dock Hub下载。如果本地存在，则使用本地的image启动容器。</li>
<li><strong>Creates a new container:</strong><br>Docker加载image，然后创建容器。 Allocates a filesystem and mounts a read-write layer : 容器开始创建文件系统，并且在image上面添加可读可写的数据层。</li>
<li><strong>Allocates a network &#x2F; bridge interface:</strong> Docker开始创建网络接口，并且允许容器同主机进行关联。</li>
<li><strong>Sets up an IP address:</strong><br>Docker从IP资源池中挑选一个分配给容器。</li>
<li><strong>Executes a process that you specify:</strong> Docker开始执行指定的应用或者命令</li>
<li><strong>Captures and provides application output:</strong> Docker将执行过程当中的输出或者错误信息返回给Client。让用户可以知道当前应用执行的情况.</li>
</ul>
<p>以上是容器的执行过程，下面我们将开始描述如何管理容器，包括：结束，停止和移除。</p>
<h3 id="The-underlying-technology"><a href="#The-underlying-technology" class="headerlink" title="The underlying technology"></a>The underlying technology</h3><p>Docker 底层使用的是Linux内核中的虚拟化技术，来呈现我们刚才所看到的一切功能。</p>
<h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h3><p>Docker采用了称之为”Namespaces”的技术解决方案来隔离不同的workspace(也就是上面所定义的容器)。当你执行一个容器时，docker会为这个容器创建一系列的namespace。</p>
<p>以下是docker所创建的namespace：</p>
<ul>
<li><strong>The pid namespace</strong>: 用来隔离进程。(PID就是process id)</li>
<li><strong>The net namespace</strong>: 用来管理网络接口</li>
<li><strong>The ipc namespace</strong>: 用来控制IPC资源的访问。</li>
<li><strong>The mnt namespace</strong>: 用来管理挂载点(mnt是 mount point)</li>
<li><strong>The uts namespace</strong>: 用来隔离内核和版本信息(UTS，分时复用系统 Unix Timesharing System)</li>
</ul>
<h3 id="Control-groups"><a href="#Control-groups" class="headerlink" title="Control groups"></a>Control groups</h3><p>Docker同时也采用了一种称之为”cgroups”的技术来控制group。不同应用之间隔离的关键在于，每个应用只能访问属于自己的资源。这样才能确保主机上面同时存在多个用户。Cgroups可以确保docker将可用的硬件资源共享给所有容器，并且可以在必要时间，对容器限制硬件资源。例如可以限制每个容器可以访问的内存容量。</p>
<h3 id="Union-file-systems"><a href="#Union-file-systems" class="headerlink" title="Union file systems"></a>Union file systems</h3><p>Union file systems 或者称为”UnionFS”是docker在创建层时采用的文件系统。这种文件系统使docker变得很轻量级并且执行速度很快。Docker使用UnionFS为容器提供相对应的数据块(data blocks)。Docker可以使用多种类型的UnionFS，比如：AUFS, btrfs, vfs, and DeviceMapper.</p>
<h3 id="Container-format"><a href="#Container-format" class="headerlink" title="Container format"></a>Container format</h3><p>Docker将上面我们所描述的各种组件封装成container数据类型(我们就称其为容器)。默认的容器类型是libcontainer。Docker同样也支持传统Linux使用LXC实现的容器类型。再未来，Docker也将支持其他类型的容器，比如：BSD Jails 或者Solaris Zones 版本的容器类型。</p>
<h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br><span class="line">sudo usermod -a -G docker &lt;your username&gt;</span><br><span class="line">restart your linux</span><br><span class="line"></span><br><span class="line">usermod:</span><br><span class="line">-modify a user account</span><br><span class="line">-a add the user to the supplementary group. Use only with -G option</span><br></pre></td></tr></table></figure>

<p>Q:Cannot connect to the Docker daemon. Is the docker daemon running on this host?</p>
<blockquote>
<p>A:The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can access it with sudo. For this reason, docker daemon always runs as the <strong>root</strong> user.</p>
</blockquote>
<blockquote>
<p>To avoid having to use sudo when you use the docker command, create a Unix group called <strong>docker</strong> and <strong>add users to it</strong>. When the docker daemon starts, it makes the ownership of the Unix socket read&#x2F;writable by the docker group.</p>
</blockquote>
<h4 id="测试Docker"><a href="#测试Docker" class="headerlink" title="测试Docker"></a>测试Docker</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service docker status</span><br><span class="line">sudo docker run hello-world</span><br><span class="line">sudo docker run docker/whalesay cowsay xxx123</span><br></pre></td></tr></table></figure>

<h4 id="显示所有images"><a href="#显示所有images" class="headerlink" title="显示所有images"></a>显示所有images</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure>

<h4 id="显示所有containers"><a href="#显示所有containers" class="headerlink" title="显示所有containers"></a>显示所有containers</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure>

<h4 id="删除container和image"><a href="#删除container和image" class="headerlink" title="删除container和image"></a>删除container和image</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rm xxx_container</span><br><span class="line">sudo docker rmi yyy_image</span><br></pre></td></tr></table></figure>

<h4 id="交互启动container"><a href="#交互启动container" class="headerlink" title="交互启动container"></a>交互启动container</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker start -a -i xxx_container</span><br></pre></td></tr></table></figure>

<h4 id="交互式运行image"><a href="#交互式运行image" class="headerlink" title="交互式运行image"></a>交互式运行image</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it xxx_container bash</span><br></pre></td></tr></table></figure>

<h4 id="挂载某container"><a href="#挂载某container" class="headerlink" title="挂载某container"></a>挂载某container</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker attach xxx_container</span><br></pre></td></tr></table></figure>

<h4 id="显示container或者image相关信息"><a href="#显示container或者image相关信息" class="headerlink" title="显示container或者image相关信息"></a>显示container或者image相关信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect img_name | container_name</span><br></pre></td></tr></table></figure>

<h4 id="显示container-IP"><a href="#显示container-IP" class="headerlink" title="显示container IP"></a>显示container IP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect -f &#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; xxx_container</span><br></pre></td></tr></table></figure>

<h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker cp local_file_path container:container_file_path</span><br><span class="line">sudo docker cp container:container_file_path local_file_path</span><br></pre></td></tr></table></figure>

<h4 id="创建镜像image"><a href="#创建镜像image" class="headerlink" title="创建镜像image"></a>创建镜像image</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -f dockerfile -t img_name .</span><br></pre></td></tr></table></figure>

<h4 id="保存镜像为文件"><a href="#保存镜像为文件" class="headerlink" title="保存镜像为文件"></a>保存镜像为文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o filename.tgz img_name</span><br></pre></td></tr></table></figure>

<h4 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i img_name </span><br></pre></td></tr></table></figure>

<h4 id="SSH-到镜像，即登录进行进行debug"><a href="#SSH-到镜像，即登录进行进行debug" class="headerlink" title="SSH 到镜像，即登录进行进行debug"></a>SSH 到镜像，即登录进行进行debug</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it img_name /bin/bash</span><br><span class="line">Docker Registry基本操作</span><br><span class="line"></span><br><span class="line">docker registry: https://github.com/docker/distribution.git</span><br><span class="line">Start docker registry server:</span><br><span class="line"></span><br><span class="line">docker run -d -it \ --name con_docker_registry \ -h hostname \ -v /data/docker-registry:/var/lib/registry \ -p 5000:5000 \ docker-registry</span><br><span class="line">View the image list</span><br><span class="line"></span><br><span class="line">curl -v -X GET localhost:5000/v2/_catalog</span><br></pre></td></tr></table></figure></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/13/">上一页</a></div><div class="pagination-next"><a href="/page/15/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/13/">13</a></li><li><a class="pagination-link is-current" href="/page/14/">14</a></li><li><a class="pagination-link" href="/page/15/">15</a></li><li><a class="pagination-link" href="/page/16/">16</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Tonygeli"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tonygeli</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SH</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">159</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">30</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tonygeli" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/JAVA/"><span class="level-start"><span class="level-item">JAVA</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux%E5%91%BD%E4%BB%A4/"><span class="level-start"><span class="level-item">Linux命令</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">时间管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%93%E5%AD%98/"><span class="level-start"><span class="level-item">缓存</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6/"><span class="level-start"><span class="level-item">读书</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bean/"><span class="tag">Bean</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CPU%E6%8C%87%E6%A0%87/"><span class="tag">CPU指标</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus/"><span class="tag">Icarus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySql/"><span class="tag">MySql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Netty/"><span class="tag">Netty</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stream/"><span class="tag">Stream</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8B%E5%8A%A1/"><span class="tag">事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"><span class="tag">公众号</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><span class="tag">内存分配</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><span class="tag">分布式事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"><span class="tag">分布式缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><span class="tag">单点登录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A0%86%E7%BC%93%E5%AD%98/"><span class="tag">堆缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91/"><span class="tag">并发</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%95%E7%94%A8/"><span class="tag">引用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%BB%E9%94%81/"><span class="tag">死锁</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"><span class="tag">自动装配</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%99%90%E6%B5%81/"><span class="tag">限流</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-16T10:18:24.850Z">2022-05-16</time></p><p class="title"><a href="/2022/05/16/12000%E9%9D%A2%E8%AF%95/12008%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E8%AE%AF/">线程之间如何进行通讯</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-16T10:14:45.012Z">2022-05-16</time></p><p class="title"><a href="/2022/05/16/12000%E9%9D%A2%E8%AF%95/12007%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/">如何查看线程死锁</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-15T15:22:11.939Z">2022-05-15</time></p><p class="title"><a href="/2022/05/15/12000%E9%9D%A2%E8%AF%95/12006CPU%E8%BF%87%E9%AB%98%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5/">CPU过高如何排查</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-15T14:58:58.764Z">2022-05-15</time></p><p class="title"><a href="/2022/05/15/13000Linux/13003Linux%E5%91%BD%E4%BB%A4df/">Linux命令df</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-15T12:24:37.230Z">2022-05-15</time></p><p class="title"><a href="/2022/05/15/14000JAVA/14003LongAdder/">LongAdder</a></p><p class="categories"><a href="/categories/JAVA/">JAVA</a></p></div></article></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a><p class="is-size-7"><span>&copy; 2022 Tonygeli</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>