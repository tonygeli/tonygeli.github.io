<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>LILAIQUN</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LILAIQUN"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LILAIQUN"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="LILAIQUN"><meta property="og:url" content="https://tonygeli.github.io/"><meta property="og:site_name" content="LILAIQUN"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tonygeli.github.io/img/og_image.png"><meta property="article:author" content="Tonygeli"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonygeli.github.io"},"headline":"LILAIQUN","image":["https://tonygeli.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tonygeli"},"publisher":{"@type":"Organization","name":"LILAIQUN","logo":{"@type":"ImageObject","url":"https://tonygeli.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?1ecc72096a22e2426f0bc13519c3c3c7";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-24T03:31:18.000Z" title="2021/6/24 上午11:31:18">2021-06-24</time>发表</span><span class="level-item"><time dateTime="2021-06-24T03:31:18.000Z" title="2021/6/24 上午11:31:18">2021-06-24</time>更新</span><span class="level-item">3 分钟读完 (大约416个字)</span></div></div><div class="content"><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>​	上一节我们学会了使用 HyperLogLog 数据结构来进行估数，它非常有价值，可以解决很多精确度不高的统计需求。</p>
<p>​	但是如果我们想知道某一个值是不是已经在 HyperLogLog 结构里面了，它就无能为力了，它只提供了 pfadd 和 pfcount 方法，没有提供 pfcontains 这种方法。</p>
<p>​	布隆过滤器 (Bloom Filter) 闪亮登场了，它就是专门用来解决这种去重问题的。它在起到去重的同时，在空间上还能节省 90% 以上，只是稍微有那么点不精确，也就是有一定的误判概率。</p>
<h3 id="布隆过滤器是什么？"><a href="#布隆过滤器是什么？" class="headerlink" title="布隆过滤器是什么？"></a>布隆过滤器是什么？</h3><p>​	布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。</p>
<p>​	当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。打个比方，当它说不认识你时，肯定就不认识；当它说见过你时，可能根本就没见过面，不过因为你的脸跟它认识的人中某脸比较相似 (某些熟脸的系数组合)，所以误判以前见过你。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-21T02:37:32.000Z" title="2021/6/21 上午10:37:32">2021-06-21</time>发表</span><span class="level-item"><time dateTime="2022-03-15T13:13:42.749Z" title="2022/3/15 下午9:13:42">2022-03-15</time>更新</span><span class="level-item">12 分钟读完 (大约1733个字)</span></div></div><div class="content"><h3 id="问题一：RabbitMQ-中的-broker-是指什么？cluster-又是指什么？"><a href="#问题一：RabbitMQ-中的-broker-是指什么？cluster-又是指什么？" class="headerlink" title="问题一：RabbitMQ 中的 broker 是指什么？cluster 又是指什么？"></a>问题一：RabbitMQ 中的 broker 是指什么？cluster 又是指什么？</h3><p>答：broker 是指一个或多个 erlang node 的逻辑分组，且 node 上运行着 RabbitMQ 应用程序。cluster 是在 broker 的基础之上，增加了 node 之间共享元数据的约束。</p>
<h3 id="问题二：什么是元数据？元数据分为哪些类型？包括哪些内容？与-cluster-相关的元数据有哪些？元数据是如何保存的？元数据在-cluster-中是如何分布的？"><a href="#问题二：什么是元数据？元数据分为哪些类型？包括哪些内容？与-cluster-相关的元数据有哪些？元数据是如何保存的？元数据在-cluster-中是如何分布的？" class="headerlink" title="问题二：什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？"></a>问题二：什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？</h3><p>答：在非 cluster 模式下，元数据主要分为 Queue 元数据（queue 名字和属性等）、Exchange 元数据（exchange 名字、类型和属性等）、Binding 元数据（存放路由关系的查找表）、Vhost 元数据（vhost 范围内针对前三者的名字空间约束</p>
<p>和安全属性设置）。在cluster 模式下，还包括 cluster 中 node 位置信息和 node 关系信息。元数据按照 erlang node 的类型确定是仅保存于 RAM 中，还是同时保存在 RAM 和 disk 上。元数据在cluster 中是全 node 分布的。</p>
<p>下图所示为 queue 的元数据在单 node 和 cluster 两种模式下的分布图。</p>
<h3 id="问题三：RAM-node-和-disk-node-的区别？"><a href="#问题三：RAM-node-和-disk-node-的区别？" class="headerlink" title="问题三：RAM node 和 disk node 的区别？"></a>问题三：RAM node 和 disk node 的区别？</h3><p>答：RAM node 仅将 fabric（即 queue、exchange 和 binding 等 RabbitMQ 基础构件）相关元数据保存到内存中，但 disk node 会在内存和磁盘中均进行存储。RAM node 上唯一会存储到磁盘上的元数据是 cluster 中使用的 disk node 的地址。要求在 RabbitMQ cluster中至少存在一个 disk node 。</p>
<h3 id="问题四：RabbitMQ-上的一个-queue-中存放的-message-是否有数量限制？"><a href="#问题四：RabbitMQ-上的一个-queue-中存放的-message-是否有数量限制？" class="headerlink" title="问题四：RabbitMQ 上的一个 queue 中存放的 message 是否有数量限制？"></a>问题四：RabbitMQ 上的一个 queue 中存放的 message 是否有数量限制？</h3><p>答：可以认为是无限制，因为限制取决于机器的内存，但是消息过多会导致处理效率的下降。</p>
<h3 id="问题五：RabbitMQ-概念里的-channel、exchange-和-queue-这些东东是逻辑概念，还是对应着进程实体？这些东东分别起什么作用？"><a href="#问题五：RabbitMQ-概念里的-channel、exchange-和-queue-这些东东是逻辑概念，还是对应着进程实体？这些东东分别起什么作用？" class="headerlink" title="问题五：RabbitMQ 概念里的 channel、exchange 和 queue 这些东东是逻辑概念，还是对应着进程实体？这些东东分别起什么作用？"></a>问题五：RabbitMQ 概念里的 channel、exchange 和 queue 这些东东是逻辑概念，还是对应着进程实体？这些东东分别起什么作用？</h3><p>答：queue 具有自己的 erlang 进程；exchange 内部实现为保存 binding 关系的查找表；channel 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给queue 。由 AMQP 协议描述可知，channel 是真实 TCP 连接之上的虚拟连接，所有AMQP 命令都是通过 channel 发送的，且每一个 channel 有唯一的 ID。一个 channel 只能被单独一个操作系统线程使用，故投递到特定 channel 上的 message 是有顺序的。但一个操作系统线程上允许使用多个 channel 。channel 号为 0 的 channel 用于处理所有对于当前 connection 全局有效的帧，而 1-65535 号 channel 用于处理和特定 channel 相关的帧。AMQP 协议给出的 channel 复用模型如下</p>
<p>其中每一个 channel 运行在一个独立的线程上，多线程共享同一个 socket。</p>
<h3 id="问题六：vhost-是什么？起什么作用？"><a href="#问题六：vhost-是什么？起什么作用？" class="headerlink" title="问题六：vhost 是什么？起什么作用？"></a>问题六：vhost 是什么？起什么作用？</h3><p>答：vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。</p>
<p>【cluster 相关】</p>
<p>问题七：在单 node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及</p>
<p>进行 binding 会有什么不同？</p>
<p>答：当你在单 node 上声明 queue 时，只要该 node 上相关元数据进行了变更，你就会</p>
<p>得到 Queue.Declare-ok 回应；而在 cluster 上声明 queue ，则要求 cluster 上的全部</p>
<p>node 都要进行元数据成功更新，才会得到 Queue.Declare-ok 回应。另外，若 node 类型</p>
<p>为 RAM node 则变更的数据仅保存在内存中，若类型为 disk node 则还要变更保存在磁盘</p>
<p>上的数据。</p>
<p>问题八：客户端连接到 cluster 中的任意 node 上是否都能正常工作？</p>
<p>答：是的。客户端感觉不到有何不同。</p>
<p>问题九：若 cluster 中拥有某个 queue 的 owner node 失效了，且该 queue 被声明具有</p>
<p>durable 属性，是否能够成功从其他 node 上重新声明该 queue ？</p>
<p>答：不能，在这种情况下，将得到 404 NOT_FOUND 错误。只能等 queue 所属的 node</p>
<p>恢复后才能使用该 queue 。但若该 queue 本身不具有 durable 属性，则可在其他 node</p>
<p>上重新声明。</p>
<p>问题十：cluster 中 node 的失效会对 consumer 产生什么影响？若是在 cluster 中创建了</p>
<p>mirrored queue ，这时 node 失效会对 consumer 产生什么影响？</p>
<p>答：若是 consumer 所连接的那个 node 失效（无论该 node 是否为 consumer 所订阅</p>
<p>queue 的 owner node），则 consumer 会在发现 TCP 连接断开时，按标准行为执行重连</p>
<p>逻辑，并根据“Assume Nothing”原则重建相应的 fabric 即可。若是失效的 node 为</p>
<p>consumer 订阅 queue 的 owner node，则 consumer 只能通过 Consumer Cancellation</p>
<p>Notification 机制来检测与该 queue 订阅关系的终止，否则会出现傻等却没有任何消息来</p>
<p>到的问题。</p>
<p>问题十一：能够在地理上分开的不同数据中心使用 RabbitMQ cluster 么？</p>
<p>答：不能。第一，你无法控制所创建的 queue 实际分布在 cluster 里的哪个 node 上（一</p>
<p>般使用 HAProxy + cluster 模型时都是这样），这可能会导致各种跨地域访问时的常见问</p>
<p>题；第二，Erlang 的 OTP 通信框架对延迟的容忍度有限，这可能会触发各种超时，导致</p>
<p>业务疲于处理；第三，在广域网上的连接失效问题将导致经典的“脑裂”问题，而</p>
<p>RabbitMQ 目前无法处理（该问题主要是说 Mnesia）。</p>
<p>【综合问题】</p>
<p>问题十二：为什么 heavy RPC 的使用场景下不建议采用 disk node ？</p>
<p>答：heavy RPC 是指在业务逻辑中高频调用 RabbitMQ 提供的 RPC 机制，导致不断创建、</p>
<p>销毁 reply queue ，进而造成 disk node 的性能问题（因为会针对元数据不断写盘）。所以</p>
<p>在使用 RPC 机制时需要考虑自身的业务场景。</p>
<p>问题十三：向不存在的 exchange 发 publish 消息会发生什么？向不存在的 queue 执行</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-18T09:16:25.000Z" title="2021/6/18 下午5:16:25">2021-06-18</time>发表</span><span class="level-item"><time dateTime="2021-06-18T09:16:25.000Z" title="2021/6/18 下午5:16:25">2021-06-18</time>更新</span><span class="level-item">15 分钟读完 (大约2182个字)</span></div></div><div class="content"><p>[toc]</p>
<h3 id="异步与非阻塞"><a href="#异步与非阻塞" class="headerlink" title="异步与非阻塞"></a>异步与非阻塞</h3><p>异步是目的.</p>
<p>异步线程中 rpc调用， 网络io多  设置线程数 2n</p>
<p>同步方式读取外部服务时，首先主线程会从<strong>用户模式</strong>进入到<strong>内核模式</strong>，在内核模式中windows会将你的请求数据交给对应的网络驱动程序，继后会让这个线程进入休眠状态</p>
<p>异步方式就是为了解放主线程，步骤三中将thread数据交给网络驱动程序之后，该thread就直接返回不管了，当后续网络驱动程序获取数据后，将数据丢给CLR线程池中的IO线程再由它触发你的回调函数。</p>
<p><img src="/../../images/214741-20200420191705462-414122379.png" alt="img"></p>
<h3 id="多线程优先级"><a href="#多线程优先级" class="headerlink" title="多线程优先级"></a>多线程优先级</h3><p>子线程默认优先级和父线程一样，Java 主线程默认的优先级是 5。Java 优先级范围是 <strong>[1, 10]</strong></p>
<p>注解开发 内置tomcat jar包运行  </p>
<p>自动化配置的效果：</p>
<p>spI机制  </p>
<p>排除一些依赖包： exclude  </p>
<h3 id="MyBatis-的区别"><a href="#MyBatis-的区别" class="headerlink" title="MyBatis # $的区别"></a>MyBatis # $的区别</h3><p>#防止sql注入  $不做转义，传字段、表名</p>
<p> <if test="aIn != 'A'" >会出现问题，系统会试图把’A’转成数字，改为<br> <if test='aIn != "A"' >;</p>
<p>结果集 对一个字段加密： 插件机制 </p>
<p> 一二级缓存：数据一致性问题</p>
<p> hibnate  </p>
<p>NoSql  </p>
<h3 id="mongodb优势："><a href="#mongodb优势：" class="headerlink" title="mongodb优势："></a>mongodb优势：</h3><h4 id="①弱一致性（最终一致），更能保证用户的访问速度："><a href="#①弱一致性（最终一致），更能保证用户的访问速度：" class="headerlink" title="①弱一致性（最终一致），更能保证用户的访问速度："></a><strong>①弱一致性（最终一致），更能保证用户的访问速度：</strong></h4><p>举例来说，在  传统的关系型数据库中，一个COUNT类型的操作会锁定数据集，这样可以保证得到“当前”情况下的精确值。这在某些情况下，例如通过ATM查看账户信息的   时候很重要，但对于Wordnik来说，数据是不断更新和增长的，这种“精确”的保证几乎没有任何意义，反而会产生很大的延迟。他们需要的是一个“大约”  的数字以及更快的处理速度。</p>
<p>但某些情况下MongoDB会锁住数据库。如果此时正有数百个请求，则它们会堆积起来，造成许多问题。我们使用  了下面的优化方式来避免锁定：每次更新前，我们会先查询记录。查询操作会将对象放入内存，于是更新则会尽可能的迅速。在主&#x2F;从部署方案中，从节点可以使用  “-pretouch”参数运行，这也可以得到相同的效果。使用多个mongod进程。我们根据访问模式将数据库拆分成多个进程。</p>
<h4 id="②文档结构的存储方式，能够更便捷的获取数据。"><a href="#②文档结构的存储方式，能够更便捷的获取数据。" class="headerlink" title="②文档结构的存储方式，能够更便捷的获取数据。"></a><strong>②文档结构的存储方式，能够更便捷的获取数据。</strong></h4><p>对于一个层级式的数据结构来说，如果要将这样的数据使用扁平式的，表状的结构来保存数据，这无论是在查询还是获取数据时都十分困难。</p>
<h4 id="③内置GridFS，支持大容量的存储。"><a href="#③内置GridFS，支持大容量的存储。" class="headerlink" title="③内置GridFS，支持大容量的存储。"></a><strong>③内置GridFS，支持大容量的存储。</strong></h4><p>GridFS是一个出色的分布式文件系统，可以支持海量的数据存储。内置了GridFS了MongoDB，能够满足对大数据集的快速范围查询。</p>
<h4 id="④内置Sharding。"><a href="#④内置Sharding。" class="headerlink" title="④内置Sharding。"></a><strong>④内置Sharding。</strong></h4><p>提供基于Range的AutoSharding机制：一个collection可按照记录的范围，分成若干个段，切分到不同的Shard上。</p>
<p>Shards可以和复制结合，配合Replicasets能够实现Sharding+fail-over，不同的Shard之间可以负载均衡。查询是对客  户端是透明的。客户端执行查询，统计，MapReduce等操作，这些会被MongoDB自动路由到后端的数据节点。这让我们关注于自己的业务，适当的时  候可以无痛的升级。MongoDB的Sharding设计能力最大可支持约20petabytes，足以支撑一般应用。</p>
<p>这可以保证MongoDB运行在便宜的PC服务器集群上。PC集群扩充起来非常方便并且成本很低，避免了“sharding”操作的复杂性和成本。</p>
<h4 id="⑤第三方支持丰富。-这是与其他的NoSQL相比，MongoDB也具有的优势"><a href="#⑤第三方支持丰富。-这是与其他的NoSQL相比，MongoDB也具有的优势" class="headerlink" title="⑤第三方支持丰富。(这是与其他的NoSQL相比，MongoDB也具有的优势)"></a><strong>⑤第三方支持丰富。(这是与其他的NoSQL相比，MongoDB也具有的优势)</strong></h4><p>现在网络上的很多NoSQL开源数据库完全属于社区型的，没有官方支持，给使用者带来了很大的风险。</p>
<p>而开源文档数据库MongoDB背后有商业公司10gen为其提供供商业培训和支持。</p>
<p>而且MongoDB社区非常活跃，很多开发框架都迅速提供了对MongDB的支持。不少知名大公司和网站也在生产环境中使用MongoDB，越来越多的创新型企业转而使用MongoDB作为和Django，RoR来搭配的技术方案。</p>
<h4 id="⑥性能优越"><a href="#⑥性能优越" class="headerlink" title="⑥性能优越"></a><strong>⑥性能优越</strong></h4><p>在  使用场合下，千万级别的文档对象，近10G的数据，对有索引的ID的查询不会比<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cdb?from=10680">mysql</a>慢，而对非索引字段的查询，则是全面胜出。mysql实际无法胜   任大数据量下任意字段的查询，而mongodb的查询性能实在让我惊讶。写入性能同样很令人满意，同样写入百万级别的数据，mongodb比我以前试用过  的couchdb要快得多，基本10分钟以下可以解决。补上一句，观察过程中mongodb都远算不上是CPU杀手。</p>
<h4 id="与关系型数据库相比，MongoDB的缺点："><a href="#与关系型数据库相比，MongoDB的缺点：" class="headerlink" title="与关系型数据库相比，MongoDB的缺点："></a><strong>与关系型数据库相比，MongoDB的缺点：</strong></h4><h4 id="①mongodb不支持事务操作。"><a href="#①mongodb不支持事务操作。" class="headerlink" title="①mongodb不支持事务操作。"></a><strong>①mongodb不支持事务操作。</strong></h4><p>所以事务要求严格的系统（如果银行系统）肯定不能用它。(这点和优点①是对应的)</p>
<h4 id="②mongodb占用空间过大。"><a href="#②mongodb占用空间过大。" class="headerlink" title="②mongodb占用空间过大。"></a><strong>②mongodb占用空间过大。</strong></h4><p>关于其原因，在官方的FAQ中，提到有如下几个方面：</p>
<p>1、  空间的预分配：为避免形成过多的硬盘碎片，mongodb每次空间不足时都会申请生成一大块的硬盘空间，而且申请的量从64M、128M、256M那样的  指数递增，直到2G为单个文件的最大体积。随着数据量的增加，你可以在其数据目录里看到这些整块生成容量不断递增的文件。</p>
<p>2、字段名所占用  的空间：为了保持每个记录内的结构信息用于查询，mongodb需要把每个字段的key-value都以BSON的形式存储，如果value域相对于  key域并不大，比如存放数值型的数据，则数据的overhead是最大的。一种减少空间占用的方法是把字段名尽量取短一些，这样占用空间就小了，但这就   要求在易读性与空间占用上作为权衡了。我曾建议作者把字段名作个index，每个字段名用一个字节表示，这样就不用担心字段名取多长了。但作者的担忧也不   无道理，这种索引方式需要每次查询得到结果后把索引值跟原值作一个替换，再发送到客户端，这个替换也是挺耗费时间的。现在的实现算是拿空间来换取时间吧。</p>
<p>3、删除记录不释放空间：这很容易理解，为避免记录删除后的数据的大规模挪动，原记录空间不删除，只标记“已删除”即可，以后还可以重复利用。</p>
<p>4、可以定期运行db.repairDatabase()来整理记录，但这个过程会比较缓慢</p>
<h4 id="③MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方"><a href="#③MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方" class="headerlink" title="③MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方"></a><strong>③MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方</strong></h4><p>es和mongodb区别   </p>
<p>设计模式 </p>
<p>工厂模式： </p>
<p>1.简单工厂： </p>
<p>2.抽象工厂： </p>
<p>和建造者什么区别</p>
<h3 id="抽象类和接口类"><a href="#抽象类和接口类" class="headerlink" title="抽象类和接口类"></a>抽象类和接口类</h3><p>他们的区别如下：</p>
<ol>
<li>在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。</li>
<li>一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。</li>
</ol>
<h3 id="API和SPI区别"><a href="#API和SPI区别" class="headerlink" title="API和SPI区别"></a>API和SPI区别</h3><p>API可以直接使用，SPI一种规范，需要被继承</p>
<p>性能压测 </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-16T09:01:31.000Z" title="2021/6/16 下午5:01:31">2021-06-16</time>发表</span><span class="level-item"><time dateTime="2021-06-16T09:01:31.000Z" title="2021/6/16 下午5:01:31">2021-06-16</time>更新</span><span class="level-item">7 分钟读完 (大约1016个字)</span></div></div><div class="content"><h2 id="常见分布式锁实现"><a href="#常见分布式锁实现" class="headerlink" title="常见分布式锁实现"></a>常见分布式锁实现</h2><p>有基于redis、基于数据库、基于zookeeper或etcd等几种实现方式，下面简单对比下这几种实现方式：</p>
<h3 id="基于redis实现"><a href="#基于redis实现" class="headerlink" title="基于redis实现"></a>基于redis实现</h3><p>对于业务来说，redis使用比较轻便，性能也比较高，通过调研，有90%的业务都是基于redis实现分布式锁。但业务线基本上都是采用单个redis节点实现分布式锁，当redis节点发生failover时，主从节点基于异步复制保证不了数据的强一致性，有可能多个客户端同时获取到锁。Redis的作者提出了一个更安全的实现，叫做Redlock，要求通过N个完全独立的Redis节点基于Quorum机制实现分布式锁，但是N个节点数据同步问题也比较复杂。</p>
<p>另外，大神 Martin Kleppmann，在文章《How to do distributed locking》中对分布式锁原理进行论证，指出Redlock解决不了持有锁的客户端GC pause问题，如下图所示。</p>
<p><img src="/../../images/redis_realize_1.png" alt="avatar"></p>
<p>客户端1在获得锁之后发生了很长时间的GC pause，在此期间，它获得的锁过期了，而客户端2获得了锁。当客户端1从GC pause中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源（上图中是一个存储服务）发起了写数据请求，而这时锁实际上被客户端2持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。除了GC pasue场景，时钟跳跃也会引发同样的问题，解决这个问题，Martin提出可以引入fencing token，即锁的版本号，在锁持有者放生变更时fencing token递增更新，客户端访问共享资源时携带着这个fencing token，这样提供共享资源的服务就能根据它进行检查，拒绝掉延迟到来的访问请求（避免了冲突），如下图所示。</p>
<p><img src="/../../images/redis_realize_2.png" alt="avatar"></p>
<p>Redis分布式锁引入fencing token机制，为了保证释放锁的安全性，即每个客户端只能释放自己持有的锁，必须使用lua脚本或者事务机制实现GET、比较、DEL这三步操作的原子性（类似于乐观锁机制），使用起来也不是特别方便。</p>
<p>总体来说，如果想要使用redis实现一套特别可靠的分布式锁服务，还是比较复杂的，对于吞吐量比较高并且有一定容错机制的服务，可以考虑直接采用单redis节点的分布式锁方案。</p>
<h3 id="基于Zookeeper实现"><a href="#基于Zookeeper实现" class="headerlink" title="基于Zookeeper实现"></a>基于Zookeeper实现</h3><p>基于Zookeeper临时有序节点实现分布式锁，通过ZAB协议保证数据一致性。具有Watch功能，可以高效实现阻塞锁。不过业务需要单独部署Zookeeper集群，每个lockkey需要关联一个客户端连接session，不够灵活，性能较差；</p>
<h3 id="基于ETCD实现"><a href="#基于ETCD实现" class="headerlink" title="基于ETCD实现"></a>基于ETCD实现</h3><p>采用etcd自带的kv存储，通过lockkey的状态值控制锁的获取与释放，基于Raft协议保证数据一致性，支持TTL与watch机制。同样，业务需要单独部署集群，客户端直连etcd的方式不太友好，需要封装客户端或代理层，单Raft group同步数据，服务端总并发能力略低。</p>
<h3 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h3><p>通过数据库写操作的原子特性（unique key）或数据库排他锁实现，实现简单。但不支持TTL机制，如果释放锁sql语句执行失败，有可能产生死锁，性能也比较低。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-15T02:31:57.000Z" title="2021/6/15 上午10:31:57">2021-06-15</time>发表</span><span class="level-item"><time dateTime="2021-06-15T02:31:57.000Z" title="2021/6/15 上午10:31:57">2021-06-15</time>更新</span><span class="level-item">5 分钟读完 (大约703个字)</span></div></div><div class="content"><h1 id="2-8-2-面试官：为什么redis不能保证100-数据不丢失"><a href="#2-8-2-面试官：为什么redis不能保证100-数据不丢失" class="headerlink" title="2.8.2 面试官：为什么redis不能保证100%数据不丢失"></a>2.8.2 面试官：为什么redis不能保证100%数据不丢失</h1><p><code>Redis</code> 在以下 2 个场景下，都会导致数据丢失。<br><code>AOF</code> 持久化配置为每秒写盘，但这个写盘过程是异步的，<code>Redis</code> 宕机时会存在数据丢失的可能<br>主从复制也是异步的，主从切换时，也存在丢失数据的可能（从库还未同步完成主库发来的数据，就被提成主库）<br>基于以上原因我们可以看到，<code>Redis</code> 本身的无法保证严格的数据完整性。<br>所以，如果把 <code>Redis</code> 当做消息队列，在这方面是有可能导致数据丢失的。</p>
<p>再来看那些专业的消息队列中间件是如何解决这个问题的？<br>像 <code>RabbitMQ</code> 或 <code>Kafka</code> 这类专业的队列中间件，在使用时，一般是部署一个集群，生产者在发布消息时，队列中间件通常会写<code>多个节点</code>，以此保证消息的完整性。这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。<br>也正因为如此，<code>RabbitMQ、Kafka</code>在设计时也更复杂。毕竟，它们是专门针对队列场景设计的。<br>但 <code>Redis</code> 的定位则不同，它的定位更多是当作缓存来用，它们两者在这个方面肯定是存在差异的。</p>
<h3 id="1-4-4-消息积压怎么办"><a href="#1-4-4-消息积压怎么办" class="headerlink" title="1.4.4 消息积压怎么办"></a>1.4.4 消息积压怎么办</h3><p>因为 <code>Redis</code> 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 <code>Redis</code> 的内存持续增长，如果超过机器内存上限，就会面临被 <code>OOM</code> 的风险。<br>所以，<code>Redis</code> 的 <code>Stream</code> 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。<br>但 <code>Kafka、RabbitMQ</code> 这类消息队列就不一样了，它们的数据都会存储在磁盘上，磁盘的成本要比内存小得多，当消息积压时，无非就是多占用一些磁盘空间，相比于内存，在面对积压时也会更加坦然</p>
<p>综上，我们可以看到，把 <code>Redis</code> 当作队列来使用时，始终面临的 2 个问题：</p>
<ul>
<li><code>Redis</code> 本身可能会丢数据</li>
<li>面对消息积压，<code>Redis</code> 内存资源紧张</li>
</ul>
<p>到这里，<code>Redis</code> 是否可以用作队列，我想这个答案你应该会比较清晰了。<br>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-13T02:07:03.000Z" title="2021/6/13 上午10:07:03">2021-06-13</time>发表</span><span class="level-item"><time dateTime="2021-06-13T02:07:03.000Z" title="2021/6/13 上午10:07:03">2021-06-13</time>更新</span><span class="level-item">7 分钟读完 (大约1042个字)</span></div></div><div class="content"><p>[toc]</p>
<h2 id="Mybatis-接口-Mapper-内的方法为啥不能重载吗？"><a href="#Mybatis-接口-Mapper-内的方法为啥不能重载吗？" class="headerlink" title="Mybatis 接口 Mapper 内的方法为啥不能重载吗？"></a>Mybatis 接口 Mapper 内的方法为啥不能重载吗？</h2><p><strong>动态代理的功能：通过拦截器方法回调，对目标target方法进行增强。</strong></p>
<p>言外之意就是为了增强目标target方法。上面这句话没错，但也不要认为它就是真理，殊不知，动态代理还有<strong>投鞭断流</strong>的霸权，连目标target都不要的科幻模式。</p>
<p>注：本文默认认为，读者对动态代理的原理是理解的，如果不明白target的含义，难以看懂本篇文章，建议先理解动态代理。</p>
<h3 id="1-自定义JDK动态代理之投鞭断流实现自动映射器Mapper"><a href="#1-自定义JDK动态代理之投鞭断流实现自动映射器Mapper" class="headerlink" title="1. 自定义JDK动态代理之投鞭断流实现自动映射器Mapper"></a>1. 自定义JDK动态代理之投鞭断流实现自动映射器Mapper</h3><p>首先定义一个pojo。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> Integer id;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Integer id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个接口UserMapper.java。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Integer id)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看看如何使用动态代理之<strong>投鞭断流</strong>，实现实例化接口并调用接口方法返回数据的。</p>
<p>自定义一个InvocationHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">newInstance</span><span class="params">(Class&lt;T&gt; clz)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(clz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; clz &#125;, <span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 诸如hashCode()、toString()、equals()等方法，将target指向当前对象this</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 投鞭断流</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>((Integer) args[<span class="number">0</span>], <span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的target，在执行Object.java内的方法时，target被指向了this，target已经变成了傀儡、象征、占位符。在<strong>投鞭断流</strong>式的拦截时，已经没有了target。</p>
<p>写一个测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">MapperProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperProxy</span>();</span><br><span class="line"></span><br><span class="line"> <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> proxy.newInstance(UserMapper.class);</span><br><span class="line"> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.getUserById(<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line"> System.out.println(<span class="string">&quot;ID:&quot;</span> + user.getId());</span><br><span class="line"> System.out.println(<span class="string">&quot;Name:&quot;</span> + user.getName());</span><br><span class="line"> System.out.println(<span class="string">&quot;Age:&quot;</span> + user.getAge());</span><br><span class="line"></span><br><span class="line"> System.out.println(mapper.toString());</span><br><span class="line">&#125;</span><br><span class="line">============================</span><br><span class="line">ID:<span class="number">1001</span></span><br><span class="line">Name:zhangsan</span><br><span class="line">Age:<span class="number">18</span></span><br><span class="line">x.y.MapperProxy@6bc7c054</span><br></pre></td></tr></table></figure>

<p>这便是Mybatis自动映射器Mapper的底层实现原理。</p>
<p>可能有读者不禁要问：你怎么把代码写的像初学者写的一样？没有结构，且缺乏美感。</p>
<p>必须声明，作为一名经验老道的高手，能把程序写的像初学者写的一样，那必定是高手中的高手。这样可以让初学者感觉到亲切，舒服，符合自己的Style，让他们或她们，感觉到大牛写的代码也不过如此，自己甚至写的比这些大牛写的还要好，从此自信满满，热情高涨，认为与大牛之间的差距，仅剩下三分钟。</p>
<h3 id="2-Mybatis自动映射器Mapper的源码分析"><a href="#2-Mybatis自动映射器Mapper的源码分析" class="headerlink" title="2. Mybatis自动映射器Mapper的源码分析"></a>2. Mybatis自动映射器Mapper的源码分析</h3><p>首先编写一个测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MybatisSqlSessionFactory.openSession();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">StudentMapper</span> <span class="variable">studentMapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">   List&lt;Student&gt; students = studentMapper.findAllStudents();</span><br><span class="line">   <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">    System.out.println(student);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   sqlSession.close();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Mapper长这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line"> List&lt;Student&gt; <span class="title function_">findAllStudents</span><span class="params">()</span>;</span><br><span class="line"> Student <span class="title function_">findStudentById</span><span class="params">(Integer id)</span>;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">insertStudent</span><span class="params">(Student student)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.apache.ibatis.binding.MapperProxy.java部分源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="built_in">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable 	&#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 投鞭断流</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line"> 	&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>org.apache.ibatis.binding.MapperProxyFactory.java部分源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxyFactory</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), </span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这便是Mybatis使用动态代理之<strong>投鞭断流</strong></p>
<h3 id="3-接口Mapper内的方法能重载（overLoad）吗？（重要"><a href="#3-接口Mapper内的方法能重载（overLoad）吗？（重要" class="headerlink" title="3. 接口Mapper内的方法能重载（overLoad）吗？（重要"></a>3. 接口Mapper内的方法能重载（overLoad）吗？（重要</h3><p>类似下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Integer id)</span>;</span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Integer id, String name)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Answer：不能。</strong></p>
<p>原因：在<strong>投鞭断流</strong>时，Mybatis使用package+Mapper+method全限名作为key，去xml内寻找唯一sql来执行的。类似：key&#x3D;x.y.UserMapper.getUserById，那么，重载方法时将导致矛盾。对于Mapper接口，Mybatis禁止方法重载（overLoad）。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-09T06:14:46.000Z" title="2021/6/9 下午2:14:46">2021-06-09</time>发表</span><span class="level-item"><time dateTime="2021-06-09T06:14:46.000Z" title="2021/6/9 下午2:14:46">2021-06-09</time>更新</span><span class="level-item">7 分钟读完 (大约1085个字)</span></div></div><div class="content"><h1 id="2-6-4HyperLogLog"><a href="#2-6-4HyperLogLog" class="headerlink" title="2.6.4HyperLogLog"></a>2.6.4HyperLogLog</h1><p>​	在开始这一节之前，我们先思考一个常见的业务问题：如果你负责开发维护一个大型的网站，有一天老板找产品经理要网站每个网页每天的 UV 数据，然后让你来开发这个统计模块，你会如何实现？</p>
<p>​	如果统计 PV 那非常好办，给每个网页一个独立的 Redis 计数器就可以了，这个计数器的 key 后缀加上当天的日期。这样来一个请求，incrby 一次，最终就可以统计出所有的 PV 数据。</p>
<p>​	但是 UV 不一样，它要去重，同一个用户一天之内的多次访问请求只能计数一次。这就要求每一个网页请求都需要带上用户的 ID，无论是登陆用户还是未登陆用户都需要一个唯一ID 来标识。</p>
<p>​	你也许已经想到了一个简单的方案，那就是为每一个页面一个独立的 set 集合来存储所有当天访问过此页面的用户 ID。当一个请求过来时，我们使用 sadd 将用户 ID 塞进去就可以了。通过 scard 可以取出这个集合的大小，这个数字就是这个页面的 UV 数据。没错，这是一个非常简单的方案。</p>
<p>​	但是，如果你的页面访问量非常大，比如一个爆款页面几千万的 UV，你需要一个很大的 set 集合来统计，这就非常浪费空间。如果这样的页面很多，那所需要的存储空间是惊人的。为这样一个去重功能就耗费这样多的存储空间，值得么？其实老板需要的数据又不需要太精确，105w 和 106w 这两个数字对于老板们来说并没有多大区别，So，有没有更好的解决方案呢？</p>
<p>​	这就是本节要引入的一个解决方案，Redis 提供了 HyperLogLog 数据结构就是用来解决这种统计问题的。HyperLogLog 提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，标准误差是 0.81%，这样的精确度已经可以满足上面的 UV 统计需求了。</p>
<p>​	HyperLogLog 数据结构是 Redis 的高级数据结构，它非常有用，但是令人感到意外的是，使用过它的人非常少。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>HyperLogLog 提供了两个指令 pfadd 和 pfcount，根据字面意义很好理解，一个是增加计数，一个是获取计数。pfadd 用法和 set 集合的 sadd 是一样的，来一个用户 ID，就将用户 ID 塞进去就是。pfcount 和 scard 用法是一样的，直接获取计数值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd codehole user1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user6</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user7 user8 user9 user10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PfTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			jedis.pfadd(<span class="string">&quot;codehole&quot;</span>, <span class="string">&quot;user&quot;</span> + i);</span><br><span class="line">      <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> jedis.pfcount(<span class="string">&quot;codehole&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (total != i + <span class="number">1</span>) &#123;</span><br><span class="line">				System.out.printf(<span class="string">&quot;%d %d\n&quot;</span>, total, i + <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; </span><br><span class="line">    &#125;</span><br><span class="line">		jedis.close();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>们将数据增加到 10w 差了 277 个，按百分比是 0.277%，对于上面的 UV 统计需求来说，误差率也不算高。然后我们把上面的脚本再跑一边，也就相当于将数据重复加入一边，查看输出，可以发现，pfcount 的结果没有任何改变，还是 99723，说明它确实具备去重功能。</p>
<h3 id="pfmerge适合什么场合用？"><a href="#pfmerge适合什么场合用？" class="headerlink" title="pfmerge适合什么场合用？"></a>pfmerge适合什么场合用？</h3><p>HyperLogLog 除了上面的 pfadd 和 pfcount 之外，还提供了第三个指令 pfmerge，用于将多个 pf 计数值累加在一起形成一个新的 pf 值。比如在网站中我们有两个内容差不多的页面，运营说需要这两个页面的数据进行合并。其中页面的 UV 访问量也需要合并，那这个时候 pfmerge 就可以派上用场了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-09T06:07:37.000Z" title="2021/6/9 下午2:07:37">2021-06-09</time>发表</span><span class="level-item"><time dateTime="2021-06-09T06:07:37.000Z" title="2021/6/9 下午2:07:37">2021-06-09</time>更新</span><span class="level-item">10 分钟读完 (大约1453个字)</span></div></div><div class="content"><h1 id="2-6-3位图"><a href="#2-6-3位图" class="headerlink" title="2.6.3位图"></a>2.6.3位图</h1><p><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">基本使用</a><br><a href="#%E7%BB%9F%E8%AE%A1%E5%92%8C%E6%9F%A5%E6%89%BE">统计和查找</a><br><a href="#%E9%AD%94%E6%9C%AF%E6%8C%87%E4%BB%A4bitfield">魔术指令bitfield</a></p>
<p>​	在我们平时开发过程中，会有一些 bool 型数据需要存取，比如用户一年的签到记录，签了是 1，没签是 0，要记录 365 天。如果使用普通的 key&#x2F;value，每个用户要记录 365 个，当用户上亿的时候，需要的存储空间是惊人的。</p>
<p>​	为了解决这个问题，Redis 提供了位图数据结构，这样每天的签到记录只占据一个位，365 天就是 365 个位，46 个字节 (一个稍长一点的字符串) 就可以完全容纳下，这就大大节约了存储空间。</p>
<p>​	位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组。我们可以使用普通的 get&#x2F;set 直接获取和设置整个位图的内容，也可以使用位图操作 <code>getbit</code>&#x2F;<code>setbit</code> 等将 byte 数组看成「位数组」来处理。</p>
<p>​	以老钱的经验，在面试中有 Redis 位图使用经验的同学很少，如果你对 Redis 的位图有所了解，它将会是你的面试加分项。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。</p>
<p>接下来我们使用位操作将字符串设置为 hello (不是直接使用 set 指令)，首先我们需要得到 hello 的 ASCII 码，用 Python 命令行可以很方便地得到每个字符的 ASCII 码的二进制值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;h&#x27;</span>)) </span><br><span class="line"><span class="string">&#x27;0b1101000&#x27;</span> <span class="comment"># 高位 -&gt; 低位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;e&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0b1100101&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;l&#x27;</span>)) </span><br><span class="line"><span class="string">&#x27;0b1101100&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;l&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0b1101100&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;o&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0b1101111&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../../images/WX20210608-190816@2x.png" alt="WX20210608-190816@2x"></p>
<p>接下来我们使用 <code>redis-cli</code> 设置第一个字符，也就是位数组的前 8 位，我们只需要设置值为 1 的位，如上图所示，h 字符只有 1&#x2F;2&#x2F;4 位需要设置，e 字符只有 9&#x2F;10&#x2F;13&#x2F;15 位需要设置。值得注意的是位数组的顺序和字符的位顺序是相反的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">2</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">4</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">9</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">10</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">13</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">15</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get s </span><br><span class="line"><span class="string">&quot;he&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子可以理解为「零存整取」，同样我们还也可以「零存零取」，「整存零取」。「零存」就是使用 setbit 对位值进行逐个设置，「整存」就是使用字符串一次性填充所有位数组，覆盖掉旧值。</p>
<p><strong>零存零取</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit w <span class="number">1</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit w <span class="number">2</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit w <span class="number">4</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">1</span> <span class="comment"># 获取某个具体位置的值 0/1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">2</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">4</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">5</span></span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果对应位的字节是不可打印字符，redis-cli 会显示该字符的 16 进制形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit x <span class="number">0</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit x <span class="number">1</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get x</span><br><span class="line"><span class="string">&quot;\xc0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="统计和查找"><a href="#统计和查找" class="headerlink" title="统计和查找"></a>统计和查找</h3><p>​	Redis 提供了位图统计指令 bitcount 和位图查找指令 bitpos，bitcount 用来统计指定位置范围内 1 的个数，bitpos 用来查找指定范围内出现的第一个 0 或 1。</p>
<p>​	比如我们可以通过 bitcount 统计用户一共签到了多少天，通过 bitpos 指令查找用户从哪一天开始第一次签到。如果指定了范围参数[start, end]，就可以统计在某个时间范围内用户签到了多少天，用户自某天以后的哪天开始签到。</p>
<p>​	遗憾的是， start 和 end 参数是字节索引，也就是说指定的位范围必须是 8 的倍数，而不能任意指定。这很奇怪，我表示不是很能理解 Antirez 为什么要这样设计。因为这个设计，我们无法直接计算某个月内用户签到了多少天，而必须要将这个月所覆盖的字节内容全部取出来 (getrange 可以取出字符串的子串) 然后在内存里进行统计，这个非常繁琐。</p>
<p>接下来我们简单试用一下 bitcount 指令和 bitpos 指令:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitcount w</span><br><span class="line">(integer) <span class="number">21</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitcount w <span class="number">0</span> <span class="number">0</span> <span class="comment"># 第一个字符中 1 的位数</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitcount w <span class="number">0</span> <span class="number">1</span> <span class="comment"># 前两个字符中 1 的位数</span></span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">0</span> <span class="comment"># 第一个 0 位</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">1</span> <span class="comment"># 第一个 1 位</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="comment"># 从第二个字符算起，第一个 1 位</span></span><br><span class="line">(integer) <span class="number">9</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="comment"># 从第三个字符算起，第一个 1 位</span></span><br><span class="line">(integer) <span class="number">17</span></span><br></pre></td></tr></table></figure>

<h3 id="魔术指令bitfield"><a href="#魔术指令bitfield" class="headerlink" title="魔术指令bitfield"></a>魔术指令bitfield</h3><p>前文我们设置 (<code>setbit</code>) 和获取 (<code>getbit</code>) 指定位的值都是单个位的，如果要一次操作多个位，就必须使用管道来处理。 不过 Redis 的 3.2 版本以后新增了一个功能强大的指令，有了这条指令，不用管道也可以一次进行多个位的操作。 bitfield 有三个子指令，分别是get&#x2F;set&#x2F;incrby，它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个子指令。</p>
<p><img src="/../../images/WX20210608-190816@2x-3150521.png" alt="WX20210608-190816@2x-3150521"></p>
<p>接下来我们对照着上面的图看个简单的例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get u4 0 <span class="comment"># 从第一个位开始取 4 个位，结果是无符号数 (u)</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get u3 2 <span class="comment"># 从第三个位开始取 3 个位，结果是无符号数 (u)</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get i4 0 <span class="comment"># 从第一个位开始取 4 个位，结果是有符号数 (i)</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get i3 2 <span class="comment"># 从第三个位开始取 3 个位，结果是有符号数 (i)</span></span><br><span class="line">(<span class="built_in">integer</span>) -3</span><br></pre></td></tr></table></figure>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-08T10:50:59.000Z" title="2021/6/8 下午6:50:59">2021-06-08</time>发表</span><span class="level-item"><time dateTime="2021-06-08T10:50:59.000Z" title="2021/6/8 下午6:50:59">2021-06-08</time>更新</span><span class="level-item">16 分钟读完 (大约2445个字)</span></div></div><div class="content"><h1 id="2-6-2延时队列"><a href="#2-6-2延时队列" class="headerlink" title="2.6.2延时队列"></a>2.6.2延时队列</h1><p><a href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">异步消息队列</a><br><a href="#%E9%98%9F%E5%88%97%E7%A9%BA%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F">队列空了怎么办？</a><br><a href="#%E9%98%9F%E5%88%97%E5%BB%B6%E8%BF%9F">队列延迟</a><br><a href="#%E7%A9%BA%E9%97%B2%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%8A%A8%E6%96%AD%E5%BC%80">空闲连接自动断开</a><br><a href="#%E9%94%81%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86">锁冲突处理</a><br><a href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">延时队列的实现</a></p>
<p>​	我们平时习惯于使用 Rabbitmq 和 Kafka 作为消息队列中间件，来给应用程序之间增加异步消息传递功能。这两个中间件都是专业的消息队列中间件，特性之多超出了大多数人的理解能力。</p>
<p>​	使用过 Rabbitmq 的同学知道它使用起来有多复杂，发消息之前要创建 Exchange，再创建 Queue，还要将 Queue 和 Exchange 通过某种规则绑定起来，发消息的时候要指定 routing-key，还要控制头部信息。消费者在消费消息之前也要进行上面一系列的繁琐过程。但是绝大多数情况下，虽然我们的消息队列只有一组消费者，但还是需要经历上面这些繁琐的过程。</p>
<p>​	有了 Redis，它就可以让我们解脱出来，对于那些只有一组消费者的消息队列，使用 Redis 就可以非常轻松的搞定。Redis 的消息队列不是专业的消息队列，它没有非常多的高级特性，没有 ack 保证，如果对消息的可靠性有着极致的追求，那么它就不适合使用。</p>
<h3 id="异步消息队列"><a href="#异步消息队列" class="headerlink" title="异步消息队列"></a>异步消息队列</h3><p>Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用<code>rpush</code>&#x2F;<code>lpush</code>操作入队列，使用 <code>lpop</code> 和 <code>rpop</code> 来出队列。</p>
<p><img src="/../../images/WX20210608-162235@2x.png" alt="WX20210608-162235@2x"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush notify-queue apple banana pear </span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line"><span class="string">&quot;apple&quot;</span></span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line"><span class="string">&quot;banana&quot;</span></span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 1 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line"><span class="string">&quot;pear&quot;</span></span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 0 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h3 id="队列空了怎么办？"><a href="#队列空了怎么办？" class="headerlink" title="队列空了怎么办？"></a>队列空了怎么办？</h3><p>​	客户端是通过队列的 pop 操作来获取消息，然后进行处理。处理完了再接着获取消息，再进行处理。如此循环往复，这便是作为队列消费者的客户端的生命周期。</p>
<p>​	可是如果队列空了，客户端就会陷入 pop 的死循环，不停地 pop，没有数据，接着再 pop，又没有数据。这就是浪费生命的空轮询。空轮询不但拉高了客户端的 CPU，redis 的 QPS 也会被拉高，如果这样空轮询的客户端有几十来个，Redis 的慢查询可能会显著增多。</p>
<p>​	通常我们使用 sleep 来解决这个问题，让线程睡一会，睡个 1s 钟就可以了。不但客户端的 CPU 能降下来，Redis 的 QPS 也降下来了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>) # java 睡 1s</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/WX20210608-162458@2x.png" alt="WX20210608-162458@2x"></p>
<h3 id="队列延迟"><a href="#队列延迟" class="headerlink" title="队列延迟"></a>队列延迟</h3><p>用上面睡眠的办法可以解决问题。但是有个小问题，那就是睡眠会导致消息的延迟增大。如果只有 1 个消费者，那么这个延迟就是 1s。如果有多个消费者，这个延迟会有所下降，因为每个消费者的睡觉时间是岔开来的。</p>
<p>​	有没有什么办法能显著降低延迟呢？你当然可以很快想到：那就把睡觉的时间缩短点。这种方式当然可以，不过有没有更好的解决方案呢？当然也有，那就是 <code>blpop</code>&#x2F;<code>brpop</code>。</p>
<p>​	这两个指令的前缀字符 b 代表的是 <code>blocking</code>，也就是阻塞读。</p>
<p>​	阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。用 blpop&#x2F;brpop 替代前面的 lpop&#x2F;rpop，就完美解决了上面的问题。…</p>
<h3 id="空闲连接自动断开"><a href="#空闲连接自动断开" class="headerlink" title="空闲连接自动断开"></a>空闲连接自动断开</h3><p>​	你以为上面的方案真的很完美么？先别急着开心，其实他还有个问题需要解决。</p>
<p>​	什么问题？—— <strong>空闲连接</strong>的问题。</p>
<p>​	如果线程一直阻塞在哪里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用。这个时候 <code>blpop</code>&#x2F;<code>brpop</code> 会抛出异常来。</p>
<p>​	所以编写客户端消费者的时候要小心，注意捕获异常，还要重试。…</p>
<h3 id="锁冲突处理"><a href="#锁冲突处理" class="headerlink" title="锁冲突处理"></a>锁冲突处理</h3><p>​	上节课我们讲了分布式锁的问题，但是没有提到客户端在处理请求时加锁没加成功怎么办。一般有 3 种策略来处理加锁失败： </p>
<p>​	1、直接抛出异常，通知用户稍后重试；<br>​	2、sleep 一会再重试；<br>​	3、将请求转移至延时队列，过一会再试；</p>
<p><strong>直接抛出特定类型的异常</strong></p>
<p>这种方式比较适合由用户直接发起的请求，用户看到错误对话框后，会先阅读对话框的内容，再点击重试，这样就可以起到人工延时的效果。如果考虑到用户体验，可以由前端的代码替代用户自己来进行延时重试控制。它本质上是对当前请求的放弃，由用户决定是否重新发起新的请求。</p>
<p><strong>sleep</strong></p>
<p>sleep 会阻塞当前的消息处理线程，会导致队列的后续消息处理出现延迟。如果碰撞的比较频繁或者队列里消息比较多，sleep 可能并不合适。如果因为个别死锁的 key 导致加锁不成功，线程会彻底堵死，导致后续消息永远得不到及时处理。</p>
<p><strong>延时队列</strong></p>
<p>这种方式比较适合异步消息处理，将当前冲突的请求扔到另一个队列延后处理以避开冲突。</p>
<h3 id="延时队列的实现"><a href="#延时队列的实现" class="headerlink" title="延时队列的实现"></a>延时队列的实现</h3><p>延时队列可以通过 Redis 的 zset(有序列表) 来实现。我们将消息序列化成一个字符串作为 zset 的 value，这个消息的到期处理时间作为 score，然后用多个线程轮询 zset 获取到期的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delay</span>(<span class="params">msg</span>): </span><br><span class="line">	msg.<span class="built_in">id</span> = <span class="built_in">str</span>(uuid.uuid4()) <span class="comment"># 保证 value 值唯一</span></span><br><span class="line">	value = json.dumps(msg) </span><br><span class="line">	retry_ts = time.time() + <span class="number">5</span> <span class="comment"># 5 秒后重试</span></span><br><span class="line">	redis.zadd(<span class="string">&quot;delay-queue&quot;</span>, retry_ts, value) </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>(): </span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">		<span class="comment"># 最多取 1 条</span></span><br><span class="line">  	values = redis.zrangebyscore(<span class="string">&quot;delay-queue&quot;</span>, <span class="number">0</span>, time.time(), start=<span class="number">0</span>, num=<span class="number">1</span>) </span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> values: </span><br><span class="line">      time.sleep(<span class="number">1</span>) <span class="comment"># 延时队列空的，休息 1s</span></span><br><span class="line">			<span class="keyword">continue</span> </span><br><span class="line">		value = values[<span class="number">0</span>] <span class="comment"># 拿第一条，也只有一条</span></span><br><span class="line">		success = redis.zrem(<span class="string">&quot;delay-queue&quot;</span>, value) <span class="comment"># 从消息队列中移除该消息</span></span><br><span class="line">		<span class="keyword">if</span> success: <span class="comment"># 因为有多进程并发的可能，最终只会有一个进程可以抢到消息</span></span><br><span class="line">			msg = json.loads(value) </span><br><span class="line">			handle_msg(msg)</span><br></pre></td></tr></table></figure>

<p>​	Redis 的 zrem 方法是多线程多进程争抢任务的关键，它的返回值决定了当前实例有没有抢到任务，因为 <code>loop</code> 方法可能会被多个线程、多个进程调用，同一个任务可能会被多个进程线程抢到，通过 <code>zrem</code>来决定唯一的属主。</p>
<p>​	同时，我们要注意一定要对 handle_msg 进行异常捕获，避免因为个别任务处理问题导致循环异常退出。以下是 Java 版本的延时队列实现，因为要使用到 Json 序列化，所以还需要 <code>fastjson</code> 库的支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.TypeReference;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDelayingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TaskItem</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> String id;</span><br><span class="line">        <span class="keyword">public</span> T msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fastjson 序列化对象中存在 generic 类型时，需要使用 TypeReference</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Type</span> <span class="variable">TaskType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;TaskItem&lt;T&gt;&gt;() &#123;</span><br><span class="line">    &#125;.getType();</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisDelayingQueue</span><span class="params">(Jedis jedis, String queueKey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">        <span class="built_in">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delay</span><span class="params">(T msg)</span> &#123;</span><br><span class="line">        <span class="type">TaskItem</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskItem</span>();</span><br><span class="line">        task.id = UUID.randomUUID().toString(); <span class="comment">// 分配唯一的 uuid</span></span><br><span class="line">        task.msg = msg;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(task); <span class="comment">// fastjson 序列化</span></span><br><span class="line">        jedis.zadd(queueKey, System.currentTimeMillis() + <span class="number">5000</span>, s); <span class="comment">// 塞入延时队列 ,5s 后再试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line"><span class="comment">// 只取一条</span></span><br><span class="line">            <span class="type">Set</span> <span class="variable">values</span> <span class="operator">=</span> jedis.zrangeByScore(queueKey, <span class="number">0</span>, System.currentTimeMillis(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (values.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>); <span class="comment">// 歇会继续</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> values.iterator().next();</span><br><span class="line">            <span class="keyword">if</span> (jedis.zrem(queueKey, s) &gt; <span class="number">0</span>) &#123; <span class="comment">// 抢到了</span></span><br><span class="line">                <span class="type">TaskItem</span> <span class="variable">task</span> <span class="operator">=</span> JSON.parseObject(s, TaskType); <span class="comment">// fastjson 反序列化</span></span><br><span class="line">                <span class="built_in">this</span>.handleMsg(task.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMsg</span><span class="params">(T msg)</span> &#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();</span><br><span class="line">        <span class="type">RedisDelayingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisDelayingQueue</span>&lt;&gt;(jedis, <span class="string">&quot;q-demo&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    queue.delay(<span class="string">&quot;codehole&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                queue.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.join();</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            consumer.interrupt();</span><br><span class="line">            consumer.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>进一步优化</strong></p>
<p>上面的算法中同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到的进程都是白取了一次任务，这是浪费。可以考虑使用 lua scripting 来优化一下这个逻辑，将zrangebyscore 和 zrem 一同挪到服务器端进行原子化操作，这样多个进程之间争抢任务时就不会出现这种浪费了。</p>
<p><strong>思考</strong></p>
<p>1、Redis 作为消息队列为什么不能保证 100% 的可靠性？ </p>
<p>2、使用 Lua Scripting 来优化延时队列的逻辑。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-08T08:14:33.000Z" title="2021/6/8 下午4:14:33">2021-06-08</time>发表</span><span class="level-item"><time dateTime="2021-06-08T08:14:33.000Z" title="2021/6/8 下午4:14:33">2021-06-08</time>更新</span><span class="level-item">13 分钟读完 (大约1919个字)</span></div></div><div class="content"><h1 id="2-6-1-分布式锁"><a href="#2-6-1-分布式锁" class="headerlink" title="2.6.1.分布式锁"></a>2.6.1.分布式锁</h1><p><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a><br><a href="#%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98">超时问题</a><br><a href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7">可重入性</a></p>
<p>分布式应用进行逻辑处理时经常会遇到并发问题。</p>
<p>比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。（Wiki 解释：所谓<strong>原子操作</strong>是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch 线程切换。）</p>
<p><img src="/../../images/WX20210608-102304@2x.png" alt="WX20210608-102304@2x"></p>
<p>这个时候就要使用到分布式锁来限制程序的并发执行。Redis 分布式锁使用非常广泛，它是面试的重要考点之一，很多同学都知道这个知识，也大致知道分布式锁的原理，但是具体到细节的使用上往往并不完全正确。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这里的冒号:就是一个普通的字符，没特别含义，它可以是任意其它字符，不要误解</span><br><span class="line">&gt; setnx lock:codehole <span class="literal">true</span></span><br><span class="line">OK</span><br><span class="line">... <span class="keyword">do</span> something critical ...</span><br><span class="line">&gt; del lock:codehole</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>​	但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p>
<p>​	于是我们在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:codehole <span class="literal">true</span></span><br><span class="line">OK</span><br><span class="line">&gt; expire lock:codehole 5</span><br><span class="line">... <span class="keyword">do</span> something critical ...</span><br><span class="line">&gt; del lock:codehole</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>​	但是以上逻辑还有问题。<strong>如果在 setnx 和 expire 之间服务器进程突然挂掉了</strong>，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p>
<p>​	这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。也许你会想到用 Redis 事务来解决。但是这里不行，因为 expire 是依赖于 setnx 的执行结果的，如果 setnx 没抢到锁，expire 是不应该执行的。事务里没有 if-else 分支逻辑，事务的特点是一口气执行，要么全部执行要么一个都不执行。</p>
<p>​	为了解决这个疑难，Redis 开源社区涌现了一堆分布式锁的 library，专门用来解决这个问题。实现方法极为复杂，小白用户一般要费很大的精力才可以搞懂。如果你需要使用分布式锁，意味着你不能仅仅使用 Jedis 或者 redis-py 就行了，还得引入分布式锁的 library。 </p>
<p><img src="/../../images/WX20210608-104119@2x.png" alt="WX20210608-104119@2x"></p>
<p>​	为了治理这个乱象，Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 <code>setnx</code> 和<code>expire</code> 指令可以一起执行，彻底解决了分布式锁的乱象。从此以后所有的第三方分布式锁library 可以休息了。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> lock:codehole <span class="literal">true</span> ex 5 nx </span><br><span class="line">OK ... <span class="keyword">do</span> something critical ... </span><br><span class="line">&gt; del lock:codehole</span><br></pre></td></tr></table></figure>

<p> 上面这个指令就是 setnx 和 expire 组合在一起的原子指令，它就是分布式锁的奥义所在。</p>
<h3 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h3><p>Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁，但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻辑执行完之间拿到了锁。</p>
<p>为了避免这个问题，Redis 分布式锁不要用于较长时间的任务。如果真的偶尔出现了，数据出现的小波错乱可能需要人工介入解决。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag = random.nextint() <span class="comment"># 随机数</span></span><br><span class="line"><span class="keyword">if</span> redis.set(key, tag, nx=True, ex=5):</span><br><span class="line">	do_something()</span><br><span class="line">redis.delifequals(key, tag) <span class="comment"># 不存在的 delifequals 指令</span></span><br></pre></td></tr></table></figure>

<p>有一个更加安全的方案是为 set 指令的 value 参数设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key。但是匹配 value 和删除 key 不是一个原子操作，Redis 也没有提供类似于 delifequals 这样的指令，这就需要使用 Lua 脚本来处理了，因为 Lua 脚本可以保证连续多个指令的原子性执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delifequals</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[1]) == ARGV[1] <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[1])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">return</span> 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>可重入性是指线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，那么这个锁就是可重入的。比如 Java 语言里有个 ReentrantLock 就是可重入锁。Redis 分布式锁如果要支持可重入，需要对客户端的 set 方法进行包装，使用线程的 Threadlocal 变量存储当前持有锁的计数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 </span></span><br><span class="line"><span class="keyword">import</span> redis </span><br><span class="line"><span class="keyword">import</span> threading </span><br><span class="line">locks = threading.local() </span><br><span class="line">locks.redis = &#123;&#125; </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">key_for</span>(<span class="params">user_id</span>): </span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;account_&#123;&#125;&quot;</span>.<span class="built_in">format</span>(user_id) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_lock</span>(<span class="params">client, key</span>): </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">bool</span>(client.<span class="built_in">set</span>(key, <span class="literal">True</span>, nx=<span class="literal">True</span>, ex=<span class="number">5</span>)) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_unlock</span>(<span class="params">client, key</span>): </span><br><span class="line">	client.delete(key) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lock</span>(<span class="params">client, user_id</span>): </span><br><span class="line">  key = key_for(user_id) </span><br><span class="line">	<span class="keyword">if</span> key <span class="keyword">in</span> locks.redis:</span><br><span class="line">		locks.redis[key] += <span class="number">1</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">	ok = _lock(client, key) </span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> ok: </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">	locks.redis[key] = <span class="number">1</span> </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unlock</span>(<span class="params">client, user_id</span>): </span><br><span class="line">	key = key_for(user_id) </span><br><span class="line">	<span class="keyword">if</span> key <span class="keyword">in</span> locks.redis: </span><br><span class="line">		locks.redis[key] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> locks.redis[key] &lt;= <span class="number">0</span>: </span><br><span class="line">			<span class="keyword">del</span> locks.redis[key] </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">client = redis.StrictRedis() </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;lock&quot;</span>, lock(client, <span class="string">&quot;codehole&quot;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;lock&quot;</span>, lock(client, <span class="string">&quot;codehole&quot;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;unlock&quot;</span>, unlock(client, <span class="string">&quot;codehole&quot;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;unlock&quot;</span>, unlock(client, <span class="string">&quot;codehole&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上还不是可重入锁的全部，精确一点还需要考虑内存锁计数的过期时间，代码复杂度将会继续升高。老钱不推荐使用可重入锁，它加重了客户端的复杂性，在编写业务方法时注意在逻辑结构上进行调整完全可以不使用可重入锁。下面是 Java 版本的可重入锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisWithReentrantLock</span> &#123; </span><br><span class="line">	<span class="keyword">private</span> ThreadLocal&lt;Map&gt; lockers = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(); </span><br><span class="line">	<span class="keyword">private</span> Jedis jedis; </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RedisWithReentrantLock</span><span class="params">(Jedis jedis)</span> &#123; </span><br><span class="line">		<span class="built_in">this</span>.jedis = jedis; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">_lock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> jedis.set(key, <span class="string">&quot;&quot;</span>, <span class="string">&quot;nx&quot;</span>, <span class="string">&quot;ex&quot;</span>, <span class="number">5L</span>) != <span class="literal">null</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">_unlock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		jedis.del(key); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">private</span> Map &lt;String, Integer&gt; currentLockers() &#123; </span><br><span class="line">		Map &lt;String, Integer&gt; refs = lockers.get(); </span><br><span class="line">		<span class="keyword">if</span> (refs != <span class="literal">null</span>) &#123; </span><br><span class="line">			<span class="keyword">return</span> refs; </span><br><span class="line">		&#125; </span><br><span class="line">		lockers.set(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()); </span><br><span class="line">		<span class="keyword">return</span> lockers.get(); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		<span class="type">Map</span> <span class="variable">refs</span> <span class="operator">=</span> currentLockers(); </span><br><span class="line">		<span class="type">Integer</span> <span class="variable">refCnt</span> <span class="operator">=</span> refs.get(key); </span><br><span class="line">		<span class="keyword">if</span> (refCnt != <span class="literal">null</span>) &#123; </span><br><span class="line">			refs.put(key, refCnt + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="built_in">this</span>._lock(key); </span><br><span class="line">		<span class="keyword">if</span> (!ok) &#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		refs.put(key, <span class="number">1</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	&#125; </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		<span class="type">Map</span> <span class="variable">refs</span> <span class="operator">=</span> currentLockers();</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">refCnt</span> <span class="operator">=</span> refs.get(key); </span><br><span class="line">		<span class="keyword">if</span> (refCnt == <span class="literal">null</span>) &#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		refCnt -= <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">if</span> (refCnt &gt; <span class="number">0</span>) &#123; </span><br><span class="line">			refs.put(key, refCnt); </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">			refs.remove(key);</span><br><span class="line">			<span class="built_in">this</span> ._unlock(key); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">		<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(); </span><br><span class="line">		<span class="type">RedisWithReentrantLock</span> <span class="variable">redis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisWithReentrantLock</span>(jedis); </span><br><span class="line">		System.out.println(redis.lock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">		System.out.println(redis.lock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">		System.out.println(redis.unlock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">		System.out.println(redis.unlock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/9/">上一页</a></div><div class="pagination-next"><a href="/page/11/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/9/">9</a></li><li><a class="pagination-link is-current" href="/page/10/">10</a></li><li><a class="pagination-link" href="/page/11/">11</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/15/">15</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Tonygeli"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tonygeli</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SH</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">150</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tonygeli" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux%E5%91%BD%E4%BB%A4/"><span class="level-start"><span class="level-item">Linux命令</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">时间管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6/"><span class="level-start"><span class="level-item">读书</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bean/"><span class="tag">Bean</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus/"><span class="tag">Icarus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySql/"><span class="tag">MySql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Netty/"><span class="tag">Netty</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stream/"><span class="tag">Stream</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"><span class="tag">公众号</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><span class="tag">内存分配</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><span class="tag">分布式事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><span class="tag">单点登录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"><span class="tag">自动装配</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%99%90%E6%B5%81/"><span class="tag">限流</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-12T06:50:12.571Z">2022-05-12</time></p><p class="title"><a href="/2022/05/12/12000%E9%9D%A2%E8%AF%95/12003ThreadLocal%E6%BA%90%E7%A0%81/">ThreadLocal源码介绍</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-11T16:16:28.365Z">2022-05-12</time></p><p class="title"><a href="/2022/05/12/12000%E9%9D%A2%E8%AF%95/12002%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">内存分配</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-11T16:02:44.782Z">2022-05-12</time></p><p class="title"><a href="/2022/05/12/12000%E9%9D%A2%E8%AF%95/12001%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/">常见限流算法</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-10T14:21:17.411Z">2022-05-10</time></p><p class="title"><a href="/2022/05/10/213Linux/13002Linux%E5%91%BD%E4%BB%A4find/">Linux命令find</a></p><p class="categories"><a href="/categories/Linux%E5%91%BD%E4%BB%A4/">Linux命令</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-10T06:58:05.176Z">2022-05-10</time></p><p class="title"><a href="/2022/05/10/3.%E8%AF%BB%E4%B9%A6/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%97%B6%E9%97%B4/">职场上如何管理时间</a></p><p class="categories"><a href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/">时间管理</a></p></div></article></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a><p class="is-size-7"><span>&copy; 2022 Tonygeli</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>