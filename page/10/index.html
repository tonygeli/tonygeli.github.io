<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>LILAIQUN</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LILAIQUN"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LILAIQUN"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="LILAIQUN"><meta property="og:url" content="https://tonygeli.github.io/"><meta property="og:site_name" content="LILAIQUN"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tonygeli.github.io/img/og_image.png"><meta property="article:author" content="Tonygeli"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonygeli.github.io"},"headline":"LILAIQUN","image":["https://tonygeli.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tonygeli"},"publisher":{"@type":"Organization","name":"LILAIQUN","logo":{"@type":"ImageObject","url":"https://tonygeli.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-16T09:01:31.000Z" title="2021/6/16 下午5:01:31">2021-06-16</time>发表</span><span class="level-item"><time dateTime="2021-06-16T09:01:31.000Z" title="2021/6/16 下午5:01:31">2021-06-16</time>更新</span><span class="level-item">7 分钟读完 (大约1016个字)</span></div></div><div class="content"><h2 id="常见分布式锁实现"><a href="#常见分布式锁实现" class="headerlink" title="常见分布式锁实现"></a>常见分布式锁实现</h2><p>有基于redis、基于数据库、基于zookeeper或etcd等几种实现方式，下面简单对比下这几种实现方式：</p>
<h3 id="基于redis实现"><a href="#基于redis实现" class="headerlink" title="基于redis实现"></a>基于redis实现</h3><p>对于业务来说，redis使用比较轻便，性能也比较高，通过调研，有90%的业务都是基于redis实现分布式锁。但业务线基本上都是采用单个redis节点实现分布式锁，当redis节点发生failover时，主从节点基于异步复制保证不了数据的强一致性，有可能多个客户端同时获取到锁。Redis的作者提出了一个更安全的实现，叫做Redlock，要求通过N个完全独立的Redis节点基于Quorum机制实现分布式锁，但是N个节点数据同步问题也比较复杂。</p>
<p>另外，大神 Martin Kleppmann，在文章《How to do distributed locking》中对分布式锁原理进行论证，指出Redlock解决不了持有锁的客户端GC pause问题，如下图所示。</p>
<p><img src="/../../images/redis_realize_1.png" alt="avatar"></p>
<p>客户端1在获得锁之后发生了很长时间的GC pause，在此期间，它获得的锁过期了，而客户端2获得了锁。当客户端1从GC pause中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源（上图中是一个存储服务）发起了写数据请求，而这时锁实际上被客户端2持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。除了GC pasue场景，时钟跳跃也会引发同样的问题，解决这个问题，Martin提出可以引入fencing token，即锁的版本号，在锁持有者放生变更时fencing token递增更新，客户端访问共享资源时携带着这个fencing token，这样提供共享资源的服务就能根据它进行检查，拒绝掉延迟到来的访问请求（避免了冲突），如下图所示。</p>
<p><img src="/../../images/redis_realize_2.png" alt="avatar"></p>
<p>Redis分布式锁引入fencing token机制，为了保证释放锁的安全性，即每个客户端只能释放自己持有的锁，必须使用lua脚本或者事务机制实现GET、比较、DEL这三步操作的原子性（类似于乐观锁机制），使用起来也不是特别方便。</p>
<p>总体来说，如果想要使用redis实现一套特别可靠的分布式锁服务，还是比较复杂的，对于吞吐量比较高并且有一定容错机制的服务，可以考虑直接采用单redis节点的分布式锁方案。</p>
<h3 id="基于Zookeeper实现"><a href="#基于Zookeeper实现" class="headerlink" title="基于Zookeeper实现"></a>基于Zookeeper实现</h3><p>基于Zookeeper临时有序节点实现分布式锁，通过ZAB协议保证数据一致性。具有Watch功能，可以高效实现阻塞锁。不过业务需要单独部署Zookeeper集群，每个lockkey需要关联一个客户端连接session，不够灵活，性能较差；</p>
<h3 id="基于ETCD实现"><a href="#基于ETCD实现" class="headerlink" title="基于ETCD实现"></a>基于ETCD实现</h3><p>采用etcd自带的kv存储，通过lockkey的状态值控制锁的获取与释放，基于Raft协议保证数据一致性，支持TTL与watch机制。同样，业务需要单独部署集群，客户端直连etcd的方式不太友好，需要封装客户端或代理层，单Raft group同步数据，服务端总并发能力略低。</p>
<h3 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h3><p>通过数据库写操作的原子特性（unique key）或数据库排他锁实现，实现简单。但不支持TTL机制，如果释放锁sql语句执行失败，有可能产生死锁，性能也比较低。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-15T02:31:57.000Z" title="2021/6/15 上午10:31:57">2021-06-15</time>发表</span><span class="level-item"><time dateTime="2021-06-15T02:31:57.000Z" title="2021/6/15 上午10:31:57">2021-06-15</time>更新</span><span class="level-item">5 分钟读完 (大约703个字)</span></div></div><div class="content"><h1 id="2-8-2-面试官：为什么redis不能保证100-数据不丢失"><a href="#2-8-2-面试官：为什么redis不能保证100-数据不丢失" class="headerlink" title="2.8.2 面试官：为什么redis不能保证100%数据不丢失"></a>2.8.2 面试官：为什么redis不能保证100%数据不丢失</h1><p><code>Redis</code> 在以下 2 个场景下，都会导致数据丢失。<br><code>AOF</code> 持久化配置为每秒写盘，但这个写盘过程是异步的，<code>Redis</code> 宕机时会存在数据丢失的可能<br>主从复制也是异步的，主从切换时，也存在丢失数据的可能（从库还未同步完成主库发来的数据，就被提成主库）<br>基于以上原因我们可以看到，<code>Redis</code> 本身的无法保证严格的数据完整性。<br>所以，如果把 <code>Redis</code> 当做消息队列，在这方面是有可能导致数据丢失的。</p>
<p>再来看那些专业的消息队列中间件是如何解决这个问题的？<br>像 <code>RabbitMQ</code> 或 <code>Kafka</code> 这类专业的队列中间件，在使用时，一般是部署一个集群，生产者在发布消息时，队列中间件通常会写<code>多个节点</code>，以此保证消息的完整性。这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。<br>也正因为如此，<code>RabbitMQ、Kafka</code>在设计时也更复杂。毕竟，它们是专门针对队列场景设计的。<br>但 <code>Redis</code> 的定位则不同，它的定位更多是当作缓存来用，它们两者在这个方面肯定是存在差异的。</p>
<h3 id="1-4-4-消息积压怎么办"><a href="#1-4-4-消息积压怎么办" class="headerlink" title="1.4.4 消息积压怎么办"></a>1.4.4 消息积压怎么办</h3><p>因为 <code>Redis</code> 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 <code>Redis</code> 的内存持续增长，如果超过机器内存上限，就会面临被 <code>OOM</code> 的风险。<br>所以，<code>Redis</code> 的 <code>Stream</code> 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。<br>但 <code>Kafka、RabbitMQ</code> 这类消息队列就不一样了，它们的数据都会存储在磁盘上，磁盘的成本要比内存小得多，当消息积压时，无非就是多占用一些磁盘空间，相比于内存，在面对积压时也会更加坦然</p>
<p>综上，我们可以看到，把 <code>Redis</code> 当作队列来使用时，始终面临的 2 个问题：</p>
<ul>
<li><code>Redis</code> 本身可能会丢数据</li>
<li>面对消息积压，<code>Redis</code> 内存资源紧张</li>
</ul>
<p>到这里，<code>Redis</code> 是否可以用作队列，我想这个答案你应该会比较清晰了。<br>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-13T02:07:03.000Z" title="2021/6/13 上午10:07:03">2021-06-13</time>发表</span><span class="level-item"><time dateTime="2021-06-13T02:07:03.000Z" title="2021/6/13 上午10:07:03">2021-06-13</time>更新</span><span class="level-item">7 分钟读完 (大约1042个字)</span></div></div><div class="content"><p>[toc]</p>
<h2 id="Mybatis-接口-Mapper-内的方法为啥不能重载吗？"><a href="#Mybatis-接口-Mapper-内的方法为啥不能重载吗？" class="headerlink" title="Mybatis 接口 Mapper 内的方法为啥不能重载吗？"></a>Mybatis 接口 Mapper 内的方法为啥不能重载吗？</h2><p><strong>动态代理的功能：通过拦截器方法回调，对目标target方法进行增强。</strong></p>
<p>言外之意就是为了增强目标target方法。上面这句话没错，但也不要认为它就是真理，殊不知，动态代理还有<strong>投鞭断流</strong>的霸权，连目标target都不要的科幻模式。</p>
<p>注：本文默认认为，读者对动态代理的原理是理解的，如果不明白target的含义，难以看懂本篇文章，建议先理解动态代理。</p>
<h3 id="1-自定义JDK动态代理之投鞭断流实现自动映射器Mapper"><a href="#1-自定义JDK动态代理之投鞭断流实现自动映射器Mapper" class="headerlink" title="1. 自定义JDK动态代理之投鞭断流实现自动映射器Mapper"></a>1. 自定义JDK动态代理之投鞭断流实现自动映射器Mapper</h3><p>首先定义一个pojo。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> Integer id;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Integer id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个接口UserMapper.java。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Integer id)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看看如何使用动态代理之<strong>投鞭断流</strong>，实现实例化接口并调用接口方法返回数据的。</p>
<p>自定义一个InvocationHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">newInstance</span><span class="params">(Class&lt;T&gt; clz)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(clz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; clz &#125;, <span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 诸如hashCode()、toString()、equals()等方法，将target指向当前对象this</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 投鞭断流</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>((Integer) args[<span class="number">0</span>], <span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的target，在执行Object.java内的方法时，target被指向了this，target已经变成了傀儡、象征、占位符。在<strong>投鞭断流</strong>式的拦截时，已经没有了target。</p>
<p>写一个测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">MapperProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperProxy</span>();</span><br><span class="line"></span><br><span class="line"> <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> proxy.newInstance(UserMapper.class);</span><br><span class="line"> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.getUserById(<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line"> System.out.println(<span class="string">&quot;ID:&quot;</span> + user.getId());</span><br><span class="line"> System.out.println(<span class="string">&quot;Name:&quot;</span> + user.getName());</span><br><span class="line"> System.out.println(<span class="string">&quot;Age:&quot;</span> + user.getAge());</span><br><span class="line"></span><br><span class="line"> System.out.println(mapper.toString());</span><br><span class="line">&#125;</span><br><span class="line">============================</span><br><span class="line">ID:<span class="number">1001</span></span><br><span class="line">Name:zhangsan</span><br><span class="line">Age:<span class="number">18</span></span><br><span class="line">x.y.MapperProxy@6bc7c054</span><br></pre></td></tr></table></figure>

<p>这便是Mybatis自动映射器Mapper的底层实现原理。</p>
<p>可能有读者不禁要问：你怎么把代码写的像初学者写的一样？没有结构，且缺乏美感。</p>
<p>必须声明，作为一名经验老道的高手，能把程序写的像初学者写的一样，那必定是高手中的高手。这样可以让初学者感觉到亲切，舒服，符合自己的Style，让他们或她们，感觉到大牛写的代码也不过如此，自己甚至写的比这些大牛写的还要好，从此自信满满，热情高涨，认为与大牛之间的差距，仅剩下三分钟。</p>
<h3 id="2-Mybatis自动映射器Mapper的源码分析"><a href="#2-Mybatis自动映射器Mapper的源码分析" class="headerlink" title="2. Mybatis自动映射器Mapper的源码分析"></a>2. Mybatis自动映射器Mapper的源码分析</h3><p>首先编写一个测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MybatisSqlSessionFactory.openSession();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">StudentMapper</span> <span class="variable">studentMapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">   List&lt;Student&gt; students = studentMapper.findAllStudents();</span><br><span class="line">   <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">    System.out.println(student);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   sqlSession.close();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Mapper长这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line"> List&lt;Student&gt; <span class="title function_">findAllStudents</span><span class="params">()</span>;</span><br><span class="line"> Student <span class="title function_">findStudentById</span><span class="params">(Integer id)</span>;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">insertStudent</span><span class="params">(Student student)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.apache.ibatis.binding.MapperProxy.java部分源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="built_in">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable 	&#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 投鞭断流</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line"> 	&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>org.apache.ibatis.binding.MapperProxyFactory.java部分源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxyFactory</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), </span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这便是Mybatis使用动态代理之<strong>投鞭断流</strong></p>
<h3 id="3-接口Mapper内的方法能重载（overLoad）吗？（重要"><a href="#3-接口Mapper内的方法能重载（overLoad）吗？（重要" class="headerlink" title="3. 接口Mapper内的方法能重载（overLoad）吗？（重要"></a>3. 接口Mapper内的方法能重载（overLoad）吗？（重要</h3><p>类似下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Integer id)</span>;</span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Integer id, String name)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Answer：不能。</strong></p>
<p>原因：在<strong>投鞭断流</strong>时，Mybatis使用package+Mapper+method全限名作为key，去xml内寻找唯一sql来执行的。类似：key&#x3D;x.y.UserMapper.getUserById，那么，重载方法时将导致矛盾。对于Mapper接口，Mybatis禁止方法重载（overLoad）。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-09T06:14:46.000Z" title="2021/6/9 下午2:14:46">2021-06-09</time>发表</span><span class="level-item"><time dateTime="2021-06-09T06:14:46.000Z" title="2021/6/9 下午2:14:46">2021-06-09</time>更新</span><span class="level-item">7 分钟读完 (大约1085个字)</span></div></div><div class="content"><h1 id="2-6-4HyperLogLog"><a href="#2-6-4HyperLogLog" class="headerlink" title="2.6.4HyperLogLog"></a>2.6.4HyperLogLog</h1><p>​	在开始这一节之前，我们先思考一个常见的业务问题：如果你负责开发维护一个大型的网站，有一天老板找产品经理要网站每个网页每天的 UV 数据，然后让你来开发这个统计模块，你会如何实现？</p>
<p>​	如果统计 PV 那非常好办，给每个网页一个独立的 Redis 计数器就可以了，这个计数器的 key 后缀加上当天的日期。这样来一个请求，incrby 一次，最终就可以统计出所有的 PV 数据。</p>
<p>​	但是 UV 不一样，它要去重，同一个用户一天之内的多次访问请求只能计数一次。这就要求每一个网页请求都需要带上用户的 ID，无论是登陆用户还是未登陆用户都需要一个唯一ID 来标识。</p>
<p>​	你也许已经想到了一个简单的方案，那就是为每一个页面一个独立的 set 集合来存储所有当天访问过此页面的用户 ID。当一个请求过来时，我们使用 sadd 将用户 ID 塞进去就可以了。通过 scard 可以取出这个集合的大小，这个数字就是这个页面的 UV 数据。没错，这是一个非常简单的方案。</p>
<p>​	但是，如果你的页面访问量非常大，比如一个爆款页面几千万的 UV，你需要一个很大的 set 集合来统计，这就非常浪费空间。如果这样的页面很多，那所需要的存储空间是惊人的。为这样一个去重功能就耗费这样多的存储空间，值得么？其实老板需要的数据又不需要太精确，105w 和 106w 这两个数字对于老板们来说并没有多大区别，So，有没有更好的解决方案呢？</p>
<p>​	这就是本节要引入的一个解决方案，Redis 提供了 HyperLogLog 数据结构就是用来解决这种统计问题的。HyperLogLog 提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，标准误差是 0.81%，这样的精确度已经可以满足上面的 UV 统计需求了。</p>
<p>​	HyperLogLog 数据结构是 Redis 的高级数据结构，它非常有用，但是令人感到意外的是，使用过它的人非常少。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>HyperLogLog 提供了两个指令 pfadd 和 pfcount，根据字面意义很好理解，一个是增加计数，一个是获取计数。pfadd 用法和 set 集合的 sadd 是一样的，来一个用户 ID，就将用户 ID 塞进去就是。pfcount 和 scard 用法是一样的，直接获取计数值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd codehole user1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user6</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user7 user8 user9 user10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PfTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			jedis.pfadd(<span class="string">&quot;codehole&quot;</span>, <span class="string">&quot;user&quot;</span> + i);</span><br><span class="line">      <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> jedis.pfcount(<span class="string">&quot;codehole&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (total != i + <span class="number">1</span>) &#123;</span><br><span class="line">				System.out.printf(<span class="string">&quot;%d %d\n&quot;</span>, total, i + <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; </span><br><span class="line">    &#125;</span><br><span class="line">		jedis.close();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>们将数据增加到 10w 差了 277 个，按百分比是 0.277%，对于上面的 UV 统计需求来说，误差率也不算高。然后我们把上面的脚本再跑一边，也就相当于将数据重复加入一边，查看输出，可以发现，pfcount 的结果没有任何改变，还是 99723，说明它确实具备去重功能。</p>
<h3 id="pfmerge适合什么场合用？"><a href="#pfmerge适合什么场合用？" class="headerlink" title="pfmerge适合什么场合用？"></a>pfmerge适合什么场合用？</h3><p>HyperLogLog 除了上面的 pfadd 和 pfcount 之外，还提供了第三个指令 pfmerge，用于将多个 pf 计数值累加在一起形成一个新的 pf 值。比如在网站中我们有两个内容差不多的页面，运营说需要这两个页面的数据进行合并。其中页面的 UV 访问量也需要合并，那这个时候 pfmerge 就可以派上用场了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-09T06:07:37.000Z" title="2021/6/9 下午2:07:37">2021-06-09</time>发表</span><span class="level-item"><time dateTime="2021-06-09T06:07:37.000Z" title="2021/6/9 下午2:07:37">2021-06-09</time>更新</span><span class="level-item">10 分钟读完 (大约1453个字)</span></div></div><div class="content"><h1 id="2-6-3位图"><a href="#2-6-3位图" class="headerlink" title="2.6.3位图"></a>2.6.3位图</h1><p><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">基本使用</a><br><a href="#%E7%BB%9F%E8%AE%A1%E5%92%8C%E6%9F%A5%E6%89%BE">统计和查找</a><br><a href="#%E9%AD%94%E6%9C%AF%E6%8C%87%E4%BB%A4bitfield">魔术指令bitfield</a></p>
<p>​	在我们平时开发过程中，会有一些 bool 型数据需要存取，比如用户一年的签到记录，签了是 1，没签是 0，要记录 365 天。如果使用普通的 key&#x2F;value，每个用户要记录 365 个，当用户上亿的时候，需要的存储空间是惊人的。</p>
<p>​	为了解决这个问题，Redis 提供了位图数据结构，这样每天的签到记录只占据一个位，365 天就是 365 个位，46 个字节 (一个稍长一点的字符串) 就可以完全容纳下，这就大大节约了存储空间。</p>
<p>​	位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组。我们可以使用普通的 get&#x2F;set 直接获取和设置整个位图的内容，也可以使用位图操作 <code>getbit</code>&#x2F;<code>setbit</code> 等将 byte 数组看成「位数组」来处理。</p>
<p>​	以老钱的经验，在面试中有 Redis 位图使用经验的同学很少，如果你对 Redis 的位图有所了解，它将会是你的面试加分项。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。</p>
<p>接下来我们使用位操作将字符串设置为 hello (不是直接使用 set 指令)，首先我们需要得到 hello 的 ASCII 码，用 Python 命令行可以很方便地得到每个字符的 ASCII 码的二进制值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;h&#x27;</span>)) </span><br><span class="line"><span class="string">&#x27;0b1101000&#x27;</span> <span class="comment"># 高位 -&gt; 低位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;e&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0b1100101&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;l&#x27;</span>)) </span><br><span class="line"><span class="string">&#x27;0b1101100&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;l&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0b1101100&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;o&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0b1101111&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../../images/WX20210608-190816@2x.png" alt="WX20210608-190816@2x"></p>
<p>接下来我们使用 <code>redis-cli</code> 设置第一个字符，也就是位数组的前 8 位，我们只需要设置值为 1 的位，如上图所示，h 字符只有 1&#x2F;2&#x2F;4 位需要设置，e 字符只有 9&#x2F;10&#x2F;13&#x2F;15 位需要设置。值得注意的是位数组的顺序和字符的位顺序是相反的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">2</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">4</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">9</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">10</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">13</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">15</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get s </span><br><span class="line"><span class="string">&quot;he&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子可以理解为「零存整取」，同样我们还也可以「零存零取」，「整存零取」。「零存」就是使用 setbit 对位值进行逐个设置，「整存」就是使用字符串一次性填充所有位数组，覆盖掉旧值。</p>
<p><strong>零存零取</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit w <span class="number">1</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit w <span class="number">2</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit w <span class="number">4</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">1</span> <span class="comment"># 获取某个具体位置的值 0/1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">2</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">4</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">5</span></span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果对应位的字节是不可打印字符，redis-cli 会显示该字符的 16 进制形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit x <span class="number">0</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit x <span class="number">1</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get x</span><br><span class="line"><span class="string">&quot;\xc0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="统计和查找"><a href="#统计和查找" class="headerlink" title="统计和查找"></a>统计和查找</h3><p>​	Redis 提供了位图统计指令 bitcount 和位图查找指令 bitpos，bitcount 用来统计指定位置范围内 1 的个数，bitpos 用来查找指定范围内出现的第一个 0 或 1。</p>
<p>​	比如我们可以通过 bitcount 统计用户一共签到了多少天，通过 bitpos 指令查找用户从哪一天开始第一次签到。如果指定了范围参数[start, end]，就可以统计在某个时间范围内用户签到了多少天，用户自某天以后的哪天开始签到。</p>
<p>​	遗憾的是， start 和 end 参数是字节索引，也就是说指定的位范围必须是 8 的倍数，而不能任意指定。这很奇怪，我表示不是很能理解 Antirez 为什么要这样设计。因为这个设计，我们无法直接计算某个月内用户签到了多少天，而必须要将这个月所覆盖的字节内容全部取出来 (getrange 可以取出字符串的子串) 然后在内存里进行统计，这个非常繁琐。</p>
<p>接下来我们简单试用一下 bitcount 指令和 bitpos 指令:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitcount w</span><br><span class="line">(integer) <span class="number">21</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitcount w <span class="number">0</span> <span class="number">0</span> <span class="comment"># 第一个字符中 1 的位数</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitcount w <span class="number">0</span> <span class="number">1</span> <span class="comment"># 前两个字符中 1 的位数</span></span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">0</span> <span class="comment"># 第一个 0 位</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">1</span> <span class="comment"># 第一个 1 位</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="comment"># 从第二个字符算起，第一个 1 位</span></span><br><span class="line">(integer) <span class="number">9</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="comment"># 从第三个字符算起，第一个 1 位</span></span><br><span class="line">(integer) <span class="number">17</span></span><br></pre></td></tr></table></figure>

<h3 id="魔术指令bitfield"><a href="#魔术指令bitfield" class="headerlink" title="魔术指令bitfield"></a>魔术指令bitfield</h3><p>前文我们设置 (<code>setbit</code>) 和获取 (<code>getbit</code>) 指定位的值都是单个位的，如果要一次操作多个位，就必须使用管道来处理。 不过 Redis 的 3.2 版本以后新增了一个功能强大的指令，有了这条指令，不用管道也可以一次进行多个位的操作。 bitfield 有三个子指令，分别是get&#x2F;set&#x2F;incrby，它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个子指令。</p>
<p><img src="/../../images/WX20210608-190816@2x-3150521.png" alt="WX20210608-190816@2x-3150521"></p>
<p>接下来我们对照着上面的图看个简单的例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get u4 0 <span class="comment"># 从第一个位开始取 4 个位，结果是无符号数 (u)</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get u3 2 <span class="comment"># 从第三个位开始取 3 个位，结果是无符号数 (u)</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get i4 0 <span class="comment"># 从第一个位开始取 4 个位，结果是有符号数 (i)</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get i3 2 <span class="comment"># 从第三个位开始取 3 个位，结果是有符号数 (i)</span></span><br><span class="line">(<span class="built_in">integer</span>) -3</span><br></pre></td></tr></table></figure>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-08T10:50:59.000Z" title="2021/6/8 下午6:50:59">2021-06-08</time>发表</span><span class="level-item"><time dateTime="2021-06-08T10:50:59.000Z" title="2021/6/8 下午6:50:59">2021-06-08</time>更新</span><span class="level-item">16 分钟读完 (大约2445个字)</span></div></div><div class="content"><h1 id="2-6-2延时队列"><a href="#2-6-2延时队列" class="headerlink" title="2.6.2延时队列"></a>2.6.2延时队列</h1><p><a href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">异步消息队列</a><br><a href="#%E9%98%9F%E5%88%97%E7%A9%BA%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F">队列空了怎么办？</a><br><a href="#%E9%98%9F%E5%88%97%E5%BB%B6%E8%BF%9F">队列延迟</a><br><a href="#%E7%A9%BA%E9%97%B2%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%8A%A8%E6%96%AD%E5%BC%80">空闲连接自动断开</a><br><a href="#%E9%94%81%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86">锁冲突处理</a><br><a href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">延时队列的实现</a></p>
<p>​	我们平时习惯于使用 Rabbitmq 和 Kafka 作为消息队列中间件，来给应用程序之间增加异步消息传递功能。这两个中间件都是专业的消息队列中间件，特性之多超出了大多数人的理解能力。</p>
<p>​	使用过 Rabbitmq 的同学知道它使用起来有多复杂，发消息之前要创建 Exchange，再创建 Queue，还要将 Queue 和 Exchange 通过某种规则绑定起来，发消息的时候要指定 routing-key，还要控制头部信息。消费者在消费消息之前也要进行上面一系列的繁琐过程。但是绝大多数情况下，虽然我们的消息队列只有一组消费者，但还是需要经历上面这些繁琐的过程。</p>
<p>​	有了 Redis，它就可以让我们解脱出来，对于那些只有一组消费者的消息队列，使用 Redis 就可以非常轻松的搞定。Redis 的消息队列不是专业的消息队列，它没有非常多的高级特性，没有 ack 保证，如果对消息的可靠性有着极致的追求，那么它就不适合使用。</p>
<h3 id="异步消息队列"><a href="#异步消息队列" class="headerlink" title="异步消息队列"></a>异步消息队列</h3><p>Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用<code>rpush</code>&#x2F;<code>lpush</code>操作入队列，使用 <code>lpop</code> 和 <code>rpop</code> 来出队列。</p>
<p><img src="/../../images/WX20210608-162235@2x.png" alt="WX20210608-162235@2x"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush notify-queue apple banana pear </span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line"><span class="string">&quot;apple&quot;</span></span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line"><span class="string">&quot;banana&quot;</span></span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 1 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line"><span class="string">&quot;pear&quot;</span></span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 0 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h3 id="队列空了怎么办？"><a href="#队列空了怎么办？" class="headerlink" title="队列空了怎么办？"></a>队列空了怎么办？</h3><p>​	客户端是通过队列的 pop 操作来获取消息，然后进行处理。处理完了再接着获取消息，再进行处理。如此循环往复，这便是作为队列消费者的客户端的生命周期。</p>
<p>​	可是如果队列空了，客户端就会陷入 pop 的死循环，不停地 pop，没有数据，接着再 pop，又没有数据。这就是浪费生命的空轮询。空轮询不但拉高了客户端的 CPU，redis 的 QPS 也会被拉高，如果这样空轮询的客户端有几十来个，Redis 的慢查询可能会显著增多。</p>
<p>​	通常我们使用 sleep 来解决这个问题，让线程睡一会，睡个 1s 钟就可以了。不但客户端的 CPU 能降下来，Redis 的 QPS 也降下来了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>) # java 睡 1s</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/WX20210608-162458@2x.png" alt="WX20210608-162458@2x"></p>
<h3 id="队列延迟"><a href="#队列延迟" class="headerlink" title="队列延迟"></a>队列延迟</h3><p>用上面睡眠的办法可以解决问题。但是有个小问题，那就是睡眠会导致消息的延迟增大。如果只有 1 个消费者，那么这个延迟就是 1s。如果有多个消费者，这个延迟会有所下降，因为每个消费者的睡觉时间是岔开来的。</p>
<p>​	有没有什么办法能显著降低延迟呢？你当然可以很快想到：那就把睡觉的时间缩短点。这种方式当然可以，不过有没有更好的解决方案呢？当然也有，那就是 <code>blpop</code>&#x2F;<code>brpop</code>。</p>
<p>​	这两个指令的前缀字符 b 代表的是 <code>blocking</code>，也就是阻塞读。</p>
<p>​	阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。用 blpop&#x2F;brpop 替代前面的 lpop&#x2F;rpop，就完美解决了上面的问题。…</p>
<h3 id="空闲连接自动断开"><a href="#空闲连接自动断开" class="headerlink" title="空闲连接自动断开"></a>空闲连接自动断开</h3><p>​	你以为上面的方案真的很完美么？先别急着开心，其实他还有个问题需要解决。</p>
<p>​	什么问题？—— <strong>空闲连接</strong>的问题。</p>
<p>​	如果线程一直阻塞在哪里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用。这个时候 <code>blpop</code>&#x2F;<code>brpop</code> 会抛出异常来。</p>
<p>​	所以编写客户端消费者的时候要小心，注意捕获异常，还要重试。…</p>
<h3 id="锁冲突处理"><a href="#锁冲突处理" class="headerlink" title="锁冲突处理"></a>锁冲突处理</h3><p>​	上节课我们讲了分布式锁的问题，但是没有提到客户端在处理请求时加锁没加成功怎么办。一般有 3 种策略来处理加锁失败： </p>
<p>​	1、直接抛出异常，通知用户稍后重试；<br>​	2、sleep 一会再重试；<br>​	3、将请求转移至延时队列，过一会再试；</p>
<p><strong>直接抛出特定类型的异常</strong></p>
<p>这种方式比较适合由用户直接发起的请求，用户看到错误对话框后，会先阅读对话框的内容，再点击重试，这样就可以起到人工延时的效果。如果考虑到用户体验，可以由前端的代码替代用户自己来进行延时重试控制。它本质上是对当前请求的放弃，由用户决定是否重新发起新的请求。</p>
<p><strong>sleep</strong></p>
<p>sleep 会阻塞当前的消息处理线程，会导致队列的后续消息处理出现延迟。如果碰撞的比较频繁或者队列里消息比较多，sleep 可能并不合适。如果因为个别死锁的 key 导致加锁不成功，线程会彻底堵死，导致后续消息永远得不到及时处理。</p>
<p><strong>延时队列</strong></p>
<p>这种方式比较适合异步消息处理，将当前冲突的请求扔到另一个队列延后处理以避开冲突。</p>
<h3 id="延时队列的实现"><a href="#延时队列的实现" class="headerlink" title="延时队列的实现"></a>延时队列的实现</h3><p>延时队列可以通过 Redis 的 zset(有序列表) 来实现。我们将消息序列化成一个字符串作为 zset 的 value，这个消息的到期处理时间作为 score，然后用多个线程轮询 zset 获取到期的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delay</span>(<span class="params">msg</span>): </span><br><span class="line">	msg.<span class="built_in">id</span> = <span class="built_in">str</span>(uuid.uuid4()) <span class="comment"># 保证 value 值唯一</span></span><br><span class="line">	value = json.dumps(msg) </span><br><span class="line">	retry_ts = time.time() + <span class="number">5</span> <span class="comment"># 5 秒后重试</span></span><br><span class="line">	redis.zadd(<span class="string">&quot;delay-queue&quot;</span>, retry_ts, value) </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>(): </span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">		<span class="comment"># 最多取 1 条</span></span><br><span class="line">  	values = redis.zrangebyscore(<span class="string">&quot;delay-queue&quot;</span>, <span class="number">0</span>, time.time(), start=<span class="number">0</span>, num=<span class="number">1</span>) </span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> values: </span><br><span class="line">      time.sleep(<span class="number">1</span>) <span class="comment"># 延时队列空的，休息 1s</span></span><br><span class="line">			<span class="keyword">continue</span> </span><br><span class="line">		value = values[<span class="number">0</span>] <span class="comment"># 拿第一条，也只有一条</span></span><br><span class="line">		success = redis.zrem(<span class="string">&quot;delay-queue&quot;</span>, value) <span class="comment"># 从消息队列中移除该消息</span></span><br><span class="line">		<span class="keyword">if</span> success: <span class="comment"># 因为有多进程并发的可能，最终只会有一个进程可以抢到消息</span></span><br><span class="line">			msg = json.loads(value) </span><br><span class="line">			handle_msg(msg)</span><br></pre></td></tr></table></figure>

<p>​	Redis 的 zrem 方法是多线程多进程争抢任务的关键，它的返回值决定了当前实例有没有抢到任务，因为 <code>loop</code> 方法可能会被多个线程、多个进程调用，同一个任务可能会被多个进程线程抢到，通过 <code>zrem</code>来决定唯一的属主。</p>
<p>​	同时，我们要注意一定要对 handle_msg 进行异常捕获，避免因为个别任务处理问题导致循环异常退出。以下是 Java 版本的延时队列实现，因为要使用到 Json 序列化，所以还需要 <code>fastjson</code> 库的支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.TypeReference;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDelayingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TaskItem</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> String id;</span><br><span class="line">        <span class="keyword">public</span> T msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fastjson 序列化对象中存在 generic 类型时，需要使用 TypeReference</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Type</span> <span class="variable">TaskType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;TaskItem&lt;T&gt;&gt;() &#123;</span><br><span class="line">    &#125;.getType();</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisDelayingQueue</span><span class="params">(Jedis jedis, String queueKey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">        <span class="built_in">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delay</span><span class="params">(T msg)</span> &#123;</span><br><span class="line">        <span class="type">TaskItem</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskItem</span>();</span><br><span class="line">        task.id = UUID.randomUUID().toString(); <span class="comment">// 分配唯一的 uuid</span></span><br><span class="line">        task.msg = msg;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(task); <span class="comment">// fastjson 序列化</span></span><br><span class="line">        jedis.zadd(queueKey, System.currentTimeMillis() + <span class="number">5000</span>, s); <span class="comment">// 塞入延时队列 ,5s 后再试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line"><span class="comment">// 只取一条</span></span><br><span class="line">            <span class="type">Set</span> <span class="variable">values</span> <span class="operator">=</span> jedis.zrangeByScore(queueKey, <span class="number">0</span>, System.currentTimeMillis(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (values.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>); <span class="comment">// 歇会继续</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> values.iterator().next();</span><br><span class="line">            <span class="keyword">if</span> (jedis.zrem(queueKey, s) &gt; <span class="number">0</span>) &#123; <span class="comment">// 抢到了</span></span><br><span class="line">                <span class="type">TaskItem</span> <span class="variable">task</span> <span class="operator">=</span> JSON.parseObject(s, TaskType); <span class="comment">// fastjson 反序列化</span></span><br><span class="line">                <span class="built_in">this</span>.handleMsg(task.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMsg</span><span class="params">(T msg)</span> &#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();</span><br><span class="line">        <span class="type">RedisDelayingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisDelayingQueue</span>&lt;&gt;(jedis, <span class="string">&quot;q-demo&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    queue.delay(<span class="string">&quot;codehole&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                queue.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.join();</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            consumer.interrupt();</span><br><span class="line">            consumer.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>进一步优化</strong></p>
<p>上面的算法中同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到的进程都是白取了一次任务，这是浪费。可以考虑使用 lua scripting 来优化一下这个逻辑，将zrangebyscore 和 zrem 一同挪到服务器端进行原子化操作，这样多个进程之间争抢任务时就不会出现这种浪费了。</p>
<p><strong>思考</strong></p>
<p>1、Redis 作为消息队列为什么不能保证 100% 的可靠性？ </p>
<p>2、使用 Lua Scripting 来优化延时队列的逻辑。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-08T08:14:33.000Z" title="2021/6/8 下午4:14:33">2021-06-08</time>发表</span><span class="level-item"><time dateTime="2021-06-08T08:14:33.000Z" title="2021/6/8 下午4:14:33">2021-06-08</time>更新</span><span class="level-item">13 分钟读完 (大约1919个字)</span></div></div><div class="content"><h1 id="2-6-1-分布式锁"><a href="#2-6-1-分布式锁" class="headerlink" title="2.6.1.分布式锁"></a>2.6.1.分布式锁</h1><p><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a><br><a href="#%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98">超时问题</a><br><a href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7">可重入性</a></p>
<p>分布式应用进行逻辑处理时经常会遇到并发问题。</p>
<p>比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。（Wiki 解释：所谓<strong>原子操作</strong>是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch 线程切换。）</p>
<p><img src="/../../images/WX20210608-102304@2x.png" alt="WX20210608-102304@2x"></p>
<p>这个时候就要使用到分布式锁来限制程序的并发执行。Redis 分布式锁使用非常广泛，它是面试的重要考点之一，很多同学都知道这个知识，也大致知道分布式锁的原理，但是具体到细节的使用上往往并不完全正确。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这里的冒号:就是一个普通的字符，没特别含义，它可以是任意其它字符，不要误解</span><br><span class="line">&gt; setnx lock:codehole <span class="literal">true</span></span><br><span class="line">OK</span><br><span class="line">... <span class="keyword">do</span> something critical ...</span><br><span class="line">&gt; del lock:codehole</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>​	但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p>
<p>​	于是我们在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:codehole <span class="literal">true</span></span><br><span class="line">OK</span><br><span class="line">&gt; expire lock:codehole 5</span><br><span class="line">... <span class="keyword">do</span> something critical ...</span><br><span class="line">&gt; del lock:codehole</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>​	但是以上逻辑还有问题。<strong>如果在 setnx 和 expire 之间服务器进程突然挂掉了</strong>，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p>
<p>​	这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。也许你会想到用 Redis 事务来解决。但是这里不行，因为 expire 是依赖于 setnx 的执行结果的，如果 setnx 没抢到锁，expire 是不应该执行的。事务里没有 if-else 分支逻辑，事务的特点是一口气执行，要么全部执行要么一个都不执行。</p>
<p>​	为了解决这个疑难，Redis 开源社区涌现了一堆分布式锁的 library，专门用来解决这个问题。实现方法极为复杂，小白用户一般要费很大的精力才可以搞懂。如果你需要使用分布式锁，意味着你不能仅仅使用 Jedis 或者 redis-py 就行了，还得引入分布式锁的 library。 </p>
<p><img src="/../../images/WX20210608-104119@2x.png" alt="WX20210608-104119@2x"></p>
<p>​	为了治理这个乱象，Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 <code>setnx</code> 和<code>expire</code> 指令可以一起执行，彻底解决了分布式锁的乱象。从此以后所有的第三方分布式锁library 可以休息了。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> lock:codehole <span class="literal">true</span> ex 5 nx </span><br><span class="line">OK ... <span class="keyword">do</span> something critical ... </span><br><span class="line">&gt; del lock:codehole</span><br></pre></td></tr></table></figure>

<p> 上面这个指令就是 setnx 和 expire 组合在一起的原子指令，它就是分布式锁的奥义所在。</p>
<h3 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h3><p>Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁，但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻辑执行完之间拿到了锁。</p>
<p>为了避免这个问题，Redis 分布式锁不要用于较长时间的任务。如果真的偶尔出现了，数据出现的小波错乱可能需要人工介入解决。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag = random.nextint() <span class="comment"># 随机数</span></span><br><span class="line"><span class="keyword">if</span> redis.set(key, tag, nx=True, ex=5):</span><br><span class="line">	do_something()</span><br><span class="line">redis.delifequals(key, tag) <span class="comment"># 不存在的 delifequals 指令</span></span><br></pre></td></tr></table></figure>

<p>有一个更加安全的方案是为 set 指令的 value 参数设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key。但是匹配 value 和删除 key 不是一个原子操作，Redis 也没有提供类似于 delifequals 这样的指令，这就需要使用 Lua 脚本来处理了，因为 Lua 脚本可以保证连续多个指令的原子性执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delifequals</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[1]) == ARGV[1] <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[1])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">return</span> 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>可重入性是指线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，那么这个锁就是可重入的。比如 Java 语言里有个 ReentrantLock 就是可重入锁。Redis 分布式锁如果要支持可重入，需要对客户端的 set 方法进行包装，使用线程的 Threadlocal 变量存储当前持有锁的计数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 </span></span><br><span class="line"><span class="keyword">import</span> redis </span><br><span class="line"><span class="keyword">import</span> threading </span><br><span class="line">locks = threading.local() </span><br><span class="line">locks.redis = &#123;&#125; </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">key_for</span>(<span class="params">user_id</span>): </span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;account_&#123;&#125;&quot;</span>.<span class="built_in">format</span>(user_id) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_lock</span>(<span class="params">client, key</span>): </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">bool</span>(client.<span class="built_in">set</span>(key, <span class="literal">True</span>, nx=<span class="literal">True</span>, ex=<span class="number">5</span>)) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_unlock</span>(<span class="params">client, key</span>): </span><br><span class="line">	client.delete(key) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lock</span>(<span class="params">client, user_id</span>): </span><br><span class="line">  key = key_for(user_id) </span><br><span class="line">	<span class="keyword">if</span> key <span class="keyword">in</span> locks.redis:</span><br><span class="line">		locks.redis[key] += <span class="number">1</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">	ok = _lock(client, key) </span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> ok: </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">	locks.redis[key] = <span class="number">1</span> </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unlock</span>(<span class="params">client, user_id</span>): </span><br><span class="line">	key = key_for(user_id) </span><br><span class="line">	<span class="keyword">if</span> key <span class="keyword">in</span> locks.redis: </span><br><span class="line">		locks.redis[key] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> locks.redis[key] &lt;= <span class="number">0</span>: </span><br><span class="line">			<span class="keyword">del</span> locks.redis[key] </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">client = redis.StrictRedis() </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;lock&quot;</span>, lock(client, <span class="string">&quot;codehole&quot;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;lock&quot;</span>, lock(client, <span class="string">&quot;codehole&quot;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;unlock&quot;</span>, unlock(client, <span class="string">&quot;codehole&quot;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;unlock&quot;</span>, unlock(client, <span class="string">&quot;codehole&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上还不是可重入锁的全部，精确一点还需要考虑内存锁计数的过期时间，代码复杂度将会继续升高。老钱不推荐使用可重入锁，它加重了客户端的复杂性，在编写业务方法时注意在逻辑结构上进行调整完全可以不使用可重入锁。下面是 Java 版本的可重入锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisWithReentrantLock</span> &#123; </span><br><span class="line">	<span class="keyword">private</span> ThreadLocal&lt;Map&gt; lockers = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(); </span><br><span class="line">	<span class="keyword">private</span> Jedis jedis; </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RedisWithReentrantLock</span><span class="params">(Jedis jedis)</span> &#123; </span><br><span class="line">		<span class="built_in">this</span>.jedis = jedis; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">_lock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> jedis.set(key, <span class="string">&quot;&quot;</span>, <span class="string">&quot;nx&quot;</span>, <span class="string">&quot;ex&quot;</span>, <span class="number">5L</span>) != <span class="literal">null</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">_unlock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		jedis.del(key); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">private</span> Map &lt;String, Integer&gt; currentLockers() &#123; </span><br><span class="line">		Map &lt;String, Integer&gt; refs = lockers.get(); </span><br><span class="line">		<span class="keyword">if</span> (refs != <span class="literal">null</span>) &#123; </span><br><span class="line">			<span class="keyword">return</span> refs; </span><br><span class="line">		&#125; </span><br><span class="line">		lockers.set(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()); </span><br><span class="line">		<span class="keyword">return</span> lockers.get(); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		<span class="type">Map</span> <span class="variable">refs</span> <span class="operator">=</span> currentLockers(); </span><br><span class="line">		<span class="type">Integer</span> <span class="variable">refCnt</span> <span class="operator">=</span> refs.get(key); </span><br><span class="line">		<span class="keyword">if</span> (refCnt != <span class="literal">null</span>) &#123; </span><br><span class="line">			refs.put(key, refCnt + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="built_in">this</span>._lock(key); </span><br><span class="line">		<span class="keyword">if</span> (!ok) &#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		refs.put(key, <span class="number">1</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	&#125; </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		<span class="type">Map</span> <span class="variable">refs</span> <span class="operator">=</span> currentLockers();</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">refCnt</span> <span class="operator">=</span> refs.get(key); </span><br><span class="line">		<span class="keyword">if</span> (refCnt == <span class="literal">null</span>) &#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		refCnt -= <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">if</span> (refCnt &gt; <span class="number">0</span>) &#123; </span><br><span class="line">			refs.put(key, refCnt); </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">			refs.remove(key);</span><br><span class="line">			<span class="built_in">this</span> ._unlock(key); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">		<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(); </span><br><span class="line">		<span class="type">RedisWithReentrantLock</span> <span class="variable">redis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisWithReentrantLock</span>(jedis); </span><br><span class="line">		System.out.println(redis.lock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">		System.out.println(redis.lock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">		System.out.println(redis.unlock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">		System.out.println(redis.unlock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2021/06/01/90000%E6%96%87%E7%AB%A0/90010%E5%90%8C%E5%9F%9F%E4%B8%8B%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><img class="fill" src="/../../images/cover10.jpg" alt="90010同域下的单点登录"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-01T03:07:53.000Z" title="2021/6/1 上午11:07:53">2021-06-01</time>发表</span><span class="level-item"><time dateTime="2022-05-08T11:55:11.885Z" title="2022/5/8 下午7:55:11">2022-05-08</time>更新</span><span class="level-item">10 分钟读完 (大约1542个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/01/90000%E6%96%87%E7%AB%A0/90010%E5%90%8C%E5%9F%9F%E4%B8%8B%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/">90010同域下的单点登录</a></h1><div class="content"><h2 id="同域下的单点登录"><a href="#同域下的单点登录" class="headerlink" title="同域下的单点登录"></a>同域下的单点登录</h2><p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。</p>
<p>我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：</p>
<ul>
<li>Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。</li>
<li>sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。</li>
</ul>
<p><img src="/../../images/4e31c204eea22ee07154df928a5ff5350da03d7a.png" alt="image"></p>
<p>那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。<strong>我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。</strong></p>
<p>Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。</p>
<p>同域下的单点登录就实现了，<strong>但这还不是真正的单点登录。</strong></p>
<h2 id="不同域下的单点登录"><a href="#不同域下的单点登录" class="headerlink" title="不同域下的单点登录"></a>不同域下的单点登录</h2><p>同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？</p>
<p>这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。<br><img src="/../../images/dcb743204f8a201be53df5338fc34affe5fa1059.png" alt="cas_flow_diagram"></p>
<p>上图是CAS官网上的标准流程，具体流程如下：</p>
<ol>
<li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li>
<li>跳转到CAS server，即SSO登录系统，<strong>以后图中的CAS Server我们统一叫做SSO系统。</strong> SSO系统也没有登录，弹出用户登录页。</li>
<li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li>
<li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</li>
<li>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li>
<li>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</li>
</ol>
<p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p>
<ol>
<li>用户访问app2系统，app2系统没有登录，跳转到SSO。</li>
<li>由于SSO已经登录了，不需要重新登录认证。</li>
<li>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</li>
<li>app2拿到ST，后台访问SSO，验证ST是否有效。</li>
<li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li>
</ol>
<p>这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。</p>
<p><strong>有的同学问我，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？</strong></p>
<p><strong>其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单点登录（SSO）的所有流程都介绍完了，原理大家都清楚了。总结一下单点登录要做的事情：</p>
<ul>
<li><strong>单点登录（SSO系统）是保障各业务系统的用户资源的安全 。</strong></li>
<li><strong>各个业务系统获得的信息是，这个用户能不能访问我的资源。</strong></li>
<li><strong>单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。</strong></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-31T06:15:14.000Z" title="2021/5/31 下午2:15:14">2021-05-31</time>发表</span><span class="level-item"><time dateTime="2021-05-31T06:15:14.000Z" title="2021/5/31 下午2:15:14">2021-05-31</time>更新</span><span class="level-item">11 分钟读完 (大约1607个字)</span></div></div><div class="content"><h1 id="集群1——-Sentinel"><a href="#集群1——-Sentinel" class="headerlink" title="集群1—— Sentinel"></a>集群1—— Sentinel</h1><p>目前我们讲的 Redis 还只是主从方案，最终一致性。读者们可思考过，如果主节点凌晨3 点突发宕机怎么办？就坐等运维从床上爬起来，然后手工进行从主切换，再通知所有的程序把地址统统改一遍重新上线么？毫无疑问，这样的人工运维效率太低，事故发生时估计得至少 1 个小时才能缓过来。如果是一个大型公司，这样的事故足以上新闻了。</p>
<p>所以我们必须有一个高可用方案来抵抗节点故障，当故障发生时可以自动进行从主切换，程序可以不用重启，运维可以继续睡大觉，仿佛什么事也没发生一样。Redis 官方提供了这样一种方案 —— Redis Sentinel(哨兵)。</p>
<img src="../../images/WX20210531-095606@2x.png" alt="WX20210531-095606@2x" style="zoom:50%;" />

<p>我们可以将 Redis Sentinel 集群看成是一个 ZooKeeper 集群，它是集群高可用的心脏，它一般是由 3～5 个节点组成，这样挂了个别节点集群还可以正常运转。它负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时，客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户端。如此应用程序将无需重启即可自动完成节点切换。比如上图的主节点挂掉后，集群将可能自动调整为下图所示结构。</p>
<img src="../../images/WX20210531-095636@2x.png" alt="WX20210531-095636@2x" style="zoom:50%;" />

<p>从这张图中我们能看到主节点挂掉了，原先的主从复制也断开了，客户端和损坏的主节点也断开了。从节点被提升为新的主节点，其它从节点开始和新的主节点建立复制关系。客户端通过新的主节点继续进行交互。Sentinel 会持续监控已经挂掉了主节点，待它恢复后，集群会调整为下面这张图。</p>
<img src="../../images/WX20210531-095748@2x.png" alt="WX20210531-095748@2x" style="zoom:50%;" />

<p>此时原先挂掉的主节点现在变成了从节点，从新的主节点那里建立复制关系。</p>
<h3 id="1-消息丢失"><a href="#1-消息丢失" class="headerlink" title="1.消息丢失"></a>1.消息丢失</h3><p>Redis 主从采用异步复制，意味着当主节点挂掉时，从节点可能没有收到全部的同步消息，这部分未同步的消息就丢失了。如果主从延迟特别大，那么丢失的数据就可能会特别多。Sentinel 无法保证消息完全不丢失，但是也尽可能保证消息少丢失。它有两个选项可以限制主从延迟过大。</p>
<p>min-slaves-to-write 1</p>
<p>min-slaves-max-lag 10</p>
<p>第一个参数表示主节点必须至少有一个从节点在进行正常复制，否则就<strong>停止对外写服务，丧失可用性</strong>。何为正常复制，何为异常复制？这个就是由第二个参数控制的，它的单位是秒，表示如果 10s 没有收到从节点的反馈，就意味着从节点同步不正常，要么网络断开了，要么一直没有给反馈。</p>
<h3 id="2-Sentinel基本使用"><a href="#2-Sentinel基本使用" class="headerlink" title="2.Sentinel基本使用"></a>2.Sentinel基本使用</h3><p>接下来我们看看客户端如何使用 sentinel，标准的流程应该是客户端可以通过 sentinel发现主从节点的地址，然后在通过这些地址建立相应的连接来进行数据存取操作。我们来看看 Python 客户端是如何做的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> redis.sentinel <span class="keyword">import</span> Sentinel</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sentinel = Sentinel([(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">26379</span>)], socket_timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sentinel.discover_master(<span class="string">&#x27;mymaster&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">6379</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sentinel.discover_slaves(<span class="string">&#x27;mymaster&#x27;</span>)</span><br><span class="line">[(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">6380</span>)]</span><br></pre></td></tr></table></figure>

<p>sentinel 的默认端口是 26379，不同于 Redis 的默认端口 6379，通过 sentinel 对象的</p>
<p><code>discover_master</code> <code>discover_slaves</code> 方法可以发现主从地址，主地址只有一个，从地址可以有多个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>master = sentinel.master_for(<span class="string">&#x27;mymaster&#x27;</span>, socket_timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slave = sentinel.slave_for(<span class="string">&#x27;mymaster&#x27;</span>, socket_timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>master.<span class="built_in">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slave.get(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过 xxx_for 方法可以从连接池中拿出一个连接来使用，因为从地址有多个，redis 客户端对从地址采用轮询方案，也就是 RoundRobin 轮着来。</p>
<p>有个问题是，但 sentinel 进行主从切换时，客户端如何知道地址变更了 ? 通过分析源码，我发现 redis-py 在建立连接的时候进行了主库地址变更判断。<strong>连接池建立新连接时</strong>，会去查询主库地址，然后跟内存中的主库地址进行比对，如果变更了，就断开所有连接，<strong>重新使用新地址建立新连接</strong>。如果是旧的主库挂掉了，那么所有正在使用的连接都会被关闭，然后在重连时就会用上新地址。</p>
<p>但是这样还不够，如果是 sentinel 主动进行主从切换，主库并没有挂掉，而之前的主库连接已经建立了在使用了，没有新连接需要建立，那这个连接是不是一致切换不了？继续深入研究源码，我发现 redis-py 在另外一个点也做了控制。那就是在处理命令的时候捕获了一个特殊的异常 ReadOnlyError，在这个异常里将所有的旧连接全部关闭了，后续指令就会进行重连。<strong>主从切换后，之前的主库被降级到从库，所有的修改性的指令都会抛出 ReadonlyError。</strong></p>
<p>如果没有修改性指令，虽然连接不会得到切换，但是数据不会被破坏，所以即使不切换也没关系。</p>
<p>作业</p>
<p>1、尝试自己搭建一套 redis-sentinel 集群；</p>
<p>2、使用 Python 或者 Java 的客户端对集群进行一些常规操作；</p>
<p>3、试试主从切换，主动切换和被动切换都试一试，看看客户端能否正常切换连接；</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-31T06:14:43.000Z" title="2021/5/31 下午2:14:43">2021-05-31</time>发表</span><span class="level-item"><time dateTime="2021-05-31T06:14:43.000Z" title="2021/5/31 下午2:14:43">2021-05-31</time>更新</span><span class="level-item">14 分钟读完 (大约2171个字)</span></div></div><div class="content"><h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p>[1.CAP原理](#1.CAP 原理)<br><a href="#2.%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4">2.最终一致</a><br><a href="#3.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5">3.主从同步</a><br><a href="#4.%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5">4.增量同步</a><br><a href="#5.%E5%BF%AB%E7%85%A7%E5%90%8C%E6%AD%A5">5.快照同步</a><br><a href="#6.%E5%A2%9E%E5%8A%A0%E4%BB%8E%E8%8A%82%E7%82%B9">6.增加从节点</a><br><a href="#7.%E6%97%A0%E7%9B%98%E5%A4%8D%E5%88%B6">7.无盘复制</a><br><a href="#8.Wait%E6%8C%87%E4%BB%A4">8.Wait指令</a><br><a href="#9.%E5%B0%8F%E7%BB%93">9.小结</a><br>[10.集群1—— Sentinel](#10.集群1—— Sentinel)<br><a href="#11.%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1">11.消息丢失</a><br><a href="#12.Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">12.Sentinel基本使用</a></p>
<p>很多企业都没有使用到 Redis 的集群，但是至少都做了主从。有了主从，当 master 挂掉的时候，运维让从库过来接管，服务就可以继续，否则 master 需要经过数据恢复和重启的过程，这就可能会拖很长的时间，影响线上业务的持续服务。</p>
<p>在了解 Redis 的主从复制之前，让我们先来理解一下现代分布式系统的理论基石——CAP 原理。</p>
<h3 id="1-CAP-原理"><a href="#1-CAP-原理" class="headerlink" title="1.CAP 原理"></a>1.CAP 原理</h3><p>CAP 原理就好比分布式领域的牛顿定律，它是分布式存储的理论基石。自打 CAP 的论文发表之后，分布式存储中间件犹如雨后春笋般一个一个涌现出来。理解这个原理其实很简单，本节我们首先对这个原理进行一些简单的讲解。</p>
<p><strong>C</strong> - <strong>C</strong>onsistent ，一致性<br><strong>A</strong> - <strong>A</strong>vailability ，可用性<br><strong>P</strong> - <strong>P</strong>artition tolerance ，分区容忍性</p>
<p>分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着「<strong>网络分区</strong>」。在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的「一致性」将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲「可用性」，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。</p>
<img src="../../images/WX20210531-095055@2x.png" alt="WX20210531-095055@2x" style="zoom:50%;" />

<p>一句话概括 CAP 原理就是——<strong>网络分区发生时，一致性和可用性两难全</strong>。 </p>
<h3 id="2-最终一致"><a href="#2-最终一致" class="headerlink" title="2.最终一致"></a>2.最终一致</h3><p>​	Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足「<strong>一致性</strong>」要求。当客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以 Redis 满足「<strong>可用性</strong>」。<br>​	Redis 保证「<strong>最终一致性</strong>」，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。</p>
<h3 id="3-主从同步"><a href="#3-主从同步" class="headerlink" title="3.主从同步"></a>3.主从同步</h3><p>Redis 同步支持主从同步和从从同步，从库同步功能是 Redis 后续版本增加的功能，为了减轻主库的同步负担。后面为了描述上的方便，统一理解为主从同步。</p>
<img src="../../images/WX20210531-095334@2x.png" alt="WX20210531-095334@2x" style="zoom:50%;" />



<h3 id="4-增量同步"><a href="#4-增量同步" class="headerlink" title="4.增量同步"></a>4.增量同步</h3><p>Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一遍向主节点反馈自己同步到哪里了 (偏移量)。因为内存的 buffer 是有限的，所以 Redis 主库不能将所有的指令都记录在内存 buffer中。Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。</p>
<p>如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么当网络状况恢复时，Redis 的主节点中那些没有同步的指令在 buffer 中有可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制 — — 快照同步。</p>
<h3 id="5-快照同步"><a href="#5-快照同步" class="headerlink" title="5.快照同步"></a>5.快照同步</h3><p>快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次 bgsave 将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空。加载完毕后通知主节点继续进行增量同步。</p>
<p>在整个快照同步进行的过程中，主节点的复制 buffer 还在不停的往前移动，如果快照同步的时间过长或者复制 buffer 太小，都会导致同步期间的增量指令在复制 buffer 中被覆盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如此极有可能会陷入快照同步的死循环。</p>
<img src="../../images/WX20210531-095441@2x.png" alt="WX20210531-095441@2x" style="zoom:50%;" />

<p>所以务必配置一个合适的复制 buffer 大小参数，避免快照复制的死循环。</p>
<h3 id="6-增加从节点"><a href="#6-增加从节点" class="headerlink" title="6.增加从节点"></a>6.增加从节点</h3><p>当从节点刚刚加入到集群时，它必须先要进行一次快照同步，同步完成后再继续进行增量同步。</p>
<h3 id="7-无盘复制"><a href="#7-无盘复制" class="headerlink" title="7.无盘复制"></a>7.无盘复制</h3><p>主节点在进行快照同步时，会进行很重的文件 IO 操作，特别是对于非 SSD 磁盘存储时，快照会对系统的负载产生较大影响。特别是当系统正在进行 AOF 的 fsync 操作时如果发生快照，fsync 将会被推迟执行，这就会严重影响主节点的服务效率。</p>
<p>所以从 Redis 2.8.18 版开始支持无盘复制。所谓无盘复制是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一遍将序列化的内容发送到从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。</p>
<h3 id="8-Wait指令"><a href="#8-Wait指令" class="headerlink" title="8.Wait指令"></a>8.Wait指令</h3><p>Redis 的复制是异步进行的，wait 指令可以让异步复制变身同步复制，确保系统的强一致性 (不严格)。wait 指令是 Redis3.0 版本以后才出现的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> key value</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">wait</span> 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>wait 提供两个参数，第一个参数是从库的数量 N，第二个参数是时间 t，以毫秒为单位。它表示等待 wait 指令之前的所有写操作同步到 N 个从库 (也就是确保 N 个从库的同步没有滞后)，最多等待时间 t。如果时间 t&#x3D;0，表示无限等待直到 N 个从库同步完成达成一致。</p>
<p>假设此时出现了网络分区，wait 指令第二个参数时间 t&#x3D;0，主从同步无法继续进行，wait 指令会永远阻塞，Redis 服务器将丧失可用性。</p>
<h3 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h3><p>主从复制是 Redis 分布式的基础，Redis 的高可用离开了主从复制将无从进行。后面的章节我们会开始讲解 Redis 的集群模式，这几种集群模式都依赖于本节所讲的主从复制。不过复制功能也不是必须的，如果你将 Redis 只用来做缓存，跟 memcache 一样来对待，也就无需要从库做备份，挂掉了重新启动一下就行。但是只要你使用了 Redis 的持久化功能，就必须认真对待主从复制，它是系统数据安全的基础保障。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/9/">上一页</a></div><div class="pagination-next"><a href="/page/11/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/9/">9</a></li><li><a class="pagination-link is-current" href="/page/10/">10</a></li><li><a class="pagination-link" href="/page/11/">11</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/15/">15</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Tonygeli"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tonygeli</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SH</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">147</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tonygeli" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux%E5%91%BD%E4%BB%A4/"><span class="level-start"><span class="level-item">Linux命令</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">时间管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6/"><span class="level-start"><span class="level-item">读书</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bean/"><span class="tag">Bean</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus/"><span class="tag">Icarus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySql/"><span class="tag">MySql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Netty/"><span class="tag">Netty</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stream/"><span class="tag">Stream</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"><span class="tag">公众号</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><span class="tag">分布式事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><span class="tag">单点登录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"><span class="tag">自动装配</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-10T14:21:17.411Z">2022-05-10</time></p><p class="title"><a href="/2022/05/10/213Linux/13002Linux%E5%91%BD%E4%BB%A4find/">Linux命令find</a></p><p class="categories"><a href="/categories/Linux%E5%91%BD%E4%BB%A4/">Linux命令</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-10T06:58:05.176Z">2022-05-10</time></p><p class="title"><a href="/2022/05/10/3.%E8%AF%BB%E4%B9%A6/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%97%B6%E9%97%B4/">职场上如何管理时间</a></p><p class="categories"><a href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/">时间管理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-09T06:10:31.715Z">2022-05-09</time></p><p class="title"><a href="/2022/05/09/15000%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4/15030k8s-Master/">Kubernetes架构与工作流程及核心概念</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-08T15:13:17.249Z">2022-05-08</time></p><p class="title"><a href="/2022/05/08/213Linux/13001Linux%E5%91%BD%E4%BB%A4lsof/">Linux虚拟文件系统</a></p><p class="categories"><a href="/categories/Linux%E5%91%BD%E4%BB%A4/">Linux命令</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-08T13:02:44.791Z">2022-05-08</time></p><p class="title"><a href="/2022/05/08/3.%E8%AF%BB%E4%B9%A6/Kubernetes%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/">Kubernetes从入门到实践</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></p></div></article></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a><p class="is-size-7"><span>&copy; 2022 Tonygeli</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>