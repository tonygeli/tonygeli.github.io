<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>LILAIQUN</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LILAIQUN"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LILAIQUN"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="LILAIQUN"><meta property="og:url" content="https://tonygeli.github.io/"><meta property="og:site_name" content="LILAIQUN"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tonygeli.github.io/img/og_image.png"><meta property="article:author" content="Tonygeli"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonygeli.github.io"},"headline":"LILAIQUN","image":["https://tonygeli.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tonygeli"},"publisher":{"@type":"Organization","name":"LILAIQUN","logo":{"@type":"ImageObject","url":"https://tonygeli.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?1ecc72096a22e2426f0bc13519c3c3c7";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-23T02:23:22.000Z" title="2021/8/23 上午10:23:22">2021-08-23</time>发表</span><span class="level-item"><time dateTime="2021-08-23T02:23:22.000Z" title="2021/8/23 上午10:23:22">2021-08-23</time>更新</span><span class="level-item">几秒读完 (大约2个字)</span></div></div><div class="content"><h4 id="Inverted-File"><a href="#Inverted-File" class="headerlink" title="Inverted File"></a>Inverted File</h4></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-13T13:00:14.000Z" title="2021/8/13 下午9:00:14">2021-08-13</time>发表</span><span class="level-item"><time dateTime="2021-08-13T13:00:14.000Z" title="2021/8/13 下午9:00:14">2021-08-13</time>更新</span><span class="level-item">4 分钟读完 (大约610个字)</span></div></div><div class="content"><p>[toc]</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>三个线程：Master一条线程和Slave中的两条线程</p>
<ul>
<li>master（binlog dump thread)</li>
<li>Slave (I&#x2F;O thread  SQL thread)</li>
</ul>
<p>1.主节点binlog，主从复制的基础是主库记录数据库的所有变更记录到binlog。<br>2.主节点log dump线程，当binlog有变动时，log dump线程读取其内容并发送给从节点。<br>3.从节点I&#x2F;O线程接收binlog内容，并将其写入relay log文件中。<br>4.从节点的SQL线程读取relay log文件内容对数据更新进行重放，最终保证主从数据库的一致性。</p>
<p>注：主从节点使用binlog文件+position偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点重启，则自动从position的位置发起同步。</p>
<h3 id="全同步复制"><a href="#全同步复制" class="headerlink" title="全同步复制"></a>全同步复制</h3><p>主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回客户端，性能有影响。</p>
<h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><p>和半同步不同的是，半同步复制的逻辑，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作成功</p>
<h2 id="索引类型和对性能的影响"><a href="#索引类型和对性能的影响" class="headerlink" title="索引类型和对性能的影响"></a>索引类型和对性能的影响</h2><p>普通索引</p>
<p>唯一索引</p>
<p>主键：一种特殊的唯一索引</p>
<p>联合索引：覆盖多个数据列，INDEX(colA, colB);</p>
<p>全文索引：通过建立<code>倒排索引</code>， Alter Table t_name Add Fulltext(column)</p>
<h2 id="RDB和AOF机制"><a href="#RDB和AOF机制" class="headerlink" title="RDB和AOF机制"></a>RDB和AOF机制</h2><p>RDB： redis database</p>
<p>将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，将数据集写入临时文件，写入成功后，替换之前的文件，用二进制压缩存储。</p>
<p>优点：</p>
<p>1.整个Redis数据库只包含一个文件dump.rdb，方便持久化<br>2.容灾性好，方便备份<br>3.性能最大化，fork子进程来完成写操作，主进程继续处理命令，所以IO最大化。<br>4.对于数据集大时，比AOF的启动效率更高。</p>
<p>缺点：</p>
<p>1.数据安全性低。RDB是间隔一段时间进行持久化，2次持久化之间发生故障数据丢失<br>2.数据大时，可能导致服务停止</p>
<p>AOF：Append Only File</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-04T03:28:31.000Z" title="2021/8/4 上午11:28:31">2021-08-04</time>发表</span><span class="level-item"><time dateTime="2021-08-04T03:28:31.000Z" title="2021/8/4 上午11:28:31">2021-08-04</time>更新</span><span class="level-item">11 分钟读完 (大约1716个字)</span></div></div><div class="content"><p>[toc]</p>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="1-1-SpringBoot的优点"><a href="#1-1-SpringBoot的优点" class="headerlink" title="1.1 SpringBoot的优点"></a>1.1 SpringBoot的优点</h3><p>SpringBoot是新一代流行的Spring应用开发框架，它具有更多的优点：</p>
<ul>
<li>创建独立的Spring应用</li>
<li>内嵌Tomcat、Jetty或Undertow（无需部署war包）</li>
<li>提供自用的starter来简化构建配置</li>
<li>提供指标监控、运行状况检查和外部化配置</li>
<li>没有代码生成，也不需要XML配置（约定大于配置）</li>
</ul>
<h3 id="1-2-SpringBoot-starter的作用"><a href="#1-2-SpringBoot-starter的作用" class="headerlink" title="1.2 SpringBoot-starter的作用"></a>1.2 SpringBoot-starter的作用</h3><p>SpringBoot拥有很多方便使用的starter（Spring提供的starter命名规范spring-boot-starter-xxx.jar，第三方提供的starter命名规范xxx-spring-boot-starter.jar），比如spring-boot-starter-log4j、mybatis-spring-boot-starter.jar等，各自都代表了一个相对完整的功能模块。</p>
<p>SpringBoot-starter是一个集成接合器，完成两件事：</p>
<ul>
<li>引入模块所需的相关jar包</li>
<li>自动配置各自模块所需的属性</li>
</ul>
<h2 id="二、SpringBoot-starter解析"><a href="#二、SpringBoot-starter解析" class="headerlink" title="二、SpringBoot-starter解析"></a>二、SpringBoot-starter解析</h2><h3 id="2-1-SpringBoot搭建SSM"><a href="#2-1-SpringBoot搭建SSM" class="headerlink" title="2.1 SpringBoot搭建SSM"></a>2.1 SpringBoot搭建SSM</h3><p>我们使用SpringBoot新建一个web工程（SSM），看看他的依赖都有哪些：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可见，使用SpringBoot-starter来搭建web工程相当方便，不像以前搭建SSM，需要将那么多jar包依赖逐个加入到Maven工程，还需考虑jar包之间的版本兼容性等。另外，数据源所需的配置也仅需如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://100.10.14.116:3306/szhtest2?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=test</span><br><span class="line">spring.datasource.password=test</span><br></pre></td></tr></table></figure>

<p>Mybatis的配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">  Map&lt;String, Object&gt; <span class="title function_">get</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，不需要多余的配置，一个SpringBoot搭建的SSM工程就可以跑了。</p>
<h3 id="2-2-SpringBoot的诸多配置"><a href="#2-2-SpringBoot的诸多配置" class="headerlink" title="2.2 SpringBoot的诸多配置"></a>2.2 SpringBoot的诸多配置</h3><p>得益于starter的作用，使用SpringBoot确实方便，但对刚刚上手SpringBoot的人来说，可能只知道配置属性是在application.xml或application.yml中添加，但他们各自的属性都有哪些，具体怎么配置，却无从下手。这里先解决SpringBoot-starter中各属性的配置问题。</p>
<p>以2.1中的示例来看，Mybatis的配置是怎么生效的？查看示例工程的pom依赖：</p>
<p><img src="/../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmd6ZWhhbw==,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>注意到mybatis-spring-boot-starter帮我们自动依赖了Mybatis所需jar包，其中有一个负责自动配置的<strong>mybatis-spring-boot-autoconfigure.jar</strong>，紧接着打开此jar，如下：</p>
<p><img src="/../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmd6ZWhhbw==,size_16,color_FFFFFF,t_70-20210804110346321.png" alt="img"></p>
<p>META-INF&#x2F;spring-configuration-metadata.json中便是Mybatis在SpringBoot中的所有配置属性和介绍。至此，第一个问题便得到解决。</p>
<h3 id="2-3-SpringBoot-starter自动配置bean"><a href="#2-3-SpringBoot-starter自动配置bean" class="headerlink" title="2.3 SpringBoot-starter自动配置bean"></a>2.3 SpringBoot-starter自动配置bean</h3><p>现在已得知jar包是怎么样自动依赖进来，以及他们的配置属性，那么接下来该考虑Mybatis所需的bean（如必需的sqlSessionFactory、sqlSessionTemplate等）是如何被自动加载的？</p>
<p>理所应当地，我们继续去查看mybatis-spring-boot-autoconfigure.jar，注意到里面有一个自动配置的类<strong>MybatisAutoConfiguration</strong>：</p>
<p><img src="/../../images/20190915174121365.png" alt="img"></p>
<p>（1）@<strong>Configuration</strong>：被挂上@Configuration注解，表明它是一个配置类，作用等同于xml配置，里面有被@Bean注解的方法，也等同于xml配置的各种<bean>。</p>
<p>（2）@<strong>ConditionalOnClass</strong>&#x2F;@<strong>ConditionalOnBean</strong>：自动配置条件注解，用于在某一部分配置中，将另一模块部分的配置自动加载进来，因为随着系统越来越大，配置内容越来越多，我们应当将Mybatis的配置放在一处，将log4j的配置放在一处，将SpringBoot自身的配置放在一处，当他们需要互相依赖时，可通过这类注解进行自动配置，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span> <span class="meta">@ConditionalOnMissingClass</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span> <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span></span><br><span class="line"><span class="meta">@ConditionalOnResource</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="meta">@ConditionalOnNotWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@AutoConfigureAfter</span> <span class="meta">@AutoConfigureBefore</span> <span class="meta">@AutoConfigureOrder</span>（指定顺序）</span><br></pre></td></tr></table></figure>

<p>（3）@<strong>EnableConfigurationProperties</strong>：启用对@ConfigurationProperties注解的bean的支持，这里对应了配置属性类MybatisProperties，它里面定义了Mybatis的所有配置。</p>
<p>（4）@<strong>AutoConfigureAfter</strong>：应在其他指定的自动配置类之后应用自动配置。即org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration被自动配置后，才会接着自动配置MybatisAutoConfiguration。这里也解释了为什么我们在application.xml中只配置了数据源，而没有配置Mybatis，但是Mybatis可以正常查库的原因，就是因为它们配置之间的依赖关系。</p>
<p>到这里，差不多明白了starter自动配置bean的方式，但是如若再去深究，各种starter的bean是如何被自动加载的，猜想会不会是项目启动后，SpringBoot自动扫描里面所有的jar包，再去扫描所有的类，从而将各个bean放置IOC容器中。从结果来看，肯定是SpringBoot在启动时确确实实地自动加载了数据源和Mybatis相关的bean，不然他们无法正常工作。</p>
<p>回想在我们启动示例工程时，SpringBoot会自动扫描启动类所在包下的所有类，而如果还去扫描所有的jar包的话，又是具体怎么做到的？不妨从入口类调试一把，在SpringApplication.run(DemoApplication.class, args)打断点，一直追踪到<strong>getSpringFactoriesInstances</strong>这块：</p>
<p><img src="/../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmd6ZWhhbw==,size_16,color_FFFFFF,t_70-20210804112014735.png" alt="img"></p>
<p>查看SpringFactoriesLoader.loadFactoryNames的方法注释：</p>
<p>使用给定的类加载器从<code>META-INF/spring.factories</code>加载给定类型的工厂实现的完全限定类名。</p>
<p>有点眼熟，这里的spring.factories刚好也存在于mybatis-spring-boot-autoconfigure.jar中，</p>
<p><img src="/../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmd6ZWhhbw==,size_16,color_FFFFFF,t_70-20210804112201976.png" alt="img"></p>
<p>继续调试，进入<strong>SpringFactoriesLoader.loadFactoryNames</strong>，</p>
<p><img src="/../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmd6ZWhhbw==,size_16,color_FFFFFF,t_70-20210804112752328.png" alt="img"></p>
<p>这里用类加载器得到工程中所有jar包中的<strong>META-INF&#x2F;spring.factories</strong>文件资源，进而通过此文件得到了一些包括自动配置相关的类的集合，有各种工厂类、监听器、处理器、过滤器、初始化器等等，如下：</p>
<p><img src="/../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmd6ZWhhbw==,size_16,color_FFFFFF,t_70-20210804112806138.png" alt="img"></p>
<p>最后的org.springframework.boot.autoconfigure.EnableAutoConfiguration集合中当然包括了org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration和org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration。接着必然是将实例化的各个bean放进IOC容器中。</p>
<p>至此我们便明白了SpringBoot是如何自动配置starter里面的bean的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-30T09:42:33.000Z" title="2021/7/30 下午5:42:33">2021-07-30</time>发表</span><span class="level-item"><time dateTime="2021-07-30T09:42:33.000Z" title="2021/7/30 下午5:42:33">2021-07-30</time>更新</span><span class="level-item">19 分钟读完 (大约2805个字)</span></div></div><div class="content"><p>[toc]</p>
<h3 id="三、垃圾回收器的选择"><a href="#三、垃圾回收器的选择" class="headerlink" title="三、垃圾回收器的选择"></a>三、垃圾回收器的选择</h3><p>1.吞吐量还是响应时间</p>
<p>首先引入两个概念：吞吐量和延迟时间</p>
<p>吞吐量 &#x3D; CPU在用户应用程序运行的时间 &#x2F; (CPU在用户应用程序运行的时间 + CPU垃圾回收的时间)</p>
<p>延迟时间 &#x3D; 平均每次的GC的耗时</p>
<p>通常，吞吐优先还是响应优先这个在JVM中是一个两难之选。堆内存增大，GC一次能处理的数量变大，吞吐量大；但是GC一次的时间会变长，导致后面排队的线程等待时间变长；相反，如果堆内存小，GC一次时间短，排队等待的线程等待时间变短，延迟减少，但一次请求的数量变小(并不绝对符合)，无法同时兼顾。吞吐优先VS响应优先，是JVM调优过程中需要权衡的核心问题。</p>
<p>2.垃圾回收器设计上的考量</p>
<p>垃圾回收器的底层实现机制非常复杂，但是设计者的设计目标无外乎以下几条：</p>
<p>JVM在GC时不允许一边垃圾回收，一边还创建新对象(就像不能一边打扫卫生，还在一边扔垃圾)。</p>
<p>基于第一条GC时需要一段Stop the world的暂停时间，而STW会造成系统短暂停顿不能处理任何请求；</p>
<p>新生代收集频率高，性能优先，常用复制算法；老年代频次低，空间敏感，避免复制方式。</p>
<p>所有垃圾回收器的设计目标都是要让GC频率更少，时间更短，减少GC对系统影响！</p>
<p>3.CMS和G1</p>
<p>目前主流的垃圾回收器配置是新生代采用ParNew，老年代采用CMS组合的方式，或者是完全采用G1回收器，从未来的趋势来看，G1是官方维护和更为推崇的垃圾回收器。<br><img src="/../../images/e6cefe4eea2841a83444256f617387f1.png" alt="e6cefe4eea2841a83444256f617387f1.png"></p>
<p>业务系统，延迟敏感的推荐CMS；大内存服务，要求高吞吐的，采用G1回收器！下面单独就两款回收器的工作机制和适用场景进行一下说明：</p>
<h3 id="四、CMS回收器"><a href="#四、CMS回收器" class="headerlink" title="四、CMS回收器"></a>四、CMS回收器</h3><p>1.CMS垃圾回收器的工作机制</p>
<p>CMS主要是针对老年代的回收器，新生代的采用ParNew回收器，工作流程就是上文提到的经典复制算法，在三块区中进行流转回收，只不过采用多线程并行的方式加快了MinorGC速度。老年代是标记-清除，默认会在一次FullGC算法后做整理算法，清理内存碎片。</p>
<p><img src="/../../images/1773c842a1a29791cdb3b153d6691a53.png" alt="1773c842a1a29791cdb3b153d6691a53.png"></p>
<p>优点：并发收集、主打“低延时” 。在最耗时的两个阶段都没有发生STW，而需要STW的阶段都以很快速度完成。</p>
<p>缺点：1、消耗CPU；2、浮动垃圾；3、内存碎片</p>
<p>适用场景：重视服务器响应速度，要求系统停顿时间最短。</p>
<p>2.登录系统的压测前配置</p>
<p>调优场景以之前的登录系统为例，按照之前容量估算套路，引入性能压测环节，测试同学对登录接口压至1s内60M的对象生成速度，假设只配置了4C8G的机器配置，采用ParNew+CMS的组合回收器，堆内存分配4g，线程栈默认1M，初始配置如下：</p>
<p>-Xms4g –Xmx4g –Xmn1536m -Xss1m -XX:+UseConcMarkSweepGC<br>划分Eden和Surviror大小，如按照默认-XX:SurvivorRatio&#x3D;8 分配规则，基于CMS的JVM运行模型粗略计算如下<br><img src="/../../images/8e9ff3a637d9a56a9ca6c25750a21d83.png" alt="8e9ff3a637d9a56a9ca6c25750a21d83.png"></p>
<p>基本上，可以看到20S后Eden区就满了，此时再运行的时候对象已经无法分配，会触发MinorGC，假设在这次GC后S1装入100M，马上过20S又会触发一次MinorGC，多出来的100M存活对象再加上S1区已经存在的100M，已无法顺利放入到S2区，此时就会触发JVM的动态年龄机制，将一批100M左右的对象推到老年代保存，持续运行一段时间，当老年代也满了的情况下，系统可能不到一小时候就会触发一次FullGC。</p>
<p>3.基于CMS的调优思路</p>
<p>首先采取上调Survior区容量策略：新生代划2g，维持E:S1:S2&#x3D;8:1:1，此时Eden&#x3D;1.6G，S&#x3D;200M。60M&#x2F;S速率，运行25s左右会触发一次MinorGC，回收的对象需要超过200M才触发进入老年代，对象进入老年代的几率大大降低，短命对象在几次minorGC后就释放掉了。此时的JVM配置如下：</p>
<p> -Xms4g –Xmx4g –Xmn2g -Xss1m -XX:SurvivorRatio&#x3D;8  -XX:+UseConcMarkSweepGC<br>然后再下调晋升老年代年龄，默认为15——当躲过15次MinorGC后，可进入老年代；可适当调低改值为5~10，让长寿对象应尽快去往属于它的地方，而不是在新生代来回折腾，占用空间，这样可以优化每次MinorGC的耗时。</p>
<p> -Xms4g –Xmx4g –Xmn2g -Xss1m -XX:SurvivorRatio&#x3D;8  -XX:MaxTenuringThreshold&#x3D;15 -XX:+UseConcMarkSweepGC<br>再选择性的去优化老年代参数：比如老年代默认在标记清除以后会做整理，还可以在CMS的增加GC频次还是增加GC时长上做些取舍，如下是响应优先的参数调优：<br><img src="/../../images/ac9b9b654c90de311c243c35d642711d.png" alt="ac9b9b654c90de311c243c35d642711d.png"></p>
<p>那么最终我们可以得到一个比较适用于自身业务系统的、基于CMS回收器的JVM参数：</p>
<p><code> -Xms4g –Xmx4g –Xmn2g -Xss1m -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=5 -XX:+UseConcMarkSweepGC  -XX:CMSInitiatingOccupancyFraction=70  -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch</code></p>
<h3 id="五、G1垃圾回收器"><a href="#五、G1垃圾回收器" class="headerlink" title="五、G1垃圾回收器"></a>五、G1垃圾回收器</h3><p>1.CMS回收器的不足</p>
<p>服务启动前就需要指定新生代和老年代大小，启动了就不能动态调整了！</p>
<p>新生代和老年代都必须<strong>分配独立且连续的一整块内存空间</strong>！</p>
<p>所有针对老年代的操作必须扫描整个老年代空间，相同的老年代对象，堆空间越大扫描耗时越长！</p>
<p>2.G1回收器的设计思路</p>
<p>G1回收天然的适用于大内存服务器，首先G1将堆内存空间拆分为多个大小相等的Region块，Region的个数默认2048个，配置4g堆内存，每个region的大小就为2M。Region动态的属于老年代或者新生代，上一秒还是分配成新生代，经过回收以后空出来，下一秒有可能被分为老年代区。</p>
<p>在G1回收器这里已经不需要再提前设置新生代和老年代的大小，但是新生代仍区分Eden和Survivor区。大大降低了JVM参数的调优复杂度，<strong>只需配置-XX:MaxGCPauseMillis&#x3D;n(ms)，设置最大GC停顿时间</strong>，剩下的交给G1回收器。G1会自动追踪每个region可以回收的大小和预估的时间，最后在真正垃圾回收的时候，尽量把垃圾回收控制在设置的时间范围内，在有限的时间内回收更多的对象。</p>
<p><img src="/../../images/e032a5b52480e7702acbce7757990f64.png" alt="e032a5b52480e7702acbce7757990f64.png"></p>
<p>所以综合来看，**G1主打高吞吐，特别适用多核、大内存服务(如Kafka&#x2F;ElasticSearch)**。</p>
<p>3.G1的工作机制</p>
<p>新生代回收：对象优先分配Eden的Region，JVM不停给新生代分配更多的region，直到新生代占堆总大小的60%，触发MinorGC。</p>
<p>进入老年代对象的条件不变：达到晋升年龄；动态年龄判定；大对象等</p>
<p>Mix混合回收：当老年代的Region占堆内存的45%以后，触发MixGC，会分阶段多次混合回收新生代和老年代的Region。</p>
<p>Full GC：MixGC时发现无可用的新Region块了来分配复制的存活对象，立马触发FullGC，停止系统程序，单线程标记、清除和整理，空闲出一批Region，过程很缓慢。</p>
<p><img src="/../../images/7c735a8c1064187bdd507687bb91dd42.png" alt="7c735a8c1064187bdd507687bb91dd42.png"></p>
<p>4.G1的核心调优参数</p>
<p>G1收集器自身已经有一套预测和调整机制了，因此我们首先的选择是相信它，即调整-XX:MaxGCPauseMillis&#x3D;N参数，这也符合G1的目的——让GC调优尽量简单！同时也不要自己显式设置新生代的大小(用-Xmn或-XX:NewRatio参数)，如果人为干预新生代的大小，会导致目标时间这个参数失效。</p>
<p>针对-XX:MaxGCPauseMillis来说，参数的设置带有明显的倾向性：调低↓：延迟更低，但MinorGC频繁，MixGC回收老年代区减少，增大Full GC的风险。调高↑：单次回收更多的对象，但系统整体响应时间也会被拉长。</p>
<p>针对InitiatingHeapOccupancyPercent来说，调参大小的效果也不一样：调低↓：更早触发MixGC，浪费cpu。调高↑：堆积过多代回收region，增大FullGC的风险。</p>
<p>5.G1调优在Kafka集群的应用</p>
<p>比如日志平台的Kafka集群每秒写入300M数据至内存，broker节点的配置为16C32G，假设堆内存给16g，新生代分配8g，每秒产生对象假设100M左右，差不多一分多钟就会产生一次MinorGC，CMS机制下需要等Eden满了以后，才一次性清理大约8g左右的垃圾对象，差不多会有秒级的STW停顿，如果是老年代的GC延时长则会有十秒级的STW停顿。</p>
<p><code>-Xms16g –Xmx16g –Xmn8g -Xss1m -XX:+UseConcMarkSweepGC</code><br>假设采用了G1回收器，适当调低最大耗时，设定MaxGCPauseMillis为100ms，并且适当调低堆使用率阈值，G1就会在允许的响应时间内自动的、多批次的去进行垃圾回收，保证每个STW的时间都不会太长。</p>
<p><code> -Xms16g -Xmx16g -Xss1m -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:InitiatingHeapOccupancyPercent=40</code><br>所以线上的kafka和ES集群，动辄32~64g的大内存，如果让CMS去整块回收十多G乃至几十G的垃圾对象，对于系统而言绝对不利！一般来说，堆内存超过8g的大内存服务器，都更推荐使用G1回收器！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-30T02:04:16.000Z" title="2021/7/30 上午10:04:16">2021-07-30</time>发表</span><span class="level-item"><time dateTime="2021-07-30T02:04:16.000Z" title="2021/7/30 上午10:04:16">2021-07-30</time>更新</span><span class="level-item">4 分钟读完 (大约582个字)</span></div></div><div class="content"><p><strong>不可重复读</strong>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p>
<p><strong>幻读</strong>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。</p>
<p>怎么解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题呢？其实有两种可选的解决方案：</p>
<ul>
<li>方案一：读操作利用多版本并发控制（<code>MVCC</code>），写操作进行<code>加锁</code></li>
<li>方案二：读、写操作都采用<code>加锁</code>的方式。</li>
</ul>
<p>用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，<strong>性能更高</strong>，</p>
<p>采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要排队执行，影响性能</p>
<h3 id="锁定读的语句"><a href="#锁定读的语句" class="headerlink" title="锁定读的语句"></a>锁定读的语句</h3><p>对读取的记录加<code>S锁</code>：</p>
<p><code>SELECT ... LOCK IN SHARE MODE;</code></p>
<p>对读取的记录加<code>X锁</code>：</p>
<p><code>SELECT ... FOR UPDATE;</code></p>
<p>我们在对教学楼整体上锁（<code>表锁</code>）时，怎么知道教学楼中有没有教室已经被上锁（<code>行锁</code>）了呢？依次检查每一间教室门口有没有上锁？那这效率也太慢了吧！遍历是不可能遍历的，这辈子也不可能遍历的，于是乎设计<code>InnoDB</code>的大叔们提出了一种称之为<code>意向锁</code>（英文名：<code>Intention Locks</code>）的东东：</p>
<ul>
<li>意向共享锁，英文名：<code>Intention Shared Lock</code>，简称<code>IS锁</code>。当事务准备在某条记录上加<code>S锁</code>时，需要先在表级别加一个<code>IS锁</code>。</li>
<li>意向独占锁，英文名：<code>Intention Exclusive Lock</code>，简称<code>IX锁</code>。当事务准备在某条记录上加<code>X锁</code>时，需要先在表级别加一个<code>IX锁</code>。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-28T09:50:03.000Z" title="2021/7/28 下午5:50:03">2021-07-28</time>发表</span><span class="level-item"><time dateTime="2021-07-28T09:50:03.000Z" title="2021/7/28 下午5:50:03">2021-07-28</time>更新</span><span class="level-item">1 小时读完 (大约9168个字)</span></div></div><div class="content"><p>[toc]</p>
<p>1、自我介绍，项目介绍，遇到的难点？产生原因？如何解决？</p>
<h3 id="2、HashMap1-8与1-7区别？ConcurrentHashMap实现原理-？"><a href="#2、HashMap1-8与1-7区别？ConcurrentHashMap实现原理-？" class="headerlink" title="2、HashMap1.8与1.7区别？ConcurrentHashMap实现原理 ？"></a>2、HashMap1.8与1.7区别？ConcurrentHashMap实现原理 ？</h3><p>HashMap</p>
<p><strong>组成差别</strong><br>1.7:数组+单链表<br>1.8:数据+单链表+红黑树<br><strong>链表存放差别：</strong><br>出现哈希冲突时：<br>1.7直接把数据存放在链表，再无其它操作<br>1.8把数据存放在链表，链表长度超过8就转红黑树<br><strong>扩容差别：</strong><br>1.7扩容条件是数组大于阈值且存在哈希冲突时扩容<br>1.8扩容条件是数组长度大于阈值或链表转红黑树时且数组元素小于64时扩容<br><strong>插值方法：</strong><br>1.7用的是头插法，(在链表头部插入新值)，弊端：可能造成逆序死循环<br>1.8用的是尾插法可避免上面的问题</p>
<p>ConcurrentHashMap采用了非常精妙的”分段锁”策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>;</span><br><span class="line"><span class="comment">// 一个Segment维护着一个HashEntry数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> </span><br><span class="line">  <span class="comment">//MAX_SEGMENTS 为1&lt;&lt;16=65536，也就是最大并发数为65536</span></span><br><span class="line">  <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">	<span class="comment">//2的sshif次方等于ssize，例:ssize=16,sshift=4;ssize=32,sshif=5</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//ssize 为segments数组长度，根据concurrentLevel计算得出</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line"> 	 ++sshift;</span><br><span class="line">  	ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。比如：默认情况下concurrentLevel是16，则ssize为16；若concurrentLevel为14，ssize为16；若concurrentLevel为17，则ssize为32。</strong></p>
<h3 id="3、jvm类加载器，自定义类加载器，双亲委派机制，优缺点，tomcat类加载机制"><a href="#3、jvm类加载器，自定义类加载器，双亲委派机制，优缺点，tomcat类加载机制" class="headerlink" title="3、jvm类加载器，自定义类加载器，双亲委派机制，优缺点，tomcat类加载机制?"></a>3、jvm类加载器，自定义类加载器，双亲委派机制，优缺点，tomcat类加载机制?</h3><p>避免类的重复加载， 确保一个类的全局唯一性Java 类随着它的类加载器一起具备了一种带<strong>有优先级的层级关系</strong>， 通过这种层级关系可以避免类的重复加载， 当父亲已经加载了该类时， 就没有必要子ClassLoader 再加载一次</p>
<p>Tomcat各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AppClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二者同时继承了 URLClassLoader ，继承关系如下：</p>
<p>Tomcat 自己实现了自己的类加载器 WebAppClassLoader。</p>
<ol>
<li>先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。</li>
<li>如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。</li>
<li>如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 AppClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。</li>
<li>如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。</li>
<li><strong>加载依然失败，才使用 AppClassLoader 继续加载。</strong></li>
<li>都没有加载成功的话，抛出异常。</li>
</ol>
<p>总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。</p>
<ul>
<li>保证了基础类不会被同时加载。</li>
<li>又保证了在同一个 Tomcat 下不同 web 之间的 class 是相互隔离的。</li>
</ul>
<h3 id="5、cms收集器过程，g1收集器原理，怎么实现可预测停顿的，region的大小结构？"><a href="#5、cms收集器过程，g1收集器原理，怎么实现可预测停顿的，region的大小结构？" class="headerlink" title="5、cms收集器过程，g1收集器原理，怎么实现可预测停顿的，region的大小结构？"></a>5、cms收集器过程，g1收集器原理，怎么实现可预测停顿的，region的大小结构？</h3><p>CMS 处理过程有七个步骤：</p>
<ol>
<li>初始标记(CMS-initial-mark) ,会导致stw;</li>
<li>并发标记(CMS-concurrent-mark)，与用户线程同时运行；</li>
<li>预清理（CMS-concurrent-preclean），与用户线程同时运行；</li>
<li>可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；</li>
<li>重新标记(CMS-remark) ，会导致swt；</li>
<li>并发清除(CMS-concurrent-sweep)，与用户线程同时运行；</li>
<li>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行； 其运行流程图如下所示：</li>
</ol>
<h3 id="6、内存溢出，内存泄漏遇到过吗？什么场景产生的，怎么解决的？"><a href="#6、内存溢出，内存泄漏遇到过吗？什么场景产生的，怎么解决的？" class="headerlink" title="6、内存溢出，内存泄漏遇到过吗？什么场景产生的，怎么解决的？"></a>6、内存溢出，内存泄漏遇到过吗？什么场景产生的，怎么解决的？</h3><p>引起内存溢出的原因有很多种，常见的有以下几种：<br>　　1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；<br>　　2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；<br>　　3.代码中存在死循环或循环产生过多重复的对象实体；<br>　　4.使用的第三方软件中的BUG；<br>　　5.启动参数内存值设定的过小；</p>
<p>【情况一】：<br><code>java.lang.OutOfMemoryError:Javaheapspace</code>：这种是java堆内存不够，一个原因是真不够（如递归的层数太多等），另一个原因是程序中有死循环；<br>　　如果是java堆内存不够的话，可以通过调整JVM下面的配置来解决：<br>　　-Xms3062m<br>　　-Xmx3062m</p>
<p>【情况二】<br><code>java.lang.OutOfMemoryError:GCoverheadlimitexceeded</code><br>　　【解释】：JDK6新增错误类型，当GC为释放很小空间占用大量时间时抛出；一般是因为堆太小，导致异常的原因，没有足够的内存。<br>　　【解决方案】：<br>　　1、查看系统是否有使用大内存的代码或死循环；<br>　　2、通过添加JVM配置，来限制使用内存：<br>　　-XX:-UseGCOverheadLimit</p>
<p>【情况五】：<br>　　java.lang.OutOfMemoryError:unabletocreatenewnativethread<br>　　【原因】：Stack空间不足以创建额外的线程，要么是创建的线程过多，要么是Stack空间确实小了。<br>　　【解决】：由于JVM没有提供参数设置总的stack空间大小，但可以设置单个线程栈的大小；而系统的用户空间一共是3G，<br>　　　　　　　除了Text&#x2F;Data&#x2F;BSS&#x2F;MemoryMapping几个段之外，Heap和Stack空间的总量有限，是此消彼长的。因此遇到这个错误，<br>　　　　　　  可以通过两个途径解决：1.通过-Xss启动参数减少单个线程栈大小，这样便能开更多线程（当然不能太小，太小会出现StackOverflowError）；<br>　　　　　　　　　　　　　　　　　　2.通过-Xms-Xmx两参数减少Heap大小，将内存让给Stack（前提是保证Heap空间够用）。</p>
<p>【情况六】：<br>　　java.lang.StackOverflowError<br>　　【原因】：这也内存溢出错误的一种，即线程栈的溢出，要么是方法调用层次过多（比如存在无限递归调用），要么是线程栈太小。<br>　　【解决】：优化程序设计，减少方法调用层次；调整-Xss参数增加线程栈大小</p>
<p>Java都采用了“可达性分析”算法来进行内存回收，原理是：会有几个引用作为root节点，对于任意对象来说，如果从root层层遍历，如果找不到对于他的引用链，那么这个对象就被标记为无用，就会在gc时被销毁。</p>
<h3 id="7、volatile的原理？synchronized和重入锁实现原理以及区别？"><a href="#7、volatile的原理？synchronized和重入锁实现原理以及区别？" class="headerlink" title="7、volatile的原理？synchronized和重入锁实现原理以及区别？"></a>7、volatile的原理？synchronized和重入锁实现原理以及区别？</h3><p>volatile保证<strong>可见性</strong>、<strong>防止指令重排</strong>，不保证<strong>原子性</strong>。在JVM底层volatile是采用“内存屏障”来实现的。</p>
<h3 id="8、redis字符串实现，sds和c字符串区别？"><a href="#8、redis字符串实现，sds和c字符串区别？" class="headerlink" title="8、redis字符串实现，sds和c字符串区别？"></a>8、redis字符串实现，sds和c字符串区别？</h3><p><strong>1、在求长度的时候</strong>   C字符串 O(n)  SDS只需要访问len属性即可 时间复杂度O(1).<br><strong>2、缓冲区溢出问题</strong>   C字符串会修改与它相邻 SDS 这里会先根据空间是否够用,实际空间长度为 free + len + 1<br><strong>3、字符串内存分配</strong>   SDS 内部使用两种机制 惰性空间释放跟空间预分配<br>空间预分配：这里SDS&lt;1M的时候是 free &#x3D; len,若SDS&#x3D;6byte 则空间为 6byte + 6byte + 1byte<br>大于1M的时候free &#x3D; 1M, 若SDS长度为60M 则实际空间为 60M + 1M + 1byte<br>惰性空间释放  不立即使用内存重新分配来回收缩短后的字节，而是通过free记录起来，以供后续使用，SDS也提供了相应的API，防止惰性空间导致内存浪费。</p>
<h3 id="9、redis集群，为什么是16384个slot？选举过程，会有脑裂问题么，raft算法，优缺点？"><a href="#9、redis集群，为什么是16384个slot？选举过程，会有脑裂问题么，raft算法，优缺点？" class="headerlink" title="9、redis集群，为什么是16384个slot？选举过程，会有脑裂问题么，raft算法，优缺点？"></a>9、redis集群，为什么是16384个slot？选举过程，会有脑裂问题么，raft算法，优缺点？</h3><p>(1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。<br>如上所述，在消息头中，最占空间的是<code>myslots[CLUSTER_SLOTS/8]</code>。<br>当槽位为65536时，这块的大小是:<br><code>65536÷8÷1024=8kb</code><br>因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。<br>(2)redis的集群主节点数量基本不可能超过1000个。<br>如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。<br>那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。<br>(3)槽位越小，节点少的情况下，压缩比高<br>Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots &#x2F; N很高的话(N表示节点数)，bitmap的压缩率就很低。<br>如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。</p>
<h3 id="10、redis有序集合怎么实现的，跳表是什么？往跳表添加一个元素的过程获取分数的时间复杂度，为什么不用红黑树，红黑树有什么特点，左旋右旋操作？"><a href="#10、redis有序集合怎么实现的，跳表是什么？往跳表添加一个元素的过程获取分数的时间复杂度，为什么不用红黑树，红黑树有什么特点，左旋右旋操作？" class="headerlink" title="10、redis有序集合怎么实现的，跳表是什么？往跳表添加一个元素的过程获取分数的时间复杂度，为什么不用红黑树，红黑树有什么特点，左旋右旋操作？"></a>10、redis有序集合怎么实现的，跳表是什么？往跳表添加一个元素的过程获取分数的时间复杂度，为什么不用红黑树，红黑树有什么特点，左旋右旋操作？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Redis使用了两种数据结构来共同实现有序集合</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">     <span class="comment">//跳跃表</span></span><br><span class="line">     zskiplist *zsl;		<span class="comment">// 范围操作 查找O(logN)</span></span><br><span class="line">     <span class="comment">//字典</span></span><br><span class="line">     dict *dice;				<span class="comment">// 无序保存元素 查找O(1) </span></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>当有序集合对象同时满足以下两个条件时，对象使用 <code>ziplist</code> 编码：<br>1、保存的元素数量小于128；<br>2、保存的所有元素长度都小于64字节。</p>
<p>不能满足上面两个条件的使用 <code>skiplist</code> 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</p>
<p>假设我们要插入的结点是10，首先我们按照跳表查找结点的方法，找到待插入结点的前置结点（仅小于待插入结点）：</p>
<p><img src="/../../images/37c930c77206489399169c56786dd606.png" alt="img"></p>
<p>接下来，按照一般链表的插入方式，把结点10插入到结点9的下一个位置：</p>
<p><img src="/../../images/9637fdae9cf545e9b561454d5311b9c6.png" alt="img"></p>
<p>这样是不是插入工作就完成了呢？并不是。随着原始链表的新结点越来越多，索引会渐渐变得不够用了，因此索引结点也需要相应作出调整。</p>
<p>如何调整索引呢？我们让新插入的结点随机“晋升”，也就是成为索引结点。<strong>新结点晋升成功的几率是50%。</strong></p>
<p>假设第一次随机的结果是晋升成功，那么我们把结点10作为索引结点，插入到第1层索引的对应位置，并且向下指向原始链表的结点10：</p>
<p><img src="/../../images/7900200883c844b48f00beb22c4cb396.png" alt="img"></p>
<p>新结点在成功晋升之后，仍然有机会继续向上一层索引晋升。我们再进行一次随机，假设随机的结果是晋升失败，那么插入操作就告一段落了。</p>
<p>小灰说的是什么意思呢？让我们看看下图， 新结点10已经晋升到第2层索引，下一次随机的结果仍然是晋升成功，这时候该怎么办呢？</p>
<p><img src="/../../images/9eb747d7eb504e4aa3c8fffd09aa1e33.png" alt="img"></p>
<p><img src="/../../images/fdb807a921d44fb49a6e06909726090d.png" alt="img"></p>
<p><img src="/../../images/07bdf3513f104153a8dfda29d6f8e220.png" alt="img"></p>
<p>Redis之所以使用跳表而不使用红黑树原因如下：<br>    1.实现简单，相对于红黑树来说，<strong>实现更加的简单</strong>，不容易出错，代码更加容易维护和调试。<br>    2.跳表的<strong>底层节点</strong>有都是通过<strong>双向指针相互链接</strong>，这和B+树一样，对于范围查找会更加的方便。<br>    3.跳表的效率和红黑树一样，<strong>查找单个Key时间复杂度都是O(logn)</strong><br>    4.跳表更加灵活，可以通过改变索引构建策略，有效的平衡执行效率和内存消耗。</p>
<table>
<thead>
<tr>
<th>zrangebyscore<br />zrevrangebyscore</th>
<th>O(log(n)+k)，k为要获取成员个数，n为当前成员个数</th>
</tr>
</thead>
<tbody><tr>
<td>zadd</td>
<td>O(k*log(n))，k为添加 成员个数，n为当前成员个数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="11、锁升级过程，轻量锁可以变成偏向锁么？偏向锁可以变成无锁么？对象头结构，锁状态变化过程？"><a href="#11、锁升级过程，轻量锁可以变成偏向锁么？偏向锁可以变成无锁么？对象头结构，锁状态变化过程？" class="headerlink" title="11、锁升级过程，轻量锁可以变成偏向锁么？偏向锁可以变成无锁么？对象头结构，锁状态变化过程？"></a>11、锁升级过程，轻量锁可以变成偏向锁么？偏向锁可以变成无锁么？对象头结构，锁状态变化过程？</h3><p><strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率.</p>
<p>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。偏向锁通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致STW(stop the word)操作； </p>
<blockquote>
<p>锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p>
</blockquote>
<p><strong>轻量级锁（自旋锁）</strong></p>
<blockquote>
<p>自旋锁：自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
</blockquote>
<p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。</p>
<h3 id="12、Innodb的结构了解么？磁盘页和缓存区是怎么配合的？缓冲区和磁盘数据不一致怎么办，服务器突然宕机了数据会丢失么？"><a href="#12、Innodb的结构了解么？磁盘页和缓存区是怎么配合的？缓冲区和磁盘数据不一致怎么办，服务器突然宕机了数据会丢失么？" class="headerlink" title="12、Innodb的结构了解么？磁盘页和缓存区是怎么配合的？缓冲区和磁盘数据不一致怎么办，服务器突然宕机了数据会丢失么？"></a>12、Innodb的结构了解么？磁盘页和缓存区是怎么配合的？缓冲区和磁盘数据不一致怎么办，服务器突然宕机了数据会丢失么？</h3><p>MySQL底层架构，涉及到：</p>
<ul>
<li><strong>内存结构</strong>：<code>buffer pool</code>、<code>log buffer</code>、<code>change buffer</code>，buffer pool的页淘汰机制是怎样的；</li>
<li><strong>磁盘结构</strong>：<code>系统表空间</code>、<code>独立表空间</code>、<code>通用表空间</code>、<code>undo表空间</code>、<code>redo log</code>；</li>
<li>以及<code>IO</code>相关底层原理、查询<code>SQL执行流程</code>、数据<code>页结构</code>和<code>行结构</code>描述、<code>聚集索引</code>和<code>辅助索引</code>的底层数据组织方式、<code>MVCC</code>多版本并发控制的底层实现原理，以及可<code>重复读</code>、<code>读已提交</code>是怎么通过MVCC实现的。</li>
</ul>
<h3 id="13、InnoDB-索引为什使用B-树而不是用B树？"><a href="#13、InnoDB-索引为什使用B-树而不是用B树？" class="headerlink" title="13、InnoDB 索引为什使用B+树而不是用B树？"></a>13、InnoDB 索引为什使用B+树而不是用B树？</h3><p><strong>B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。</strong>所以从Mysql（Inoodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。 </p>
<p><strong>那么Mysql如何衡量查询效率呢？– 磁盘IO次数。</strong> B-树&#x2F;B+树 的特点就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。<strong>这是优点之一。</strong><br><strong>另一个优点是：</strong> B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是<strong>将所有的叶子节点用指针串起来</strong>。这样<strong>遍历</strong>叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。</p>
<p>B树相对于红黑树的区别</p>
<p><strong>AVL 数和红黑树基本都是存储在内存中才会使用的数据结构</strong>。在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据<strong>磁盘查找存取的次数往往由树的高度所决定</strong>，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<p><strong>数据库系统的设计者巧妙利用了磁盘预读原理</strong>，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证<strong>一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</p>
<h3 id="14、MySQL-分表是怎么实现的？跨库join如何解决？数据量突增怎么解决？"><a href="#14、MySQL-分表是怎么实现的？跨库join如何解决？数据量突增怎么解决？" class="headerlink" title="14、MySQL 分表是怎么实现的？跨库join如何解决？数据量突增怎么解决？"></a>14、MySQL 分表是怎么实现的？跨库join如何解决？数据量突增怎么解决？</h3><h3 id="15、数据库的隔离级别，怎么实现的？当前读，快照读？MVCC？"><a href="#15、数据库的隔离级别，怎么实现的？当前读，快照读？MVCC？" class="headerlink" title="15、数据库的隔离级别，怎么实现的？当前读，快照读？MVCC？"></a>15、数据库的隔离级别，怎么实现的？当前读，快照读？MVCC？</h3><h3 id="16、mysql优化的实践经验"><a href="#16、mysql优化的实践经验" class="headerlink" title="16、mysql优化的实践经验"></a>16、mysql优化的实践经验</h3><h3 id="17、分布式事务出现过不一致吗？为什么？怎么解决？有什么方法避免？怎么监控？监控到怎么处理？什么时候需要人工接入？"><a href="#17、分布式事务出现过不一致吗？为什么？怎么解决？有什么方法避免？怎么监控？监控到怎么处理？什么时候需要人工接入？" class="headerlink" title="17、分布式事务出现过不一致吗？为什么？怎么解决？有什么方法避免？怎么监控？监控到怎么处理？什么时候需要人工接入？"></a>17、分布式事务出现过不一致吗？为什么？怎么解决？有什么方法避免？怎么监控？监控到怎么处理？什么时候需要人工接入？</h3><h3 id="18、io模型了解么？多路复用？selete，poll，epoll，epoll的结构？怎么注册事件？"><a href="#18、io模型了解么？多路复用？selete，poll，epoll，epoll的结构？怎么注册事件？" class="headerlink" title="18、io模型了解么？多路复用？selete，poll，epoll，epoll的结构？怎么注册事件？"></a>18、io模型了解么？多路复用？selete，poll，epoll，epoll的结构？怎么注册事件？</h3><h3 id="19、你们用的什么消息中间件，kafka，为什么用kafka？kafka是怎么保证高吞吐量的？"><a href="#19、你们用的什么消息中间件，kafka，为什么用kafka？kafka是怎么保证高吞吐量的？" class="headerlink" title="19、你们用的什么消息中间件，kafka，为什么用kafka？kafka是怎么保证高吞吐量的？"></a>19、你们用的什么消息中间件，kafka，为什么用kafka？kafka是怎么保证高吞吐量的？</h3><p><strong>kafka是怎么保证高吞吐量的</strong></p>
<p><strong>1.顺序读写</strong></p>
<p>kafka的消息是不断追加到文件中的，这个特性使kafka可以充分利用磁盘的顺序读写性能。顺序读写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机读写。<br>生产者负责写入数据，Kafka会将消息持久化到磁盘，保证不会丢失数据，Kafka采用了俩个技术提高写入的速度。<br><strong>1.顺序写入</strong>：如果是随机IO，磁盘会进行频繁的寻址，导致写入速度下降。Kafka使用了顺序IO提高了磁盘的写入速度，Kafka会将数据顺序插入到文件末尾，消费者端通过控制<strong>偏移量</strong>来读取消息，这样做会导致数据无法删除，时间一长，磁盘空间会满，kafka提供了2种策略来删除数据：基于时间删除和基于partition文件的大小删除。<br><strong>2.Memory Mapped Files</strong>：这个和Java NIO中的内存映射基本相同，在大学的计算机原理里我们学过（划重点），mmf直接利用操作系统的Page来实现文件到物理内存的映射，完成之后对物理内存的操作会直接同步到硬盘。mmf通过内存映射的方式大大提高了IO速率，省去了用户空间到内核空间的复制。它的缺点显而易见–不可靠，当发生宕机而数据未同步到硬盘时，数据会丢失，Kafka提供了produce.type参数来控制是否主动的进行刷新，如果kafka写入到mmp后立即flush再返回给生产者则为同步模式，反之为异步模式。</p>
<p><strong>2.零拷贝</strong></p>
<p>在这之前先来了解一下零拷贝(直接让操作系统的 Cache 中的数据发送到网卡后传输给下游的消费者)：平时从服务器读取静态文件时，服务器先将文件从复制到内核空间，再复制到用户空间，最后再复制到内核空间并通过网卡发送出去，而零拷贝则是直接从内核到内核再到网卡，省去了用户空间的复制。<br>Kafka把所有的消息存放到一个文件中，当消费者需要数据的时候直接将文件发送给消费者，比如10W的消息共10M，全部发送给消费者，10M的消息在内网中传输是非常快的，假如需要1s，那么kafka的tps就是10w。Zero copy对应的是Linux中sendfile函数，这个函数会接受一个offsize来确定从哪里开始读取。现实中，不可能将整个文件全部发给消费者，他通过消费者传递过来的偏移量来使用零拷贝读取指定内容的数据返回给消费者。</p>
<p>在Linux kernel2.2 之后出现了一种叫做”零拷贝(zero-copy)”系统调用机制，就是跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到“用户态缓冲区”，系统上下文切换减少为2次，可以提升一倍的性能。</p>
<p><img src="/../../images/webp" alt="img"></p>
<p><strong>3.分区</strong></p>
<p>kafka中的topic中的内容可以被分为多分partition存在,每个partition又分为多个段segment,所以每次操作都是针对一小部分做操作，很轻便，并且增加<code>并行操作</code>的能力</p>
<p><strong>4.批量发送</strong></p>
<p>kafka允许进行批量发送消息，producter发送消息的时候，可以将消息缓存在本地,等到了固定条件发送到kafka</p>
<ol>
<li>等消息条数到固定条数</li>
<li>一段时间发送一次</li>
</ol>
<p><strong>5.数据压缩</strong></p>
<p>Kafka还支持对消息集合进行压缩，Producer可以通过GZIP或Snappy格式对消息集合进行压缩。<br>压缩的好处就是减少传输的数据量，减轻对网络传输的压力。</p>
<p>Producer压缩之后，在Consumer需进行解压，虽然增加了CPU的工作，但在对大数据处理上，瓶颈在网络上而不是CPU，所以这个成本很值得*<code>批量发送</code>和<code>数据压缩</code>一起使用,单条做数据压缩的话，效果不明显*</p>
<p>Kafka的设计目标是高吞吐量，它比其它消息系统快的原因体现在以下几方面：</p>
<p>1、Kafka操作的是序列文件I &#x2F; O（序列文件的特征是按顺序写，按顺序读），为保证顺序，Kafka强制点对点的按顺序传递消息，这意味着，一个consumer在消息流（或分区）中只有一个位置。</p>
<p>2、Kafka不保存消息的状态，即消息是否被“消费”。一般的消息系统需要保存消息的状态，并且还需要以随机访问的形式更新消息的状态。而Kafka 的做法是保存Consumer在Topic分区中的位置offset，在offset之前的消息是已被“消费”的，在offset之后则为未“消费”的，并且offset是可以任意移动的，这样就消除了大部分的随机IO。</p>
<p>3、Kafka支持点对点的批量消息传递。</p>
<p>4、Kafka的消息存储在OS pagecache（页缓存，page cache的大小为一页，通常为4K，在Linux读写文件时，它用于缓存文件的逻辑内容，从而加快对磁盘上映像和数据的访问）。</p>
<h3 id="20、kafka重平衡，重启服务怎么保证kafka不发生重平衡，有什么方案？"><a href="#20、kafka重平衡，重启服务怎么保证kafka不发生重平衡，有什么方案？" class="headerlink" title="20、kafka重平衡，重启服务怎么保证kafka不发生重平衡，有什么方案？"></a>20、kafka重平衡，重启服务怎么保证kafka不发生重平衡，有什么方案？</h3><h3 id="21、netty的原理和使用？tcp的连接过程？一台服务器能支持多少连接，为什么-？tcp各个参数怎么设置？"><a href="#21、netty的原理和使用？tcp的连接过程？一台服务器能支持多少连接，为什么-？tcp各个参数怎么设置？" class="headerlink" title="21、netty的原理和使用？tcp的连接过程？一台服务器能支持多少连接，为什么 ？tcp各个参数怎么设置？"></a>21、netty的原理和使用？tcp的连接过程？一台服务器能支持多少连接，为什么 ？tcp各个参数怎么设置？</h3><p><strong>服务端</strong></p>
<p>我们现在在来回头考虑服务器端。对于服务器来说，最大支持的并发连接是多少呢？就有人开始可爱地糊涂了：“服务器端理论也是端口限制吗？”。好，假设如果受影响的话，那我们的Nginx服务器只监听了一个80端口。那Nginx只能接受一个TCP连接喽？这明显是太荒唐了。</p>
<p>好，我们再看另外一个靠谱一点的答案。那就是一条TCP连接是由一个四元组组成的。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，对于我们这台Nginx Server来说，它的IP和端口是固定的。cp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的。它可能建立的最大的连接数是2的32次方（ip数）×2的16次方（port数）。这是2.8*10的14次方的一个大数字，两百万亿！！</p>
<p>Linux上除了监听80以外，还可以监听其它的端口，例如Mysql的3306, Redis的6339，当然所有65535个端口你都可以用来监听一遍。这样理论上线就到了2的32次方（ip数）×2的16次方（port数）×2的16次方（服务器port数）个。感兴趣你可以算一下，这个基本相当于无穷个了。</p>
<p>不过理想和实际总是会有差距的，因为Linux每维护一条TCP连接都要花费资源。处理连接请求，保活，数据的收发时需要消耗一些CPU，维持TCP连接主要消耗内存。我们题目的问题是考虑最大多少个连接，所以我们先不考虑数据的收发。那么TCP在静止的状态下，就不怎么消耗CPU了，主要消耗内存。而Linux上内存是有限的。<br>我们今天先直接把结论抛出来，一条TCP连接如果不发送数据的话，消耗内存是3.3K左右。如果有数据发送，需要为每条TCP分配发送缓存区，大小受你的参数net.ipv4.tcp_wmem配置影响，默认情况下最小是4K。如果发送结束，缓存区消耗的内存会被回收详细的分析过程敬请期待接下来的另一篇文章。</p>
<p><strong>假设你只保持连接不发送数据，那么你服务器可以建立的连接最大数量 &#x3D; 你的内存&#x2F;3.3K。</strong> 假如是4GB的内存，那么大约可接受的TCP连接数量是100万左右。</p>
<blockquote>
<p>这个例子里，我们考虑的前提是在一个进程下hold所有的服务器端连接。而在实际中的项目里，为了收发数据方便，很多网络IO模型还会为TCP连接再创建一个线程或协程。拿最轻量的golang来说，一个协程栈也需要2KB的内存开销。</p>
</blockquote>
<p><strong>结论</strong></p>
<p>一台机器最大究竟能支持多少个网络连接？这个简单的问题里其实埋了坑，导致无数的英雄好汉被困惑不解。就和树上九只鸟打死一只还剩几只的问题一样，没有和你说清楚树上是真鸟，还是假鸟。也没有说枪是有声还是无声的。通过今天的分析，相信你终于可以扬眉吐气把这个问题踩在脚下摩擦了。来，总结下：</p>
<ul>
<li><strong>TCP连接的客户端机：</strong>每一个ip可建立的TCP连接理论受限于内核net.ip_local_port_range参数，也受限于65535。但可以通过配置多ip的方式来加大自己的建立连接的能力。</li>
<li><strong>TCP连接的服务器机：</strong>每一个监听的端口虽然理论值很大，但这个数字没有实际意义。最大并发数取决你的内存大小，每一条静止状态的TCP连接大约需要吃3.3K的内存。</li>
</ul>
<h3 id="22、Sping的AOP实现原理，以及对象生成方式的种类，单例的还是原型的？"><a href="#22、Sping的AOP实现原理，以及对象生成方式的种类，单例的还是原型的？" class="headerlink" title="22、Sping的AOP实现原理，以及对象生成方式的种类，单例的还是原型的？"></a>22、Sping的AOP实现原理，以及对象生成方式的种类，单例的还是原型的？</h3><h3 id="23、讲讲调度接口是怎么实现的"><a href="#23、讲讲调度接口是怎么实现的" class="headerlink" title="23、讲讲调度接口是怎么实现的"></a>23、讲讲调度接口是怎么实现的</h3><p>Timer 的设计核心是一个 TaskQueue 和一个 TimerThread。Timer 将接收到的任务丢到自己的 TaskQueue中。TimerThread 在创建 Timer 时会启动成为一个守护线程。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread 被唤醒并执行该任务。之后 TimerThread 更新最近一个要执行的任务，继续休眠。</p>
<h3 id="24、分布式唯一ID是怎么实现的"><a href="#24、分布式唯一ID是怎么实现的" class="headerlink" title="24、分布式唯一ID是怎么实现的"></a>24、分布式唯一ID是怎么实现的</h3><h3 id="25、设计模式，以及自己使用的场景"><a href="#25、设计模式，以及自己使用的场景" class="headerlink" title="25、设计模式，以及自己使用的场景"></a>25、设计模式，以及自己使用的场景</h3><h3 id="26、有没有用过分布式锁，怎么实现的，讲讲原理"><a href="#26、有没有用过分布式锁，怎么实现的，讲讲原理" class="headerlink" title="26、有没有用过分布式锁，怎么实现的，讲讲原理"></a>26、有没有用过分布式锁，怎么实现的，讲讲原理</h3><h3 id="27、如何解决线上问题？cpu狂飙怎么办？频繁minor-gc怎么办？可能造成的原因是什么？如何避免？"><a href="#27、如何解决线上问题？cpu狂飙怎么办？频繁minor-gc怎么办？可能造成的原因是什么？如何避免？" class="headerlink" title="27、如何解决线上问题？cpu狂飙怎么办？频繁minor gc怎么办？可能造成的原因是什么？如何避免？"></a>27、如何解决线上问题？cpu狂飙怎么办？频繁minor gc怎么办？可能造成的原因是什么？如何避免？</h3><h3 id="28、怎么理解分布式和微服务，为什么要拆分服务，会产生什么问题，怎么解决这些问题-？"><a href="#28、怎么理解分布式和微服务，为什么要拆分服务，会产生什么问题，怎么解决这些问题-？" class="headerlink" title="28、怎么理解分布式和微服务，为什么要拆分服务，会产生什么问题，怎么解决这些问题 ？"></a>28、怎么理解分布式和微服务，为什么要拆分服务，会产生什么问题，怎么解决这些问题 ？</h3><p><strong>面试题剖析</strong></p>
<p><strong>为什么要将系统进行拆分？</strong></p>
<p>网上查查，答案极度零散和复杂，很琐碎，原因一大坨。但是我这里给大家直观的感受：</p>
<p>1.代码量大，容易冲突，合并非常耗费时间<br>2.不敢随意乱改技术。</p>
<p><strong>拆分了以后</strong>，每个人维护自己的服务就可以了。技术上想怎么升级就怎么升级，大幅度提升复杂系统大型团队的开发效率</p>
<p><strong>拆分后不用 dubbo 可以吗？</strong></p>
<p>当然可以了，大不了最次，就是各个系统之间，直接基于 spring mvc，就纯 http 接口互相通信呗，还能咋样。但是这个肯定是有问题的，因为 http 接口通信维护起来成本很高，你要考虑<strong>超时重试</strong>、<strong>负载均衡</strong>等等各种乱七八糟的问题，比如说你的订单系统调用商品系统，商品系统部署了 5 台机器，你怎么把请求均匀地甩给那 5 台机器？这不就是负载均衡？你要是都自己搞那是可以的，但是确实很痛苦。</p>
<p>所以 dubbo 说白了，是一种 rpc 框架，就是说本地就是进行接口调用，但是 dubbo 会代理这个调用请求，跟远程机器网络通信，给你处理掉负载均衡了、服务实例上下线自动感知了、超时重试了，等等乱七八糟的问题。那你就不用自己做了，用 dubbo 就可以了。</p>
<h3 id="29、怎么理解高可用，如何保证高可用，有什么弊端，熔断机制，怎么实现-？"><a href="#29、怎么理解高可用，如何保证高可用，有什么弊端，熔断机制，怎么实现-？" class="headerlink" title="29、怎么理解高可用，如何保证高可用，有什么弊端，熔断机制，怎么实现 ？"></a>29、怎么理解高可用，如何保证高可用，有什么弊端，熔断机制，怎么实现 ？</h3><h3 id="30、对于高并发怎么看，怎么算高并发，你们项目有么，如果有会产生什么问题，怎么解决"><a href="#30、对于高并发怎么看，怎么算高并发，你们项目有么，如果有会产生什么问题，怎么解决" class="headerlink" title="30、对于高并发怎么看，怎么算高并发，你们项目有么，如果有会产生什么问题，怎么解决"></a>30、对于高并发怎么看，怎么算高并发，你们项目有么，如果有会产生什么问题，怎么解决</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>31、有没有做过压测的项目？首页接口优化是怎么做的？<br>32、如何优雅的写代码？什么代码算做优雅？什么代码是规范？你们代码规范是什么样的？如何进行code review？<br>33、算法：给定一个长度为N的整形数组arr，其中有N个互不相等的自然数1-N，请实现arr的排序，但是不要把下标0∼N−1位置上的数通过直接赋值的方式替换成1∼N<br>34、算法：判断一个树是否是平衡二叉树<br>35、算法：给定一个二叉树，请计算节点值之和最大的路径的节点值之和是多少，这个路径的开始节点和结束节点可以是二叉树中的任意节点<br>36、算法：LRU 缓存<br>37、算法：实现带有getMin功能的栈，要求push，pop，getMin的时间复杂度都是O(1)<br>38、算法：两数之和<br>39、算法：实现二叉树先序，中序和后序遍历</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-23T09:02:41.000Z" title="2021/7/23 下午5:02:41">2021-07-23</time>发表</span><span class="level-item"><time dateTime="2021-07-23T09:02:41.000Z" title="2021/7/23 下午5:02:41">2021-07-23</time>更新</span><span class="level-item">11 分钟读完 (大约1697个字)</span></div></div><div class="content"><h3 id="线程安全的机制"><a href="#线程安全的机制" class="headerlink" title="线程安全的机制"></a>线程安全的机制</h3><p>线程表示一条单独的执行流，每个线程都有自己的执行计数器，有自己的栈，但可以共享内存。共享内存有2个问题：竞态条件、内存可见性</p>
<p>1.synchronized<br>2.使用显式锁<br>3.使用volatile<br>4.使用原子变量和CAS<br>5.写时复制<br>6.ThreadLocal</p>
<p>显式锁是相对synchronized隐式锁而言的，需要自己创建锁，主要实现类ReentrantLock。相比synchronized，显示锁支持以非阻塞方式获取锁，可以响应中断、限时、指定公平性、解决死锁问题。<br>在读多写少、读并发情景中，可以通过读写锁提高并发度，读写锁接口ReadWriteLock</p>
<p>volatile。保证安全不一定需要锁，共享对象只有一个，操作也只是进行最简单的get、set操作，就不存在竞态条件问题，只有内存可见性问题。这时在变量声明上加上volatile就可以了。</p>
<p>写时复制<br>之所以会有线程安全的问题，是因为多个线程并发读写同一个对象，如果每个线程读写的对象都是不同的，或者，如果共享访问的对象是只读的，不能修改，那也就不存在线程安全问题了。<br>我们在介绍容器类CopyOnWriteArrayList和CopyOnWriteArraySet时介绍了写时复制技术，写时复制就是将共享访问的对象变为只读的，写的时候，再使用锁，保证只有一个线程写，写的线程不是直接修改原对象，而是新创建一个对象，对该对象修改完毕后，再原子性地修改共享访问的变量，让它指向新的对象。</p>
<h3 id="20-2线程的协作机制"><a href="#20-2线程的协作机制" class="headerlink" title="20.2线程的协作机制"></a>20.2线程的协作机制</h3><p>wail&#x2F;notify<br>显示条件<br>线程的中断<br>协作工具类<br>阻塞队列<br>Future&#x2F;FutureTask</p>
<h3 id="23-1-静态代理"><a href="#23-1-静态代理" class="headerlink" title="23.1 静态代理"></a>23.1 静态代理</h3><h3 id="23-2-JAVA-SDK动态代理"><a href="#23-2-JAVA-SDK动态代理" class="headerlink" title="23.2 JAVA SDK动态代理"></a>23.2 JAVA SDK动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleJDKDynamicProxyDemo</span> &#123;￼</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">IService</span> &#123;￼</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;￼</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RealService</span> <span class="keyword">implements</span> <span class="title class_">IService</span> &#123;￼</span><br><span class="line">  	<span class="meta">@Override</span>￼</span><br><span class="line">	  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;￼</span><br><span class="line">    	System.out.println(<span class="string">&quot;hello&quot;</span>);￼      </span><br><span class="line">    &#125;￼</span><br><span class="line"> 	&#125;￼</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;￼                </span><br><span class="line">      <span class="keyword">private</span> Object realObj;￼</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">SimpleInvocationHandler</span><span class="params">(Object realObj)</span> &#123;￼</span><br><span class="line">        <span class="built_in">this</span>.realObj = realObj;￼</span><br><span class="line">      &#125;￼</span><br><span class="line">      <span class="meta">@Override</span>￼</span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;￼</span><br><span class="line">          System.out.println(<span class="string">&quot;entering &quot;</span> + method.getName());￼</span><br><span class="line">	    		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(realObj, args);￼        </span><br><span class="line">          System.out.println(<span class="string">&quot;leaving &quot;</span> + method.getName());￼</span><br><span class="line">          <span class="keyword">return</span> result;￼</span><br><span class="line">      &#125;￼</span><br><span class="line">  &#125;￼</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IService</span> <span class="variable">realService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealService</span>();￼</span><br><span class="line">    <span class="type">IService</span> <span class="variable">proxyService</span> <span class="operator">=</span> (IService) Proxy.newProxyInstance(￼IService.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;? &gt;[] &#123; IService.class &#125;,￼ <span class="keyword">new</span> <span class="title class_">SimpleInvocationHandler</span>(realService));￼</span><br><span class="line">    proxyService.sayHello();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="23-3-cglib动态代理"><a href="#23-3-cglib动态代理" class="headerlink" title="23.3 cglib动态代理"></a>23.3 cglib动态代理</h3><p>Java SDK动态代理的局限在于，它只能为接口创建代理，返回的代理对象也只能转换到某个接口类型，如果一个类没有接口，或者希望代理非接口中定义的方法，那就没有办法了。有一个第三方的类库cglib（<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E8%BF%99%E4%B8%80%E7%82%B9%EF%BC%8CSpring%E3%80%81Hibernate%E7%AD%89%E9%83%BD%E4%BD%BF%E7%94%A8%E8%AF%A5%E7%B1%BB%E5%BA%93%E3%80%82%E6%88%91%E4%BB%AC%E7%9C%8B%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%A6%82%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9523-5%E6%89%80%E7%A4%BA%E3%80%82">https://github.com/cglib/cglib），可以做到这一点，Spring、Hibernate等都使用该类库。我们看个简单的例子，如代码清单23-5所示。</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCGLibDemo</span> &#123;￼            </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RealService</span> &#123;￼             </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;￼</span><br><span class="line">    	System.out.println(<span class="string">&quot;hello&quot;</span>);￼</span><br><span class="line">    &#125;￼</span><br><span class="line">  &#125;￼</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;￼</span><br><span class="line">    <span class="meta">@Override</span>￼</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, Method method,￼ Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    ￼  System.out.println(<span class="string">&quot;entering &quot;</span> + method.getName());￼</span><br><span class="line">      <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(object, args);￼</span><br><span class="line">      System.out.println(<span class="string">&quot;leaving &quot;</span> + method.getName());￼</span><br><span class="line">      <span class="keyword">return</span> result;￼</span><br><span class="line">    &#125;￼</span><br><span class="line">  &#125;￼</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; cls)</span> &#123;￼</span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();￼</span><br><span class="line">    enhancer.setSuperclass(cls);￼</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">SimpleInterceptor</span>());￼</span><br><span class="line">    <span class="keyword">return</span> (T) enhancer.create();￼</span><br><span class="line">  &#125;￼         </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;￼                		  </span><br><span class="line">    <span class="type">RealService</span> <span class="variable">proxyService</span> <span class="operator">=</span> getProxy(RealService.class);￼</span><br><span class="line">    proxyService.sayHello();￼</span><br><span class="line">  &#125;￼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RealService表示被代理的类，它没有接口。getProxy()为一个类生成代理对象，这个代理对象可以安全地转换为被代理类的类型，它使用了cglib的Enhancer类。Enhancer类的setSuperclass设置被代理的类，setCallback设置被代理类的public非final方法被调用时的处理类。Enhancer支持多种类型，这里使用的类实现了MethodInterceptor接口，它与Java SDK中的InvocationHandler有点类似，方法名称变成了intercept，多了一个MethodProxy类型的参数。<br>与前面的InvocationHandler不同，SimpleInterceptor中没有被代理的对象，它通过MethodProxy的invokeSuper方法调用被代理类的方法：<br>￼   <code>Object result = proxy.invokeSuper(object, args);</code><br>注意，它不能这样调用被代理类的方法：<br>￼   <code>Object result = method.invoke(object, args);</code></p>
<p>object是代理对象，调用这个方法还会调用到SimpleInterceptor的intercept方法，造成死循环。<br>在main方法中，我们也没有创建被代理的对象，创建的对象直接就是代理对象。<br>cglib的实现机制与Java SDK不同，它是通过继承实现的，它也是动态创建了一个类，但这个类的父类是被代理的类，代理类重写了父类的所有public非final方法，改为调用Callback中的相关方法，在上例中，调用SimpleInterceptor的intercept方法。</p>
<h3 id="23-4-Java-SDK代理与cglib代理比较"><a href="#23-4-Java-SDK代理与cglib代理比较" class="headerlink" title="23.4 Java SDK代理与cglib代理比较"></a>23.4 Java SDK代理与cglib代理比较</h3><p>Java SDK代理面向的是一组接口，它为这些接口动态创建了一个实现类。接口的具体实现逻辑是通过自定义的InvocationHandler实现的，这个实现是自定义的，也就是说，其背后都不一定有真正被代理的对象，也可能有多个实际对象，根据情况动态选择。cglib代理面向的是一个具体的类，它动态创建了一个新类，继承了该类，重写了其方法。<br>从代理的角度看，Java SDK代理的是对象，需要先有一个实际对象，自定义的InvocationHandler引用该对象，然后创建一个代理类和代理对象，客户端访问的是代理对象，代理对象最后再调用实际对象的方法；cglib代理的是类，创建的对象只有一个。<br>如果目的都是为一个类的方法增强功能，Java SDK要求该类必须有接口，且只能处理接口中的方法，cglib没有这个限制。</p>
<h3 id="12-1-抽象容器类"><a href="#12-1-抽象容器类" class="headerlink" title="12.1 抽象容器类"></a>12.1 抽象容器类</h3><p>抽象容器类与之前介绍的接口和具体容器类的关系如图12-1所示。<br>虚线框表示接口，有Collection、List、Set、Queue、Deque和Map。有6个抽象容器类。<br>1）AbstractCollection：实现了Collection接口，被抽象类AbstractList、AbstractSet、AbstractQueue继承，ArrayDeque也继承自AbstractCollection（图中未画出）。<br>2）AbstractList：父类是AbstractCollection，实现了List接口，被ArrayList、Abstract-SequentialList继承。</p>
<p><img src="/../images/575A5B45-0F35-41F5-85F5-7B2188030FF9.png" alt="575A5B45-0F35-41F5-85F5-7B2188030FF9"></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2021/07/14/90000%E6%96%87%E7%AB%A0/90002%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"><img class="fill" src="/../../images/cover2.jpg" alt="90002 快速了解TCP的流量控制与拥塞控制"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-14T07:55:12.000Z" title="2021/7/14 下午3:55:12">2021-07-14</time>发表</span><span class="level-item"><time dateTime="2022-05-08T11:54:23.985Z" title="2022/5/8 下午7:54:23">2022-05-08</time>更新</span><span class="level-item">19 分钟读完 (大约2899个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/14/90000%E6%96%87%E7%AB%A0/90002%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">90002 快速了解TCP的流量控制与拥塞控制</a></h1><div class="content"><h1 id="快速了解TCP的流量控制与拥塞控制"><a href="#快速了解TCP的流量控制与拥塞控制" class="headerlink" title="快速了解TCP的流量控制与拥塞控制"></a>快速了解TCP的流量控制与拥塞控制</h1><p>有关TCP你不能不知道的三次握手和四次挥手问题，<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6711623920568500743/?group_id=6711623920568500743">关于三次握手与四次挥手你要知道这些</a></p></div><a class="article-more button is-small is-size-7" href="/2021/07/14/90000%E6%96%87%E7%AB%A0/90002%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2021/07/14/90000%E6%96%87%E7%AB%A0/90006TCP%E7%B2%98%E6%8B%86%E5%8C%85%E8%AF%A6%E8%A7%A3%E4%B8%8ENetty%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"><img class="fill" src="/../../images/bb8b60d1c9ae493dbe3557c0017ffa15.png" alt="90006 TCP粘拆包详解与Netty代码示例"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-14T07:54:46.000Z" title="2021/7/14 下午3:54:46">2021-07-14</time>发表</span><span class="level-item"><time dateTime="2022-05-08T12:43:13.935Z" title="2022/5/8 下午8:43:13">2022-05-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></span><span class="level-item">11 分钟读完 (大约1583个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/14/90000%E6%96%87%E7%AB%A0/90006TCP%E7%B2%98%E6%8B%86%E5%8C%85%E8%AF%A6%E8%A7%A3%E4%B8%8ENetty%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/">90006 TCP粘拆包详解与Netty代码示例</a></h1><div class="content"><h1 id="TCP粘拆包详解与Netty代码示例"><a href="#TCP粘拆包详解与Netty代码示例" class="headerlink" title="TCP粘拆包详解与Netty代码示例"></a>TCP粘拆包详解与Netty代码示例</h1><p>TCP是个“流”协议，所谓流，就是没有界限的一串数据。可以想想河里的流水，是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</p>
<blockquote>
<p>有关TCP的详细讲解，可以点击<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6711623920568500743/?group_id=6711623920568500743">关于三次握手与四次挥手你要知道这些</a>和<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6711818943989809671/?group_id=6711818943989809671">快速了解TCP的流量控制与拥塞控制</a></p>
</blockquote></div><a class="article-more button is-small is-size-7" href="/2021/07/14/90000%E6%96%87%E7%AB%A0/90006TCP%E7%B2%98%E6%8B%86%E5%8C%85%E8%AF%A6%E8%A7%A3%E4%B8%8ENetty%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2021/07/14/90000%E6%96%87%E7%AB%A0/90003%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82NIO%E6%95%88%E7%8E%87%E9%AB%98%E7%9A%84%E5%8E%9F%E7%90%86/"><img class="fill" src="/../../images/cover3.jpg" alt="90003彻底搞懂NIO效率高的原理"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-14T07:53:00.000Z" title="2021/7/14 下午3:53:00">2021-07-14</time>发表</span><span class="level-item"><time dateTime="2022-05-08T11:54:26.799Z" title="2022/5/8 下午7:54:26">2022-05-08</time>更新</span><span class="level-item">18 分钟读完 (大约2746个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/14/90000%E6%96%87%E7%AB%A0/90003%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82NIO%E6%95%88%E7%8E%87%E9%AB%98%E7%9A%84%E5%8E%9F%E7%90%86/">90003彻底搞懂NIO效率高的原理</a></h1><div class="content"><h1 id="彻底搞懂NIO效率高的原理"><a href="#彻底搞懂NIO效率高的原理" class="headerlink" title="彻底搞懂NIO效率高的原理"></a>彻底搞懂NIO效率高的原理</h1><p><strong>前言</strong></p>
<p>这篇文章读不懂的没关系，可以先收藏一下。笔者准备介绍完epoll和NIO等知识点，然后写一篇Java网络IO模型的介绍，这样可以使Java网络IO的知识体系更加地完整和严谨。初学者也可以等看完IO模型介绍的博客之后，再回头看这些博客，会更加有收获。</p></div><a class="article-more button is-small is-size-7" href="/2021/07/14/90000%E6%96%87%E7%AB%A0/90003%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82NIO%E6%95%88%E7%8E%87%E9%AB%98%E7%9A%84%E5%8E%9F%E7%90%86/#more">阅读更多</a></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/7/">上一页</a></div><div class="pagination-next"><a href="/page/9/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/7/">7</a></li><li><a class="pagination-link is-current" href="/page/8/">8</a></li><li><a class="pagination-link" href="/page/9/">9</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/16/">16</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Tonygeli"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tonygeli</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SH</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">152</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">24</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tonygeli" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux%E5%91%BD%E4%BB%A4/"><span class="level-start"><span class="level-item">Linux命令</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">时间管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6/"><span class="level-start"><span class="level-item">读书</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bean/"><span class="tag">Bean</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus/"><span class="tag">Icarus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySql/"><span class="tag">MySql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Netty/"><span class="tag">Netty</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stream/"><span class="tag">Stream</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8B%E5%8A%A1/"><span class="tag">事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"><span class="tag">公众号</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><span class="tag">内存分配</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><span class="tag">分布式事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><span class="tag">单点登录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%95%E7%94%A8/"><span class="tag">引用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"><span class="tag">自动装配</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%99%90%E6%B5%81/"><span class="tag">限流</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-13T03:44:34.257Z">2022-05-13</time></p><p class="title"><a href="/2022/05/13/12000%E9%9D%A2%E8%AF%95/12005Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%886%E7%A7%8D%E5%9C%BA%E6%99%AF/">Java的引用问题</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-13T03:43:11.151Z">2022-05-13</time></p><p class="title"><a href="/2022/05/13/12000%E9%9D%A2%E8%AF%95/12004Java%E7%9A%84%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/">Java的引用问题</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-12T06:50:12.571Z">2022-05-12</time></p><p class="title"><a href="/2022/05/12/12000%E9%9D%A2%E8%AF%95/12003ThreadLocal%E6%BA%90%E7%A0%81/">ThreadLocal源码介绍</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-11T16:16:28.365Z">2022-05-12</time></p><p class="title"><a href="/2022/05/12/12000%E9%9D%A2%E8%AF%95/12002%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">内存分配</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-11T16:02:44.782Z">2022-05-12</time></p><p class="title"><a href="/2022/05/12/12000%E9%9D%A2%E8%AF%95/12001%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/">常见限流算法</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a><p class="is-size-7"><span>&copy; 2022 Tonygeli</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>