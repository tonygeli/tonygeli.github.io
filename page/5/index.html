<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>LILAIQUN</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LILAIQUN"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LILAIQUN"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="LILAIQUN"><meta property="og:url" content="https://tonygeli.github.io/"><meta property="og:site_name" content="LILAIQUN"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tonygeli.github.io/img/og_image.png"><meta property="article:author" content="Tonygeli"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonygeli.github.io"},"headline":"LILAIQUN","image":["https://tonygeli.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tonygeli"},"publisher":{"@type":"Organization","name":"LILAIQUN","logo":{"@type":"ImageObject","url":"https://tonygeli.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-07T09:08:08.000Z" title="2022/2/7 下午5:08:08">2022-02-07</time>发表</span><span class="level-item"><time dateTime="2022-02-07T09:08:08.000Z" title="2022/2/7 下午5:08:08">2022-02-07</time>更新</span><span class="level-item">32 分钟读完 (大约4837个字)</span></div></div><div class="content"><p>[toc]</p>
<h1 id="1、什么是-Mybatis？"><a href="#1、什么是-Mybatis？" class="headerlink" title="1、什么是 Mybatis？"></a>1、什么是 Mybatis？</h1><p>1.Mybatis 是⼀个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发 时只需要关注 SQL 语句本身，不需要 花费精⼒去处理加载驱动、创建连接、 创 建 statement 等繁杂的过程。程序员直 接编写原⽣态 sql，可以严格控制 sql执⾏性能，灵活度⾼。<br>2.MyBatis 可以使⽤ XML 或注解来配 置和映射原⽣信息，将 POJO 映射成数据库中的记 录 ，避免了⼏乎所有的JDBC代码和⼿动设置参数以及获取结果集。<br>3.通过 xml ⽂件或注解的⽅式将要执⾏的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进⾏映射⽣成最终执⾏的 sql 语句，最后由 mybatis 框架执⾏ sql 并将结果映射为 java 对象并返回。（从执⾏ sql 到返回result 的过程）。 </p>
<h1 id="2-MyBatis的优点"><a href="#2-MyBatis的优点" class="headerlink" title="2.MyBatis的优点"></a>2.MyBatis的优点</h1><p>1.基于 SQL 语句编程，相当灵活，不会对应⽤程序或者数据库的现有设计造成任何影响，SQL 写在 XML ⾥，解除 sql 与程序代码的耦合，便于统⼀管理；提供 XML 标签，⽀持编写动态 SQL 语 句，并可重⽤。<br>2.与 JDBC 相⽐，减少了 50%以上的 代码量，消除了 JDBC ⼤量冗余的代 码， 不需要⼿动开关连接；<br>3.很 好 的 与 各 种 数 据 库 兼 容 （ 因 为 MyBatis 使⽤ JDBC 来连接数据库，所 以 只要 JDBC ⽀持的数据库 MyBatis 都⽀持）。<br>4.能够与 Spring 很好的集成；<br>5.提供映射标签，⽀持对象与数据库的 ORM 字段关系映射；提供对象关系映 射标签，⽀持对象关系组件维护。</p>
<h1 id="3-MyBatis-框架的缺点："><a href="#3-MyBatis-框架的缺点：" class="headerlink" title="3.MyBatis 框架的缺点："></a>3.MyBatis 框架的缺点：</h1><p>1.SQL 语句的编写⼯作量较⼤，尤其当 字段多、关联表多时，对开发⼈员编写 SQL 语句的功底有⼀定要求。<br>2.SQL 语句依赖于数据库，导致数据库 移植性差，不能随意更换数据库。</p>
<h1 id="4、MyBatis-框架适⽤场合："><a href="#4、MyBatis-框架适⽤场合：" class="headerlink" title="4、MyBatis 框架适⽤场合："></a>4、MyBatis 框架适⽤场合：</h1><p>1.MyBatis 专注于 SQL 本身，是⼀个⾜够灵活的 DAO 层解决⽅案。<br>2.对性能的要求很⾼，或者需求变化较 多的项⽬，如互联⽹项⽬，MyBatis 将 是不错的选择。</p>
<h1 id="5、MyBatis-与-Hibernate-有哪些不同？"><a href="#5、MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="5、MyBatis 与 Hibernate 有哪些不同？"></a>5、MyBatis 与 Hibernate 有哪些不同？</h1><p> 1.Mybatis 和 hibernate 不同，它不完全是</p>
<h2 id="2-MYBATIS之MAPPER接口的注册过程"><a href="#2-MYBATIS之MAPPER接口的注册过程" class="headerlink" title="2.MYBATIS之MAPPER接口的注册过程"></a>2.MYBATIS之MAPPER接口的注册过程</h2><p>Mapper接口用于定义执行SQL语句相关的方法，方法名一般和Mapper XML配置文件中&lt;select|update|delete|insert&gt;标签的id属性相同，接口的完全限定名一般对应Mapper XML配置文件的命名空间。</p>
<p>可以看一下Mapper XML，如下面的UserMapper.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.blog4java.mybatis.example.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;sql id=&quot;userAllField&quot;&gt;</span><br><span class="line">      id,create_time, name, password, phone, nick_name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;listAllUser&quot;   resultType=&quot;com.blog4java.mybatis.example.entity.UserEntity&quot; &gt;</span><br><span class="line">        select</span><br><span class="line">        &lt;include refid=&quot;userAllField&quot;/&gt;</span><br><span class="line">        from user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getUserByEntity&quot;  resultType=&quot;com.blog4java.mybatis.example.entity.UserEntity&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">        &lt;include refid=&quot;userAllField&quot;/&gt;</span><br><span class="line">        from user</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">                AND id = #&#123;id&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;name != null&quot;&gt;</span><br><span class="line">                AND name = #&#123;name&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;phone != null&quot;&gt;</span><br><span class="line">                AND phone = #&#123;phone&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getUserByPhone&quot; resultType=&quot;com.blog4java.mybatis.example.entity.UserEntity&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">        &lt;include refid=&quot;userAllField&quot;/&gt;</span><br><span class="line">        from user</span><br><span class="line">        where phone = $&#123;phone&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>UserMapper的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;UserEntity&gt; listAllUser();</span><br><span class="line"></span><br><span class="line">    List&lt;UserEntity&gt; getUserByEntity( UserEntity user);</span><br><span class="line"></span><br><span class="line">    UserEntity getUserByPhone(@Param(&quot;phone&quot;) String phone);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下如何执行这个UserMapper.xml，参考下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取配置文件输入流</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 通过SqlSessionFactoryBuilder的build()方法创建SqlSessionFactory实例</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"><span class="comment">// 调用openSession()方法创建SqlSession实例</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">// 获取UserMapper代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="comment">// 执行Mapper方法，获取执行结果</span></span><br><span class="line">List&lt;UserEntity&gt; userList = userMapper.listAllUser();</span><br><span class="line"></span><br><span class="line">System.out.println(JSON.toJSONString(userList));</span><br></pre></td></tr></table></figure>

<p>如上面的代码所示，在创建SqlSession实例后，需要调用SqlSession的getMapper()方法获取一个UserMapper的引用，然后通过该引用调用Mapper接口中定义的方法，UserMapper是一个接口，我们调用SqlSession对象getMapper()返回的到底是什么呢？</p>
<p>我们知道，接口中定义的方法必须通过某个类实现该接口，然后创建该类的实例，才能通过实例调用方法。所以SqlSession对象的getMapper()方法返回的一定是某个类的实例。具体是哪个类的实例呢？实际上getMapper()方法返回的是一个动态代理对象。</p>
<p>我们一步步解析 DefaultSqlSession实现了SqlSession接口，可以直接看一下DefaultSqlSession对getMapper()的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SqlSession对象getMapper()具体的实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="built_in">this</span>);  <span class="comment">// this:sqlSession</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过调用configuration类的getMapper获取UserMapper的实列，继续看看getMapper的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> &#123;  <span class="comment">// configuration类的getMapper的实现</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>configuration类的getMapper的是通过调用mapperRegistry的getMapper方法来实现的</p>
<p><strong>这里的mapperRegistry用于注册Mapper接口信息，建立Mapper接口的Class对象和MapperProxyFactory对象之间的关系，其中MapperProxyFactory对象用于创建Mapper动态代理对象</strong></p>
<p>继续下一步</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/4925ef65d1764d2abeab75982197f6d6.png?lastModify=1623470232" alt="Mybatis之Mapper接口的注册过程"></p>
<p>根据Mapper接口Class对象获取Mapper动态代理对象</p>
<p>Mapper动态代理对象是通过MapperProxyFactory创建的。</p>
<p>重点来了，MapperProxyFactory如何通过动态代理来创建Mapper对象的</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/658577fd8f6e4bfb94945b74192bb7d5.png?lastModify=1623470232" alt="Mybatis之Mapper接口的注册过程"></p>
<p>MapperProxy使用的是JDK内置的动态代理</p>
<p>MapperProxy使用的是JDK内置的动态代理，实现了InvocationHandler接口，invoke()方法中为通用的拦截逻辑，具体内容在介绍Mapper方法调用过程时再做介绍。使用JDK内置动态代理，通过MapperProxy类实现InvocationHandler接口，定义方法执行拦截逻辑后，还需要调用java.lang.reflect.Proxy类的newProxyInstance()方法创建代理对象。</p>
<p>MyBatis对这一过程做了封装，使用MapperProxyFactory创建Mapper动态代理对象。</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/19f7239d661149ca847ea7171a542faf.png?lastModify=1623470232" alt="Mybatis之Mapper接口的注册过程"></p>
<p>MapperProxyFactory类对jdk动态代理做了进一步的封装</p>
<p>如上面的代码所示，MapperProxyFactory类的工厂方法newInstance()是非静态的。也就是说，使用MapperProxyFactory创建Mapper动态代理对象首先需要创建MapperProxyFactory实例。MapperProxyFactory实例是什么时候创建的呢？</p>
<p>Configuration对象中有一个mapperRegistry属性，创建Configuration对象过程中，<a target="_blank" rel="noopener" href="https://www.toutiao.com/item/6956133794403435038/">具体看这篇文章</a>，解析<mappers>标签的时候会调用mapperRegistry中的addMapper(Class<T> type)，创建MapperProxyFactory实例。</p>
<p>MyBatis通过mapperRegistry属性注册Mapper接口与MapperProxyFactory对象之间的对应关系。下面是MapperRegistry类的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public class MapperRegistry &#123;</span><br><span class="line">  // Configuration对象引用</span><br><span class="line">  private final Configuration config;</span><br><span class="line">  // 用于注册Mapper接口Class对象，和MapperProxyFactory对象对应关系</span><br><span class="line">  private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  public MapperRegistry(Configuration config) &#123;</span><br><span class="line">    this.config = config;</span><br><span class="line">  &#125;</span><br><span class="line">  // 根据Mapper接口Class对象获取Mapper动态代理对象</span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    if (mapperProxyFactory == null) &#123;</span><br><span class="line">      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public &lt;T&gt; boolean hasMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return knownMappers.containsKey(type);</span><br><span class="line">  &#125;</span><br><span class="line">  // 根据Mapper接口Class对象，创建MapperProxyFactory对象，并注册到knownMappers属性中</span><br><span class="line">  public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    if (type.isInterface()) &#123;</span><br><span class="line">      if (hasMapper(type)) &#123;</span><br><span class="line">        throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      boolean loadCompleted = false;</span><br><span class="line">      try &#123;</span><br><span class="line">        knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">        // It&#x27;s important that the type is added before the parser is run</span><br><span class="line">        // otherwise the binding may automatically be attempted by the</span><br><span class="line">        // mapper parser. If the type is already known, it won&#x27;t try.</span><br><span class="line">        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = true;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        if (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @since 3.2.2</span><br><span class="line">   */</span><br><span class="line">  public Collection&lt;Class&lt;?&gt;&gt; getMappers() &#123;</span><br><span class="line">    return Collections.unmodifiableCollection(knownMappers.keySet());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @since 3.2.2</span><br><span class="line">   */</span><br><span class="line">  public void addMappers(String packageName, Class&lt;?&gt; superType) &#123;</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">    for (Class&lt;?&gt; mapperClass : mapperSet) &#123;</span><br><span class="line">      addMapper(mapperClass);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @since 3.2.2</span><br><span class="line">   */</span><br><span class="line">  public void addMappers(String packageName) &#123;</span><br><span class="line">    addMappers(packageName, Object.class);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面的代码所示，MapperRegistry类有一个knownMappers属性，用于注册Mapper接口对应的Class对象和MapperProxyFactory对象之间的关系。另外，MapperRegistry提供了addMapper()方法，用于向knownMappers属性中注册Mapper接口信息。在addMapper()方法中，为每个Mapper接口对应的Class对象创建一个MapperProxyFactory对象，然后添加到knownMappers属性中。</p>
<p>MapperRegistry还提供了getMapper()方法，能够根据Mapper接口的Class对象获取对应的MapperProxyFactory对象，然后就可以使用MapperProxyFactory对象创建Mapper动态代理对象了。</p>
<p>MyBatis框架在应用启动时会解析所有的Mapper接口，然后调用MapperRegistry对象的addMapper()方法将Mapper接口信息和对应的MapperProxyFactory对象注册到MapperRegistry对象中。</p>
<h2 id="3-从源码层面解释：为什么执行MYBATIS接口就可以执行SQL？"><a href="#3-从源码层面解释：为什么执行MYBATIS接口就可以执行SQL？" class="headerlink" title="3.从源码层面解释：为什么执行MYBATIS接口就可以执行SQL？"></a>3.从源码层面解释：为什么执行MYBATIS接口就可以执行SQL？</h2><h1 id="1-场景分析"><a href="#1-场景分析" class="headerlink" title="1:场景分析"></a>1:场景分析</h1><p>在我们使用SpringBoot+MyBatis的时候，我们一般是先引入依赖，然后配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">      mapper-locations: classpath:mapper/*.xml</span><br><span class="line">      type-aliases-package: com.coco.pojo</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然还要在启动类上加上一个注解</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/3937db9fa56947899d61bc78a04a819d.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>这时候，就可以编写一个接口，然后调用这个方法就可以执行配置文件中对应的SQL语句了</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/5c8dd828dee64ec6b031c80c0a745d6b.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>那么底层原理到底是怎么实现的呢？？</p>
<h1 id="2-万事开头难"><a href="#2-万事开头难" class="headerlink" title="2:万事开头难"></a>2:万事开头难</h1><p>分析一个框架源码的时候最难的就是不知道该从哪开始，我是这样想的，既然我们只要写一个这样的接口，那么就可以调用对应的SQL语句，那么肯定是在哪个环节对这个接口做一些特殊的处理</p>
<p>我们在启动类上加了一个注解，而且注解中的包路径正是我们接口的路径，这时候我们就有点眉目了。</p>
<p>进入 <strong>@MapperScan(“com.coco.mapper”)</strong> 这个注解中</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/2aba0c9e45b1412fb74acd771cebf494.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>我们看到除了注解的基本三个注解之外，还有一个注解就是 <strong>@Import({ MapperScannerRegistrar.class})</strong> ，很多小伙伴可能不知道这个注解有什么用，我们先解释一下</p>
<h1 id="3-SPRINGBOOT中-IMPORT注解的作用"><a href="#3-SPRINGBOOT中-IMPORT注解的作用" class="headerlink" title="3: SPRINGBOOT中@IMPORT注解的作用"></a>3: SPRINGBOOT中@IMPORT注解的作用</h1><p>在SpringBoot中当我们要声明一个Bean的时候，我们可以在该类上加上 <strong>@Service，@Compont</strong> 等，或者是在配置类中加上 <strong>@Bean</strong> 这个注解，除此之外还有一种方法，就是 <strong>@Import</strong></p>
<p>@Import注解中会标明一个类，而且在SpringBoot启动的时候会处理也就是会实例化这个Bean，也就是会对这个Bean做一些处理</p>
<h1 id="4-MAPPERSCANNERREGISTRAR-CLASS的作用"><a href="#4-MAPPERSCANNERREGISTRAR-CLASS的作用" class="headerlink" title="4: MAPPERSCANNERREGISTRAR.CLASS的作用"></a>4: MAPPERSCANNERREGISTRAR.CLASS的作用</h1><p>即然知道了 <strong>@Import</strong> 注解的作用，那现在我们进入到这个类中看看，这个类实现了** ImportBeanDefinitionRegistrar** 这个接口</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/09a4d2ca48d740c38f33a061b1b4aa51.png?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>这个接口有什么用呢？？简单的来说就是MyBatis通过这个入口可以让Spring扫描到某些Bean，并且这些Bean会被Spring所管理，也就是说这些Bean会被Spring进行初始化。</p>
<p>所以我们自定义的Mapper接口会被Spring扫描到，然后会被Spring进行加载</p>
<p>ImportBeanDefinitionRegistrar这个接口就代表着当把Bean生成了对应的 <strong>BeanDefinition</strong> 的时候，就会调用这个接口的方法，我们看下这个接口中定义的方法</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/01a26972e56f4587b43fa1a81eced2e1.png?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>这个方法做什么的呢？？</p>
<p>Spring在加载Bean的时候，首先会将Bean生成一个个的对应的 <strong>BeanDefinition</strong> ，后续就会通过这些一个个的 <strong>BeanDefinition</strong> 来进行初始化，也就是生成对应的Bean。</p>
<p>简而言之：Spring会通过MyBatis提供的 <strong>@MapperScan(“com.coco.mapper”)</strong> 这个注解会扫描我们自定义的Mapper接口，然后Spring就会为这些Mapper接口生成对应的 <strong>BeanDefinition</strong></p>
<h1 id="5-DEBUG模式进入源码"><a href="#5-DEBUG模式进入源码" class="headerlink" title="5: DEBUG模式进入源码"></a>5: DEBUG模式进入源码</h1><p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/16b84ced71b647ec85e74efd16a3c789.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>然后debug模式启动SpringBoot项目，当然前提是整合了MyBatis哈，这个方法我进行了截取，其实只需要关注下面这几行代码就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    </span><br><span class="line">    //获取到MapperScan注解</span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    </span><br><span class="line">    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">    // 获取MapperScan注解中basePackages的属性值</span><br><span class="line">    for (String pkg : annoAttrs.getStringArray(&quot;basePackages&quot;)) &#123;</span><br><span class="line">      if (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 真正开始处理这个包路径下的接口，也就是我们的Mapper接口</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里就可以获取到我们自定义mapper接口的包的全路径了</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/22ee326e02bc46fbadd26be350a682d6.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<h1 id="6-开始处理MAPPER接口"><a href="#6-开始处理MAPPER接口" class="headerlink" title="6: 开始处理MAPPER接口"></a>6: 开始处理MAPPER接口</h1><p>我们进入到上面的 scanner.doScan(StringUtils.toStringArray(basePackages)); 这个方法</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/fa6b19fd5327477bbb2bdd1ab836f7d8.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>然后进入 <strong>Set beanDefinitions &#x3D; super.doScan(basePackages);</strong> 发现好多代码，其实这个方法的返回值是一个 <strong>BeanDefinitionHolder</strong> 的集合，而 <strong>BeanDefinitionHolder</strong> 就是bean的名称和该bean的BeanDefinition的组成</p>
<p>其实到这里我们应该能明白，这个方法的作用就是：扫描我们自定义的Mapper接口，然后为每一个接口生成一个对应的BeanDefinition，然后将其返回</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/a70eaf14689641b48a0d5a020a0fb4ea.png?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">                Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);</span><br><span class="line">                Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();</span><br><span class="line">                for (String basePackage : basePackages) &#123;</span><br><span class="line">                        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">                        for (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">                                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">                                candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">                                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);</span><br><span class="line">                                if (candidate instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">                                        postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (candidate instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">                                        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                                        BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                                        definitionHolder =</span><br><span class="line">                                                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">                                        beanDefinitions.add(definitionHolder);</span><br><span class="line">                                        registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return beanDefinitions;</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/281b2ea126e541e39f4f0aa4afe8fffa.png?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>我们debug到这一步可以看到返回值，也证实了我们之前说的</p>
<h1 id="7-拿到BEANDEFINITION之后的处理"><a href="#7-拿到BEANDEFINITION之后的处理" class="headerlink" title="7: 拿到BEANDEFINITION之后的处理"></a>7: 拿到BEANDEFINITION之后的处理</h1><p>现在我们来看下 <strong>processBeanDefinitions(beanDefinitions);</strong> 这个方法，因为之前我们已经拿到了Mapper接口的BeanDefinition了，所以接下来就要进一步的处理</p>
<p>这个方法的代码依旧很多，我这里就不贴出来了，这里我先说一下这个方法是干什么的。</p>
<p>Spring在初始化Bean之前，我们是可以改变Bean的BeanDefinition的属性值得，而这个方法做的事情就是这个，经过这个方法处理之后，我们之前得到的BeanDefiniton会发生一些改变。我这里贴出二张图进行对比一下</p>
<h1 id="这是之前的："><a href="#这是之前的：" class="headerlink" title="这是之前的："></a>这是之前的：</h1><p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/e86c7c377179442fbd8ce481e7e3cc6f.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<h1 id="这是经过该方法处理之后的："><a href="#这是经过该方法处理之后的：" class="headerlink" title="这是经过该方法处理之后的："></a>这是经过该方法处理之后的：</h1><p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/e6cca4863df54c728865ceb9a2448cb3.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>可以发现该Bean的 <strong>beanClass</strong> 属性变了，已经不再是我们自定义的Bean的class了</p>
<p>改变之后有什么问题呢？？</p>
<p>Spring在初始化Bean的时候，会拿到该Bean的BenDefinition，然后就是根据 <strong>beanClass</strong> 这个属性值初始化Bean，本来我们Mapper接口初始化之后应该就是我们自己定义的Bean，也就是我们执行a.getClass的值应该是 com.xxx.a 这种形式的</p>
<p>但是现在变了，也就是说我们自定义的Mapper接口在被Spring初始化之后，再执行a.getClass会变成** org.mybatis.spring.mapper.MapperFactoryBean**</p>
<h1 id="8-初始化BEAN"><a href="#8-初始化BEAN" class="headerlink" title="8: 初始化BEAN"></a>8: 初始化BEAN</h1><p>经过上面的步骤之后，我们是拿到了Mapper接口的BeanDefinition，现在Spring就要开始初始化这些Bean了</p>
<p>因为此时就涉及到了Spring的源码了，我这里就不细说了</p>
<p>大致的流程：</p>
<p>1: Spring在初始化bean的时候，会根据Bean的scope属性进行初始化，而我们自定义的Mapper接口由于BeanDefinition的beanClass属性被修改了，所以在初始化的时候，经过一系列的判断最终会由MyBatis中的 <strong>MapperProxy</strong> 生成一个代理类，底层是通过jdk动态代理实现的</p>
<p>2: 然后当我们调用Mapper接口方法的时候就会执行 <strong>invoke</strong> 方法，因为是jdk动态代理生成的代理类。</p>
<p>3: 这时候，MyBatis是可以拿到该方法所在的类和该类的全路径的，比如我们在 <strong>com.coco.mapper</strong> 包下自定义了一个 <strong>TestMapper</strong> 接口，然后里面有一个 test() 方法，这时候我们可以通过一系列的方法得到一个值，该值就是:** com.coco.mapper.TestMapper.test** , 也就是该Mapper接口的全路径+方法名</p>
<p>4: MyBatis在解析xml配置文件的时候，有一个 <strong>namespace</strong> 的属性，它的值就是Mapper接口的全路径名，然后加上 id 的值，MyBatis底层会将所有的这种路径全都保存在一个Map中，然后执行接口方法的时候就会根据第3步生成的值去匹配，就能拿到对应的SQL语句了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">    &lt;mapper namespace=&quot;com.coco.mapper.TestMapper&quot;&gt;</span><br><span class="line">        &lt;select id=&quot;test&quot;&gt;</span><br><span class="line">           select * from test</span><br><span class="line">        &lt;/select&gt;</span><br><span class="line">    &lt;/mapper&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-29T07:05:03.000Z" title="2021/12/29 下午3:05:03">2021-12-29</time>发表</span><span class="level-item"><time dateTime="2021-12-29T07:05:03.000Z" title="2021/12/29 下午3:05:03">2021-12-29</time>更新</span><span class="level-item">7 分钟读完 (大约1034个字)</span></div></div><div class="content"><h1 id="4001-JDK中的ThreadPoolExecutor"><a href="#4001-JDK中的ThreadPoolExecutor" class="headerlink" title="4001-JDK中的ThreadPoolExecutor"></a>4001-JDK中的ThreadPoolExecutor</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/13G4Vs5Kcy9yrwYsX2yoiQ">https://mp.weixin.qq.com/s/13G4Vs5Kcy9yrwYsX2yoiQ</a></p>
</blockquote>
<h2 id="一、内容概述"><a href="#一、内容概述" class="headerlink" title="一、内容概述"></a>一、内容概述</h2><p>首先描述了ThreadPoolExecutor的构造流程以及内部状态管理的机理，随后用大量篇幅深入源码探究了ThreadPoolExecutor线程分配、任务处理、拒绝策略、启动停止等过程，其中对Worker内置类进行重点分析，内容不仅包含其工作原理，更对其设计思路进行了一定分析。文章内容既包含了源码流程分析，还具有设计思路探讨和二次开发实践。</p>
<p><img src="/../images/image-20211229144419379.png" alt="image-20211229144419379"></p>
<h2 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h2><h3 id="2-1-构造函数参数"><a href="#2-1-构造函数参数" class="headerlink" title="2.1 构造函数参数"></a>2.1 构造函数参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>corePoolSize</strong>：核心线程数。提交任务时，当线程池中的线程数 小于 corePoolSize 时，会 新 创建一个核心线程执行任务。当线程数 等于 corePoolSize 时，会将任务 添加进任务队列。</li>
<li><strong>maximumPoolSize</strong>：最大线程数。提交任务时，当 任务队列已满 并且线程池中的总线程数 不大于 maximumPoolSize 时，线程池会令非核心线程执行提交的任务。当 大于 maximumPoolSize 时，会执行拒绝策略。</li>
<li><strong>keepAliveTime</strong>：非核心线程 空闲时 的存活时间。</li>
<li><strong>unit</strong>：keepAliveTime 的单位。</li>
<li><strong>workQueue</strong>：任务队列（阻塞队列）。</li>
<li><strong>threadFactory</strong>：线程工厂。线程池用来新创建线程的工厂类。</li>
<li><strong>handler</strong>：拒绝策略，线程池遇到无法处理的情况时会执行该拒绝策略选择抛弃或忽略任务等。</li>
</ol>
<h3 id="2-3-常用线程池"><a href="#2-3-常用线程池" class="headerlink" title="2.3 常用线程池"></a>2.3 常用线程池</h3><p>在进入 ThreadPoolExecutor 的源码分析前，我们先介绍下常用的线程池（其实并不常用，只是JDK自带了）。这些线程池可由 Executors 这个工具类（或叫线程池工厂）来创建。</p>
<p><strong>2.3.1 FixedThreadPool</strong></p>
<p>固定线程数线程池的创建方式如下：其中核心线程数与最大线程数固定且相等，采用以链表为底层结构的无界阻塞队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>核心线程数与最大线程数相等，因此不会创建空闲线程。keepAliveTime 设置与否无关紧要。</li>
<li>采用无界队列，任务会被无限添加，直至内存溢出（OOM）。</li>
<li>由于无界队列不可能被占满，任务在执行前不可能被拒绝（前提是线程池一直处于运行状态）。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于线程数固定的场景</li>
<li>适用负载比较重的服务器</li>
</ul>
<p><strong>2.3.2 SingleThreadExecutor</strong></p>
<p>单线程线程池的创建方式如下：其中核心线程数与最大线程数都为1，采用以链表为底层结构的无界阻塞队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<ul>
<li>与 FixedThreadPool 类似，只是线程数为1而已。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>适用单线程的场景。</li>
<li>适用于对提交任务的处理有顺序性要求的场景。</li>
</ul>
<p><strong>2.3.3 CachedThreadPool</strong></p>
<p>缓冲线程池的创建方式如下：其中核心线程数为0，最大线程数为Integer.MAX_VALUE（可以理解为无穷大）。采用同步阻塞队列。</p>
<p>- </p>
<p><strong>特点</strong>：</p>
<ul>
<li>核心线程数为0，则初始就创建空闲线程，并且空闲线程的只能等待任务60s，60s内没有提交任务，空闲线程将被销毁。</li>
<li>最大线程数为无穷大，这样会造成巨量线程同时运行，CPU负载过高，导致应用崩溃。</li>
<li>采用同步阻塞队列，即队列不存储任务。提交一个消费一个。由于最大线程数为无穷大，因此，只要提交任务就一定会被消费（应用未崩溃前）。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于耗时短、异步的小程序。</li>
<li>适用于负载较轻的服务器。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-28T10:06:35.000Z" title="2021/12/28 下午6:06:35">2021-12-28</time>发表</span><span class="level-item"><time dateTime="2021-12-28T10:06:35.000Z" title="2021/12/28 下午6:06:35">2021-12-28</time>更新</span><span class="level-item">3 分钟读完 (大约460个字)</span></div></div><div class="content"><h1 id="Spring-OXM实践"><a href="#Spring-OXM实践" class="headerlink" title="Spring OXM实践"></a>Spring OXM实践</h1><blockquote>
<p>示例代码仓库： <a target="_blank" rel="noopener" href="https://gitee.com/tonygeli/springoxmdemo">https://gitee.com/tonygeli/springoxmdemo</a></p>
</blockquote>
<h3 id="OXMapper是什么？"><a href="#OXMapper是什么？" class="headerlink" title="OXMapper是什么？"></a>OXMapper是什么？</h3><p>Spring3.0的一个新特性是O&#x2F;XMapper。O&#x2F;X映射器这个概念并不新鲜，O代表Object，X代表XML。它的目的是在Java对象（POJO）和XML文档之间来回转换。</p>
<h3 id="用途？"><a href="#用途？" class="headerlink" title="用途？"></a>用途？</h3><p>将Java对象转换为一个XML文档</p>
<p>要利用Spring的O&#x2F;X功能，您需要一个在Java对象和XML之间来回转换的实用程序。Castor就是这样一个流行的第三方工具，本文将使用这个工具。其他这样的工具包括XMLBeans、JavaArchitectureforXMLBinding(JAXB)、JiBX和XStream。</p>
<p>SpringO&#x2F;X框架只定义两个接口：Marshaller编组和Unmarshaller解组，它们用于执行O&#x2F;X功能，这是使用这个框架的另一个重大好处。这些接口的实现完全对独立开发人员开放，开发人员可以轻松切换它们而无需修改代码。例如，如果您一开始使用Castor进行O&#x2F;X转换，但后来发现它缺乏您需要的某个功能，这时您可以切换到XMLBeans而无需任何代码更改。唯一需要做的就是更改Spring配置文件以使用新的O&#x2F;X框架。</p>
<h3 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-oxm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.thoughtworks.xstream<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xstream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>AppConfig.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XStreamMarshaller <span class="title function_">XStreamMarshaller</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XStreamMarshaller</span> <span class="variable">xStreamMarshaller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStreamMarshaller</span>();</span><br><span class="line">        xStreamMarshaller.setSupportedClasses(Company.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// com.thoughtworks.xstream.security.ForbiddenClassException</span></span><br><span class="line">        <span class="type">AnyTypePermission</span> <span class="variable">anyTypePermission</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnyTypePermission</span>();</span><br><span class="line">        xStreamMarshaller.setTypePermissions(anyTypePermission);</span><br><span class="line">        <span class="keyword">return</span> xStreamMarshaller;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">annoCtx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        annoCtx.register(AppConfig.class);</span><br><span class="line">        annoCtx.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">XStreamMarshaller</span> <span class="variable">xStreamMarshaller</span> <span class="operator">=</span> annoCtx.getBean(XStreamMarshaller.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>();</span><br><span class="line">        company.setId(<span class="number">100</span>);</span><br><span class="line">        company.setCompanyName(<span class="string">&quot;PQR&quot;</span>);</span><br><span class="line">        company.setCeoName(<span class="string">&quot;MNO&quot;</span>);</span><br><span class="line">        company.setNoEmp(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        xStreamMarshaller.marshal(company, <span class="keyword">new</span> <span class="title class_">StreamResult</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;company.xml&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;marshal success&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Company</span> <span class="variable">outputCompany</span> <span class="operator">=</span> (Company) xStreamMarshaller.unmarshal(<span class="keyword">new</span> <span class="title class_">StreamSource</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;company.xml&quot;</span>)));</span><br><span class="line">        System.out.println(outputCompany);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-28T07:52:05.000Z" title="2021/12/28 下午3:52:05">2021-12-28</time>发表</span><span class="level-item"><time dateTime="2021-12-28T07:52:05.000Z" title="2021/12/28 下午3:52:05">2021-12-28</time>更新</span><span class="level-item">1 分钟读完 (大约219个字)</span></div></div><div class="content"><h2 id="1-1Spring的整体框架"><a href="#1-1Spring的整体框架" class="headerlink" title="1.1Spring的整体框架"></a>1.1Spring的整体框架</h2><p>1.1.1Core Container</p>
<pre><code>1. Core、Beans、Context和Expression Language
1. Beans
1. Context
 4. Expression Language
 设置获取属性的值，属性的分配，方法的调用，访问数组上下文
</code></pre>
<p>1.1.2Data Access&#x2F;Integration</p>
<pre><code>1. JDBC模块提供了JDBC抽象层
1. ORM模块为流行的对象-关系映射API，如JPA、Hibernate、iBatis。Spring框架插入了若干个ORM框架，从而提供了ORM的对象关系工具，其中包含JDO、Hibernate和IBatisSQL Map。
1. OXM模块提供了一个对Objext、XML隐射实现的抽象层，隐射包括JAXB、Castor、XMLBeans、JiBX和XStream。
1. JMS Java Messaging Service模块提供了制造和消费消息的特性。
1. Transaction模块支持编程和声明性的事务管理，这些事务类必须实现特定的接口，并且对所有POJO都适用。
</code></pre>
<p>1.1.3Web</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-20T06:07:04.000Z" title="2021/12/20 下午2:07:04">2021-12-20</time>发表</span><span class="level-item"><time dateTime="2021-12-20T06:07:04.000Z" title="2021/12/20 下午2:07:04">2021-12-20</time>更新</span><span class="level-item">1 分钟读完 (大约141个字)</span></div></div><div class="content"><p>实体、领域服务、限界上下文</p>
<p>学习路线图<br>• 了解DDD可以为你的项目和团队带来哪些好处<br>• 如何确定你的项目是否适合采用DDD<br>• 了解DDD的常见替代方案和它们将导致问题的原因<br>• 学习DDD的基础<br>• 学习如何向你的管理层、领域专家和技术成员推销DDD<br>• 了解使用DDD时所面临的挑战<br>• 看看一个正在学习采用DDD的团队是如何工作的</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-20T05:53:19.000Z" title="2021/12/20 下午1:53:19">2021-12-20</time>发表</span><span class="level-item"><time dateTime="2022-03-28T12:41:04.781Z" title="2022/3/28 下午8:41:04">2022-03-28</time>更新</span><span class="level-item">几秒读完 (大约71个字)</span></div></div><div class="content"><p>木兰词-纳兰性德</p>
<p>人生若只如初见，何事秋风悲画扇。</p>
<p>等闲变却故人心，却道故人心易变。</p>
<p>骊山语罢清宵半，泪雨霖铃终不怨。</p>
<p>何如薄幸锦衣郎，比翼连枝当日愿。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-10T03:41:27.000Z" title="2021/12/10 上午11:41:27">2021-12-10</time>发表</span><span class="level-item"><time dateTime="2021-12-10T03:41:27.000Z" title="2021/12/10 上午11:41:27">2021-12-10</time>更新</span><span class="level-item">1 分钟读完 (大约214个字)</span></div></div><div class="content"><p>夯实基础<br>《深入理解计算机系统》–700页<br>《计算机网络》–500页（可能节选着看，不会看全部）<br>《Java编程思想》（重读，看的会稍微快一些） –800页<br>技术架构<br>《可伸缩服务架构》–550页<br>《大型网站技术架构》–200页<br>《大型网站系统与Java中间件实践》–350页<br>《亿级流量网站架构核心技术》–450页<br>深入Java<br>《Java性能优化权威指南》–550页<br>《Java性能权威指南》–300页<br>《揭秘Java虚拟机》–700页<br>《EffectiveJava》第三版（重读，看的会稍微快一些）–300页<br>《重构 改善既有代码的设计》–400页<br>《MyBatis技术内幕》–400页<br>《Java并发编程之美》–350页</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-09T03:49:15.000Z" title="2021/12/9 上午11:49:15">2021-12-09</time>发表</span><span class="level-item"><time dateTime="2021-12-09T03:49:15.000Z" title="2021/12/9 上午11:49:15">2021-12-09</time>更新</span><span class="level-item">1 分钟读完 (大约150个字)</span></div></div><div class="content"><p>通过npm安装Vue CLI</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"></span><br><span class="line">vue create electron-vue</span><br><span class="line">&gt; Vue CLI v4.5.15</span><br><span class="line">&gt; Vue 3.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Installing-Electron-into-your-Vue-Application"><a href="#Installing-Electron-into-your-Vue-Application" class="headerlink" title="Installing Electron into your Vue Application"></a>Installing Electron into your Vue Application</h3><p>After creating our Vue project, let’s now install Electron in our Vue project using the following commands:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev electron@latest</span><br></pre></td></tr></table></figure>

<p>By using the <code>--save-dev</code> switch, Electron will be installed as a development dependency in your project.</p>
<p><code>&quot;electron&quot;: &quot;^16.0.4&quot;</code></p>
<h3 id="Bootstrapping-the-Electron-App"><a href="#Bootstrapping-the-Electron-App" class="headerlink" title="Bootstrapping the Electron App"></a>Bootstrapping the Electron App</h3><p>After installing Electron, you need to add some code to bootstrap your Electron app and create a GUI window where the Vue app will be opened.</p>
<p>Go ahead and create a <code>main.js</code> file inside your Vue project and add the following code:</p>
<p><a target="_blank" rel="noopener" href="https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-124092">https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-124092</a>   16h<br><a target="_blank" rel="noopener" href="https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-127197">https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-127197</a> 8h<br><a target="_blank" rel="noopener" href="https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-127198">https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-127198</a>   8h</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-29T08:27:21.000Z" title="2021/11/29 下午4:27:21">2021-11-29</time>发表</span><span class="level-item"><time dateTime="2022-03-15T13:13:09.588Z" title="2022/3/15 下午9:13:09">2022-03-15</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-29T08:06:16.000Z" title="2021/11/29 下午4:06:16">2021-11-29</time>发表</span><span class="level-item"><time dateTime="2021-11-29T08:06:16.000Z" title="2021/11/29 下午4:06:16">2021-11-29</time>更新</span><span class="level-item">9 分钟读完 (大约1366个字)</span></div></div><div class="content"><h1 id="SpringBoot监听器源码分析"><a href="#SpringBoot监听器源码分析" class="headerlink" title="SpringBoot监听器源码分析"></a>SpringBoot监听器源码分析</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/woshilijiuyi/article/details/82805649">SpringBoot监听器源码分析</a></p>
</blockquote>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>springBoot监听器的主要分为两类：</p>
<p>1）运行时监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Run Listeners</span><br><span class="line"></span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br></pre></td></tr></table></figure>

<p>2）上下文监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line"></span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</span><br><span class="line">org.springframework.boot.context.FileEncodingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.ConfigFileApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationListener,\</span><br><span class="line">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\</span><br><span class="line">org.springframework.boot.logging.ClasspathLoggingApplicationListener,\</span><br><span class="line">org.springframework.boot.logging.LoggingApplicationListener</span><br></pre></td></tr></table></figure>

<p>注意：springBoot运行时监听器作用是用来触发springBoot上下文监听器，再根据各监听器监听的事件进行区分。<br>上面默认监听器的作用如下：</p>
<h3 id="监听器触发"><a href="#监听器触发" class="headerlink" title="监听器触发"></a>监听器触发</h3><p>启动流程前面两篇已经有详细分析，所以本篇我们只看监听器相关逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">  <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line">  <span class="comment">//获取启动监听器的监听器 - 这里创建了一个关键类：SpringApplicationRunListeners。</span></span><br><span class="line">  <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">  <span class="comment">//用该监听器来启动所有监听器</span></span><br><span class="line">  listeners.started();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(</span><br><span class="line">      args);</span><br><span class="line">    context = createAndRefreshContext(listeners, applicationArguments);</span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line">    listeners.finished(context, <span class="literal">null</span>);</span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)</span><br><span class="line">        .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, listeners, ex);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SpringApplicationRunListeners</code>这是一个封装工具类，封装了所有的启动类监听器。默认只有一个实例，这里封装成List<SpringApplicationRunListener> listeners，主要是方便我们扩展，我们可以定义自己的启动类监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动类监听器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SpringApplicationRunListener&gt; listeners;</span><br><span class="line"></span><br><span class="line">SpringApplicationRunListeners(Log log,</span><br><span class="line">        Collection&lt;? <span class="keyword">extends</span> <span class="title class_">SpringApplicationRunListener</span>&gt; listeners) &#123;</span><br><span class="line">    <span class="built_in">this</span>.log = log;</span><br><span class="line">    <span class="built_in">this</span>.listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SpringApplicationRunListener&gt;(listeners);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动上下文事件监听</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">started</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="built_in">this</span>.listeners) &#123;</span><br><span class="line">        listener.started();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//environment准备完毕事件监听</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="built_in">this</span>.listeners) &#123;</span><br><span class="line">        listener.environmentPrepared(environment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//spring上下文准备完毕事件监听</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="built_in">this</span>.listeners) &#123;</span><br><span class="line">        listener.contextPrepared(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文配置类加载事件监听</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="built_in">this</span>.listeners) &#123;</span><br><span class="line">        listener.contextLoaded(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文构造完成事件监听</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="built_in">this</span>.listeners) &#123;</span><br><span class="line">        callFinishedListener(listener, context, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在前面的启动流程源码分析中介绍过，这些方法会在合适的时间点触发执行，然后广播出不同的事件。</p>
<p>跟进去EventPublishingRunListener:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">EventPublishingRunListener</span><span class="params">(SpringApplication application, String[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.application = application;</span><br><span class="line">    <span class="built_in">this</span>.args = args;</span><br><span class="line">    <span class="comment">//spring事件机制通用的事件发布类</span></span><br><span class="line">    <span class="built_in">this</span>.multicaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.multicaster.addApplicationListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面会默认创建全局的事件发布工具类SimpleApplicationEventMulticaster。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">started</span><span class="params">()</span> &#123;</span><br><span class="line">	publishEvent(<span class="keyword">new</span> <span class="title class_">ApplicationStartedEvent</span>(<span class="built_in">this</span>.application, <span class="built_in">this</span>.args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ApplicationEnvironmentPreparedEvent</span>(<span class="built_in">this</span>.application, <span class="built_in">this</span>.args, environment));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    registerApplicationEventMulticaster(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : <span class="built_in">this</span>.application.getListeners()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">            ((ApplicationContextAware) listener).setApplicationContext(context);</span><br><span class="line">        &#125;</span><br><span class="line">        context.addApplicationListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ApplicationPreparedEvent</span>(<span class="built_in">this</span>.application, <span class="built_in">this</span>.args, context));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;</span><br><span class="line">    publishEvent(getFinishedEvent(context, exception));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出每个方法都会发布不同的事件，所有的事件统一继承SpringApplicationEvent：</p>
<h3 id="事件广播"><a href="#事件广播" class="headerlink" title="事件广播"></a>事件广播</h3><p>继续跟进事件广播方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">  multicastEvent(event, resolveDefaultEventType(event));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="comment">//根据事件类型选取需要通知的监听器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="comment">//获取线程池，如果为null，则同步执行</span></span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    invokeListener(listener, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重点来看一下根据类型获取监听器：<code>getApplicationListeners(event, type)</code><br>跟进该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners(</span><br><span class="line">            ResolvableType eventType, Class&lt;?&gt; sourceType, ListenerRetriever retriever) &#123; </span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    <span class="comment">//根据类型匹配监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : listeners) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsEvent(listener, eventType, sourceType)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">                retriever.applicationListeners.add(listener);</span><br><span class="line">            &#125;</span><br><span class="line">            allListeners.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(allListeners);</span><br><span class="line">    <span class="keyword">return</span> allListeners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面省去了一些不相关代码，继续跟进：<code>supportsEvent(listener, eventType, sourceType)：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supportsEvent</span><span class="params">(ApplicationListener&lt;?&gt; listener, ResolvableType eventType, Class&lt;?&gt; sourceType)</span> &#123;</span><br><span class="line">        <span class="comment">//判断监听器是否是 GenericApplicationListener 的子类，如果不是就返回一个GenericApplicationListenerAdapter</span></span><br><span class="line">        <span class="type">GenericApplicationListener</span> <span class="variable">smartListener</span> <span class="operator">=</span> (listener <span class="keyword">instanceof</span> GenericApplicationListener ?</span><br><span class="line">                (GenericApplicationListener) listener : <span class="keyword">new</span> <span class="title class_">GenericApplicationListenerAdapter</span>(listener));</span><br><span class="line">        <span class="keyword">return</span> (smartListener.supportsEventType(eventType) &amp;&amp; smartListener.supportsSourceType(sourceType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericApplicationListener</span> <span class="keyword">extends</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationEvent&gt;, Ordered &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">supportsEventType</span><span class="params">(ResolvableType eventType)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">supportsSourceType</span><span class="params">(Class&lt;?&gt; sourceType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又出现一个关键类：GenericApplicationListener,该类是 spring 提供的用于重写匹配监听器事件的接口。<br>就是说如果需要判断的监听器是GenericApplicationListener的子类，说明类型匹配方法已被重现，就调用子类的匹配方法。如果不是，则为我们提供一个默认的适配器用来匹配：GenericApplicationListenerAdapter：</p>
<p>继续跟进该类的supportsEventType(ResolvableType eventType)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsEventType</span><span class="params">(ResolvableType eventType)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.delegate <span class="keyword">instanceof</span> SmartApplicationListener) &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; eventClass = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt;) eventType.getRawClass();</span><br><span class="line">    <span class="keyword">return</span> ((SmartApplicationListener) <span class="built_in">this</span>.delegate).supportsEventType(eventClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.declaredEventType == <span class="literal">null</span> || <span class="built_in">this</span>.declaredEventType.isAssignableFrom(eventType));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到该类最终调用的是declaredEventType.isAssignableFrom(eventType)方法，也就是说，如果我们没有重写监听器匹配方法，那么发布的事件 event 会被监听 event以及监听event的父类的监听器监听到。</p>
<h3 id="自定义监听器"><a href="#自定义监听器" class="headerlink" title="自定义监听器"></a>自定义监听器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">GenericApplicationListener</span>,ApplicationListener&lt;ApplicationEvent&gt; &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;myApplistener execute...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsEventType</span><span class="params">(ResolvableType eventType)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsSourceType</span><span class="params">(Class&lt;?&gt; sourceType)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面supportsEventType和supportsSourceType是预留的扩展方法，这里全部为true，也就意味着监听所有的ApplicationEvent事件，方法会执行多次：</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>springBoot</code>整体框架就是通过该监听器<code>org.springframework.boot.SpringApplicationRunListeners</code>，来触发上下文监听器。通过上下文监听器来完成整体逻辑，比如加载配置文件，加载配置类，初始化日志环境等。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/4/">上一页</a></div><div class="pagination-next"><a href="/page/6/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link is-current" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/15/">15</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Tonygeli"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tonygeli</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SH</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">146</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tonygeli" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">时间管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6/"><span class="level-start"><span class="level-item">读书</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bean/"><span class="tag">Bean</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus/"><span class="tag">Icarus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySql/"><span class="tag">MySql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Netty/"><span class="tag">Netty</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stream/"><span class="tag">Stream</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"><span class="tag">公众号</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><span class="tag">分布式事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><span class="tag">单点登录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"><span class="tag">自动装配</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-10T06:58:05.176Z">2022-05-10</time></p><p class="title"><a href="/2022/05/10/3.%E8%AF%BB%E4%B9%A6/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%97%B6%E9%97%B4/">职场上如何管理时间</a></p><p class="categories"><a href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/">时间管理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-09T06:10:31.715Z">2022-05-09</time></p><p class="title"><a href="/2022/05/09/15000%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4/15030k8s-Master/">Kubernetes架构与工作流程及核心概念</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-08T15:13:17.249Z">2022-05-08</time></p><p class="title"><a href="/2022/05/08/213Linux/13001Linux%E5%91%BD%E4%BB%A4lsof/">Linux虚拟文件系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-08T13:02:44.791Z">2022-05-08</time></p><p class="title"><a href="/2022/05/08/3.%E8%AF%BB%E4%B9%A6/Kubernetes%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/">Kubernetes从入门到实践</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-07T01:46:49.745Z">2022-05-07</time></p><p class="title"><a href="/2022/05/07/90000%E6%96%87%E7%AB%A0/90012Bean%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E7%A5%9E%E5%99%A8Mapstruct/">自动转换神器 Mapstruct</a></p><p class="categories"><a href="/categories/Spring/">Spring</a></p></div></article></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a><p class="is-size-7"><span>&copy; 2022 Tonygeli</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>