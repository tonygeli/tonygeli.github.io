<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>LILAIQUN</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LILAIQUN"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LILAIQUN"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="LILAIQUN"><meta property="og:url" content="https://tonygeli.github.io/"><meta property="og:site_name" content="LILAIQUN"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tonygeli.github.io/img/og_image.png"><meta property="article:author" content="Tonygeli"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonygeli.github.io"},"headline":"LILAIQUN","image":["https://tonygeli.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tonygeli"},"publisher":{"@type":"Organization","name":"LILAIQUN","logo":{"@type":"ImageObject","url":"https://tonygeli.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-10T02:15:12.000Z" title="2022/3/10 上午10:15:12">2022-03-10</time>发表</span><span class="level-item"><time dateTime="2022-03-10T02:15:12.000Z" title="2022/3/10 上午10:15:12">2022-03-10</time>更新</span><span class="level-item">2 分钟读完 (大约279个字)</span></div></div><div class="content"><p>[TOC]</p>
<h4 id="1-网络："><a href="#1-网络：" class="headerlink" title="1.网络："></a>1.网络：</h4><ul>
<li>局域网</li>
<li>城域网</li>
<li>广域网</li>
</ul>
<h4 id="2-计算机网络体系结构"><a href="#2-计算机网络体系结构" class="headerlink" title="2.计算机网络体系结构"></a>2.计算机网络体系结构</h4><p>​	各层的关系：每一层建立在低一层的服务上，并为高一层提供服务</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
</ul>
<p>TCP&#x2F;IP协议族</p>
<p><img src="/../images/image-20201107195657654.png" alt="image-20201107195657654"></p>
<h4 id="3-端口号"><a href="#3-端口号" class="headerlink" title="3.端口号"></a>3.端口号</h4><p>FTP&#x3D;21,SSH&#x3D;22,SMTP&#x3D;25,HTTP服务器&#x3D;80,FTP&#x3D;2000,HTTP客户端&#x3D;2001<br>总共65535个端口号</p>
<h4 id="4-什么是TCP"><a href="#4-什么是TCP" class="headerlink" title="4.什么是TCP"></a>4.什么是TCP</h4><p><strong>TCP基本特性：</strong> Transmission Control Protocol</p>
<ul>
<li>面向连接</li>
<li>可靠性</li>
<li>RTT和RTO (Round trip time传输来回的时间 RTO重传时间)</li>
<li>数据排序</li>
<li>流量控制</li>
<li>全双工</li>
</ul>
<h4 id="5-SYN洪泛攻击"><a href="#5-SYN洪泛攻击" class="headerlink" title="5.SYN洪泛攻击"></a>5.SYN洪泛攻击</h4><p>发送伪造的攻击报文，造成服务端上的半开连接队列被占满，阻止其他用户进行访问。</p>
<p>原理：第一次握手，而服务端的响应（第二次握手）的报文将永远发送不到真实的客户端，客户端在等待第三次握手，服务器在这种半开的连接中消耗了资源。</p>
<p>解决方案：</p>
<ul>
<li>无效连接监控释放</li>
<li>延缓TCB分配方法</li>
<li>防火墙</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-08T08:54:16.000Z" title="2022/3/8 下午4:54:16">2022-03-08</time>发表</span><span class="level-item"><time dateTime="2022-03-08T08:54:16.000Z" title="2022/3/8 下午4:54:16">2022-03-08</time>更新</span><span class="level-item">1 分钟读完 (大约159个字)</span></div></div><div class="content"><h2 id="Gateway基本介绍"><a href="#Gateway基本介绍" class="headerlink" title="Gateway基本介绍"></a>Gateway基本介绍</h2><h3 id="什么是API网关？"><a href="#什么是API网关？" class="headerlink" title="什么是API网关？"></a>什么是API网关？</h3><p>主要起到隔离外部访问与内部系统的作用。解决访问认证、报文转换、访问统计等问题。随着微服务架构概念的提出，API网关成为了微服务架构的一个标配组件。</p>
<p><img src="/../images/image-20220308160345562.png" alt="image-20220308160345562"></p>
<p><img src="/../images/image-20220308160722336.png" alt="image-20220308160722336"></p>
<p><img src="/../images/image-20220308160927021.png" alt="image-20220308160927021"></p>
<p><img src="/../images/image-20220308161038785.png" alt="image-20220308161038785"></p>
<p><img src="/../images/image-20220308161157603.png" alt="image-20220308161157603"></p>
<p><img src="/../images/image-20220308161341389.png" alt="image-20220308161341389"></p>
<p><img src="/../images/image-20220308162518349.png" alt="image-20220308162518349"></p>
<p><img src="/../images/image-20220308162721668.png" alt="image-20220308162721668"></p>
<p><img src="/../images/image-20220308163118695.png" alt="image-20220308163118695"></p>
<p><img src="/../images/image-20220308163245430.png" alt="image-20220308163245430"></p>
<p><img src="/../images/image-20220308163454317.png" alt="image-20220308163454317"></p>
<p><img src="/../images/image-20220308163512428.png" alt="image-20220308163512428"></p>
<p><img src="/../images/image-20220308163633162.png" alt="image-20220308163633162"></p>
<p><img src="/../images/image-20220308164251369.png" alt="image-20220308164251369"></p>
<p><img src="/../images/image-20220308164656761.png" alt="image-20220308164656761"></p>
<p><img src="/../images/image-20220308164808946.png" alt="image-20220308164808946"></p>
<p><img src="/../images/image-20220308164952151.png" alt="image-20220308164952151"></p>
<p><img src="/../images/image-20220308165039964.png" alt="image-20220308165039964"></p>
<p><img src="/../images/image-20220308165414760.png" alt="image-20220308165414760"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-08T07:53:04.000Z" title="2022/3/8 下午3:53:04">2022-03-08</time>发表</span><span class="level-item"><time dateTime="2022-03-08T07:53:04.000Z" title="2022/3/8 下午3:53:04">2022-03-08</time>更新</span><span class="level-item">3 分钟读完 (大约407个字)</span></div></div><div class="content"><h2 id="ZK的命名服务、配置管理、集群管理"><a href="#ZK的命名服务、配置管理、集群管理" class="headerlink" title="ZK的命名服务、配置管理、集群管理"></a>ZK的命名服务、配置管理、集群管理</h2><h3 id="命名服务："><a href="#命名服务：" class="headerlink" title="命名服务："></a>命名服务：</h3><p>通过指定的名字来获取资源或者服务地址。Zookeeper可以创建一个全局唯一的路径，这个路径就可以作为一个名字。被命名的实体可以是集群中的机器，服务的地址，或者是远程的对象等。一些分布式服务框架（RPC、RMI）中的服务地址列表，通过使用命名服务，客户端应用能够根据特定的名字来获取资源的实体、服务地址和提供者信息等</p>
<h3 id="配置管理："><a href="#配置管理：" class="headerlink" title="配置管理："></a>配置管理：</h3><p>实际项目开发中，经常使用.properties或者xml需要配置很多信息，如数据库连接信息、fps地址端口等等。程序分布式部署时，如果把程序的这些配置信息保存在zk的znode节点下，当你需要修改配置，即znode会发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知各个客户端，从而更改配置。</p>
<h3 id="集群管理："><a href="#集群管理：" class="headerlink" title="集群管理："></a>集群管理：</h3><p>集群管理包含集群监控和集群控制，就是监控集群机器状态，剔除机器和加入机器。实时监控znode节点的变化，一旦返现机器宕机，该机器就会与zk断开链接，对应的临时目录节点会被删除，其他机器都收到通知，新机器加入也是类似。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-08T06:52:22.000Z" title="2022/3/8 下午2:52:22">2022-03-08</time>发表</span><span class="level-item"><time dateTime="2022-03-08T06:52:22.000Z" title="2022/3/8 下午2:52:22">2022-03-08</time>更新</span><span class="level-item">3 分钟读完 (大约481个字)</span></div></div><div class="content"><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>Zookeeper专门设计的一种支持崩溃恢复的原子广播协议，实现分布式数据一致性。</p>
<p>ZK是CP，放弃高可用</p>
<h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><p>Leader节点处理所有事务请求，Leader将客户端的事务请求转换成事务Proposal，并且将Proposal分发给集群中其他所有的Follower。</p>
<p>完成广播后，等待Follower反馈，当有过半数的Follower反馈信息后，Leader将再次向集群中Follower广播Commit信息，Commit信息就是确认之前的Proposal提交。</p>
<p>Leader节点的写入是一个两步操作，第一步是广播事务操作，第二步是广播提交操作。</p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><ul>
<li>初始化机器，刚刚启动的时候</li>
<li>Leader崩溃，故障宕机</li>
<li>Leader失去半数的机器支持，与集群超过一般的节点断连</li>
</ul>
<p>此时开启新一轮Leader选举，选举产生的Leader会与过半的Follower进行同步，使数据一致，当过半的机器同步完成后，就退出恢复模式，进入消息广播模式</p>
<p><strong>Zxid</strong>是Zab协议的一个事务编号，64位数字，低32是单调递增计数器，针对客户端每一个事务请求，计数器+1，高32位代表Leader周期年代编号。</p>
<p>Leader周期（epoch）可以理解成当前集群所处的年代或者周期，每当有一个新的Leader选举出现，就会从这个Leader服务器上取出其本地日志中最大事务的Zxid，并从中读取epoch值，然后+1，以此作为新的周期ID，高32位代表了每代Leader唯一性，低32位事务的唯一性。</p>
<h3 id="Zab节点的三种状态："><a href="#Zab节点的三种状态：" class="headerlink" title="Zab节点的三种状态："></a>Zab节点的三种状态：</h3><p>following：服从leader的命令</p>
<p>leading：负责协调事务</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-08T06:24:32.000Z" title="2022/3/8 下午2:24:32">2022-03-08</time>发表</span><span class="level-item"><time dateTime="2022-03-08T06:24:32.000Z" title="2022/3/8 下午2:24:32">2022-03-08</time>更新</span><span class="level-item">3 分钟读完 (大约407个字)</span></div></div><div class="content"><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p>XA规范：分布式事务规范，定义了分布式事务模型</p>
<p>四个角色：事务管理器、资源管理器、应用程序AP、通信资源管理器CRM</p>
<p>全局事务：一个横跨多个数据库的事务，要不全提交，要不全回滚</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>第一阶段：prepare：每个参与执行本地事务但不提交，进入ready状态，并通知协调者已经准备就绪。</p>
<p>第二阶段commint：当协调者确认每个参与者都ready后，通知参与者进行commit操作；如有参与者fail，则发送rollback命令，各参与者做回滚。</p>
<p>问题：</p>
<ul>
<li>单点故障：一旦事务管理器出现故障，整个系统不可用</li>
<li>数据不一致：在二阶段，如果事务管理器只发送部分commit消息，只有部分参与者提交了事务，使得系统数据不一致</li>
<li>响应时间长：参与者资源都被锁，提交、回滚才释放</li>
<li>不确定性：部分参与者commit，事务管理器宕机，新管理器无法确定消息是否成功</li>
</ul>
<h3 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h3><p>解决2PC单点故障问题，性能和不一致问题没有根本解决</p>
<p>超时机制（可用性提高）：如果消息执行成功，如果一定时间没收到DoCommit消息，自己执行DoCommit操作</p>
<p>TCC（补偿事务）：Try、Confirm、Cancel</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-08T02:20:11.000Z" title="2022/3/8 上午10:20:11">2022-03-08</time>发表</span><span class="level-item"><time dateTime="2022-03-08T02:20:11.000Z" title="2022/3/8 上午10:20:11">2022-03-08</time>更新</span><span class="level-item">6 分钟读完 (大约846个字)</span></div></div><div class="content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>1.<strong>解释下对象的创建过程</strong></p>
<p>分配空间 初始化 引用赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;T&gt;		<span class="comment">// 分配空间</span></span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="number">4</span> invokespecial #<span class="number">3</span> &lt;T.&lt;init&gt;&gt;	<span class="comment">// 初始化</span></span><br><span class="line"><span class="number">7</span> astore_1			<span class="comment">// 引用赋值</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>2.DCL单例 double check lock 到底需不需要volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(Mg.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 没加volatile 指令重排后，先引用赋值</span></span><br><span class="line"><span class="comment">      * INSTANCE != null</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      INSTANCE = <span class="keyword">new</span> <span class="title class_">Mg</span>();			 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br></pre></td></tr></table></figure>

<p>3.对象在内存中的存储布局</p>
<ul>
<li>1.Markword                           8B</li>
<li>2.Class pointer类型指针        4B</li>
<li>3.instance data示例对象</li>
<li>4.padding 对齐</li>
</ul>
<p>4.对象头信息</p>
<p>5.对象怎么定位</p>
<p>6.对象怎么分配</p>
<p>7.内存多少字节</p>
<p>new Object(); 16字节</p>
<h3 id="1-最顶级的异常类是什么，什么情况下会用到，他的子类有什么，error什么时候会用到"><a href="#1-最顶级的异常类是什么，什么情况下会用到，他的子类有什么，error什么时候会用到" class="headerlink" title="1.最顶级的异常类是什么，什么情况下会用到，他的子类有什么，error什么时候会用到"></a>1.最顶级的异常类是什么，什么情况下会用到，他的子类有什么，error什么时候会用到</h3><p>**<em>*Throwable*<em>：</em></em> 有两个重要的子类：Exception（异常）和 Error（错误）</p>
<p>**<em>*Error（错误）*</em>:**是程序无法处理的错误  OutOfMemoryError</p>
<p>**<em>*Exception（异常）*</em>:**是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException </p>
<h3 id="2-java语法糖有了解吗"><a href="#2-java语法糖有了解吗" class="headerlink" title="2.java语法糖有了解吗"></a>2.java语法糖有了解吗</h3><p><strong>自动装箱与拆箱</strong></p>
<p><strong>可变参数</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... strs)</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++)  </span><br><span class="line">        System.out.println(strs[i]); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="7-新生代和老年代的比例大小，怎么设置老年代的比例"><a href="#7-新生代和老年代的比例大小，怎么设置老年代的比例" class="headerlink" title="7.新生代和老年代的比例大小，怎么设置老年代的比例"></a>7.新生代和老年代的比例大小，怎么设置老年代的比例</h3><p>-Xmx 最大堆内存</p>
<p>-Xms 最小堆内存</p>
<p>-XX:SurvivorRatio 设置eden:from:to的比例 默认是8 实际默认并不一定</p>
<p>-XX:NewRatio 新生代与老年代的比率 默认是2，老年代是新生代的2倍</p>
<p>非堆空间也是持久代，方法区，jdk8以后的元数据区。</p>
<p>-XX:PermSize 初始永久代的大小</p>
<p>-XX:MaxPermSize 最大永久代的大小 注意永久代就是通常指的方法区，保存类信息，常量表等，在jdk8中已经废弃了永久代，而是用元数据去代取，默认的非常大可以用：</p>
<p>持久代的空间与我们的类的大小有很大的关系，类加载后放着持久代，如果不是频繁使用动态字节码技术、发射、OSGI等技术，持久代的大小基本上可以预估的，测试环境是多少，上线后基本没有差别。</p>
<p>-XX:<strong>MaxMetaspaceSize</strong>配置最大元数据区的大小</p>
<h3 id="8-jvm怎么查看内存占用情况"><a href="#8-jvm怎么查看内存占用情况" class="headerlink" title="8.jvm怎么查看内存占用情况"></a>8.jvm怎么查看内存占用情况</h3><p>9.aqs<br>10.synchronized的底层原理，它是可重入锁吗。怎么实现可重入锁</p>
<p>13.有a,b,c三列，建了一个 组合索引，和在a上建了索引。现在查询a&#x3D;？.会选择哪个索引<br>14.mysql有哪些约束<br>15.innodb默认的事务隔离级别，要做分布式事务，最高能到哪个隔离级别<br>16.tcp三次握手，tcp协议是在网络链路哪一层<br>17.http头部有哪些参数<br>18.hashmap1.8的改动。写出123456的红黑树<br>19.集合中有哪些有序的集合<br>20.linkedhashmap和treemap的区别</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>程序结束，直接中断。不可访问固有资源，因为可能随时中断</p>
<p><code>Thread.setDaemon()</code></p>
<h3 id="ThreadLocal原理与场景"><a href="#ThreadLocal原理与场景" class="headerlink" title="ThreadLocal原理与场景"></a>ThreadLocal原理与场景</h3><p>1.对象跨层传递，避免多次传递<br>2.线程间数据隔离<br>3.事务操作，存储线程事务信息<br>4.数据库连接，session会话管理</p>
<p>内存泄漏原因：</p>
<p>weakreference无论内存是否足够，都会被回收</p>
<p>强软弱虚  </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-21T15:33:37.985Z" title="2022/2/21 下午11:33:37">2022-02-21</time>发表</span><span class="level-item"><time dateTime="2022-02-21T15:36:44.506Z" title="2022/2/21 下午11:36:44">2022-02-21</time>更新</span><span class="level-item">几秒读完 (大约12个字)</span></div></div><div class="content"><h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><h3 id="一、Validator参数校验器"><a href="#一、Validator参数校验器" class="headerlink" title="一、Validator参数校验器"></a>一、Validator参数校验器</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-21T07:41:16.000Z" title="2022/2/21 下午3:41:16">2022-02-21</time>发表</span><span class="level-item"><time dateTime="2022-02-21T07:41:16.000Z" title="2022/2/21 下午3:41:16">2022-02-21</time>更新</span><span class="level-item">20 分钟读完 (大约3073个字)</span></div></div><div class="content"><h1 id="2-1-2-线程安全"><a href="#2-1-2-线程安全" class="headerlink" title="2.1.2 线程安全"></a>2.1.2 线程安全</h1><p><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">什么是线程安全</a><br><a href="#%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">解决线程安全</a><br>    <a href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97">方法一：使用synchronized关键字</a><br>    <a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8Lock%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB">方法二：使用Lock接口下的实现类</a><br>    <a href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8ThreadLocal">方法三：使用线程本地存储ThreadLocal</a><br>    <a href="#%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%B9%90%E8%A7%82%E9%94%81%E6%9C%BA%E5%88%B6">方法四：使用乐观锁机制</a></p>
<h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>什么是线程安全呢？什么样的情况会造成线程安全问题呢？怎么解决线程安全呢？这些问题都是在下文中所要讲述的。</p>
<p><strong>线程安全：</strong>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p>
<p>那什么时候会造成线程安全问题呢？当多个线程同时去访问一个对象时，就可能会出现线程安全问题。那么怎么解决呢？请往下看！</p>
<h2 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h2><p>在这里提供4种方法来解决线程安全问题，也是最常用的4种方法。前提是项目在一个服务器中，如果是分布式项目可能就会用到分布锁了，这个就放到后面文章来详谈了。</p>
<p>讲4种方法前，还是先来了解一下悲观锁和乐观锁吧！</p>
<p>悲观锁，顾名思义它是悲观的。讲得通俗点就是，认为自己在使用数据的时候，一定有别的线程来修改数据，因此在获取数据的时候先加锁，确保数据不会被线程修改。形象理解就是总觉得有刁民想害朕。</p>
<p>而乐观锁就比较乐观了，认为在使用数据时，不会有别的线程来修改数据，就不会加锁，只是在更新数据的时候去判断之前有没有别的线程来更新了数据。具体用法在下面讲解。</p>
<p>现在来看有那<strong>4种方法</strong>吧！</p>
<h3 id="方法一：使用synchronized关键字"><a href="#方法一：使用synchronized关键字" class="headerlink" title="方法一：使用synchronized关键字"></a>方法一：使用synchronized关键字</h3><p>一个表现为原生语法层面的互斥锁，它是一种悲观锁，使用它的时候我们一般需要一个监听对象 并且监听对象必须是唯一的，通常就是当前类的字节码对象。它是JVM级别的，不会造成死锁的情况。使用synchronized可以拿来修饰类，静态方法，普通方法和代码块。比如：Hashtable类就是使用synchronized来修饰方法的。put方法部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;		<span class="comment">// Make sure the value is not null</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<p>而ConcurrentHashMap类中就是使用synchronized来锁代码块的。</p>
<p>synchronized关键字底层实现主要是通过monitorenter 与monitorexit计数 ，如果计数器不为0，说明资源被占用，其他线程就不能访问了，但是可重入的除外。说到这，就来讲讲什么是可重入的。这里其实就是指的可重入锁：指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响，执行对象中所有同步方法不用再次获得锁。避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。</p>
<p>其实在使用synchronized时，存在一个锁升级原理。它是指在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。锁升级的目的是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。可能你又会问什么是偏向锁？什么是轻量级锁？什么是重量级锁？这里就简单描述一下吧，能够帮你更好的理解synchronized。</p>
<p>偏向锁（无锁）：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后（线程的id会记录在对象的Mark Word中），消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</p>
<p>轻量级锁（CAS）：就是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；轻量级锁的意图是在没有多线程竞争的情况下，通过CAS操作尝试将MarkWord更新为指向LockRecord的指针，减少了使用重量级锁的系统互斥量产生的性能消耗。</p>
<p>重量级锁：虚拟机使用CAS操作尝试将MarkWord更新为指向LockRecord的指针，如果更新成功表示线程就拥有该对象的锁；如果失败，会检查MarkWord是否指向当前线程的栈帧，如果是，表示当前线程已经拥有这个锁；如果不是，说明这个锁被其他线程抢占，此时膨胀为重量级锁。</p>
<h3 id="方法二：使用Lock接口下的实现类"><a href="#方法二：使用Lock接口下的实现类" class="headerlink" title="方法二：使用Lock接口下的实现类"></a>方法二：使用Lock接口下的实现类</h3><p>Lock是juc（java.util.concurrent）包下面的一个接口。常用的实现类就是ReentrantLock 类，它其实也是一种悲观锁。一种表现为 API 层面的互斥锁。通过lock() 和 unlock() 方法配合使用。因此也可以说是一种手动锁，使用比较灵活。但是使用这个锁时一定要注意要释放锁，不然就会造成死锁。一般配合try&#x2F;finally 语句块来完成。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketThreadSafe</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">      <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">               lock.lock();</span><br><span class="line">               <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName()+<span class="string">&quot;你的票号是&quot;</span>+num--);</span><br><span class="line">               &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">              &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                 lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比 synchronized，ReentrantLock 增加了一些高级功能，主要有以下 3 项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p>
<p>等待可中断是指：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</p>
<p>公平锁是指：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> </span><br><span class="line">	sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br></pre></td></tr></table></figure>

<p>锁绑定多个条件是指：一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123; <span class="comment">//ConditionObject是Condition的实现类</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="方法三：使用线程本地存储ThreadLocal"><a href="#方法三：使用线程本地存储ThreadLocal" class="headerlink" title="方法三：使用线程本地存储ThreadLocal"></a>方法三：使用线程本地存储ThreadLocal</h3><p>当多个线程操作同一个变量且互不干扰的场景下，可以使用ThreadLocal来解决。它会在每个线程中对该变量创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。通过set(T value)方法给线程的局部变量设置值；get()获取线程局部变量中的值。当给线程绑定一个 Object 内容后，只要线程不变,就可以随时取出；改变线程,就无法取出内容.。这里提供一个用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                  ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();</span><br><span class="line">                  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                        local.set(++a);   <span class="comment">//子线程对a的操作不会影响主线程中的a</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                              Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">&quot;子线程：&quot;</span>+local.get());</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            a = <span class="number">22</span>;</span><br><span class="line">            ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();</span><br><span class="line">            local.set(a);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                  System.out.println(<span class="string">&quot;主线程：&quot;</span>+local.get());</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>ThreadLocal线程容器保存变量时，底层其实是通过ThreadLocalMap来实现的。它是以当前ThreadLocal变量为key ，要存的变量为value。获取的时候就是以当前ThreadLocal变量去找到对应的key，然后获取到对应的值。源码参考如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">   <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">   <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">   <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">   		map.set(<span class="built_in">this</span>, value);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals; <span class="comment">//ThreadLocal.ThreadLocalMap threadLocals = null;Thread类中声明的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察源码就会发现，其实每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
<p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找即可。</p>
<h3 id="方法四：使用乐观锁机制"><a href="#方法四：使用乐观锁机制" class="headerlink" title="方法四：使用乐观锁机制"></a>方法四：使用乐观锁机制</h3><p>前面已经讲述了什么是乐观锁。这里就来描述哈在java开发中怎么使用的。</p>
<p>其实在表设计的时候，我们通常就需要往表里加一个version字段。每次查询时，查出带有version的数据记录，更新数据时，判断数据库里对应id的记录的version是否和查出的version相同。若相同，则更新数据并把版本号+1；若不同，则说明，该数据发生了并发，被别的线程使用了，进行递归操作，再次执行递归方法，直到成功更新数据为止。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-16T13:01:11.000Z" title="2022/2/16 下午9:01:11">2022-02-16</time>发表</span><span class="level-item"><time dateTime="2022-02-16T13:01:11.000Z" title="2022/2/16 下午9:01:11">2022-02-16</time>更新</span><span class="level-item">5 分钟读完 (大约711个字)</span></div></div><div class="content"><h1 id="主从延迟"><a href="#主从延迟" class="headerlink" title="主从延迟"></a>主从延迟</h1><h2 id="一、常见的主从架构"><a href="#一、常见的主从架构" class="headerlink" title="一、常见的主从架构"></a>一、常见的主从架构</h2><ul>
<li>一主一从</li>
<li>一主多从</li>
<li>多主一从</li>
<li>双主复制</li>
<li>级联复制</li>
</ul>
<h2 id="二、主从同步原理"><a href="#二、主从同步原理" class="headerlink" title="二、主从同步原理"></a>二、主从同步原理</h2><ul>
<li><p>binlog（二进制日志文件）</p>
</li>
<li><p>relay log（中继日志文件）</p>
</li>
</ul>
<p><img src="/../images/image-20220216203727511.png" alt="image-20220216203727511"></p>
<h4 id="主从同步过程"><a href="#主从同步过程" class="headerlink" title="主从同步过程"></a>主从同步过程</h4><ul>
<li>从库生成两个线程，一个I&#x2F;O线程，一个SQL线程；</li>
<li>i&#x2F;o线程去请求主库的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中；</li>
<li>主库会生成一个 log dump 线程，用来给从库 i&#x2F;o线程传binlog</li>
<li>SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；</li>
</ul>
<h2 id="三、如何判断主从是否延时"><a href="#三、如何判断主从是否延时" class="headerlink" title="三、如何判断主从是否延时"></a>三、如何判断主从是否延时</h2><p>通过监控 show slave status 命令输出的Seconds_Behind_Master参数的值来判断：</p>
<ul>
<li>NULL，表示io_thread或是sql_thread有任何一个发生故障</li>
<li>0，该值为零，表示主从复制良好</li>
<li>正值，表示主从已经出现延时，数字越大表示从库延迟越严重</li>
</ul>
<p><img src="/../images/image-20220216204001336.png" alt="image-20220216204001336"></p>
<h2 id="四、主从延迟原因"><a href="#四、主从延迟原因" class="headerlink" title="四、主从延迟原因"></a>四、主从延迟原因</h2><h4 id="随机重放"><a href="#随机重放" class="headerlink" title="随机重放"></a>随机重放</h4><p>MySQL的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高。Slave的SQL Thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序的，成本高很多。所以SQL Thread线程的速度赶不上主库学binlog的速度，就会产生主从延迟</p>
<h4 id="锁等待"><a href="#锁等待" class="headerlink" title="锁等待"></a>锁等待</h4><p>另一方面，由于SQL Thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL Thread所能处理的速度，或者当slave中有大型query语句产生了锁等待那么延时就产生了。</p>
<h2 id="五、主从延迟解决办法"><a href="#五、主从延迟解决办法" class="headerlink" title="五、主从延迟解决办法"></a>五、主从延迟解决办法</h2><h4 id="并行复制"><a href="#并行复制" class="headerlink" title="并行复制"></a>并行复制</h4><p>既然 SQL 单线程进行重放时速度有限，那么能不能采用多线程的方式来进行重放呢？MySQL 5.6 版本后，提供了一种并行复制的方式，通过将 SQL 线程转换为多个 work 线程来进行重放，这样就解决了主从延迟的问题</p>
<p><img src="/../images/640-5016434" alt="图片"></p>
<h4 id="降低并发"><a href="#降低并发" class="headerlink" title="降低并发"></a>降低并发</h4><p>如果你理解了随机重放这个导致主从延迟的原因，那么就比较好理解了，控制主库写入的速度，主从延迟发生的概率自然就小了。</p>
<h4 id="读主库"><a href="#读主库" class="headerlink" title="读主库"></a>读主库</h4><p>如果你做的是类似支付这种对实时性要求非常高的业务，那么最直接的方法就是直接读主库。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-15T07:25:45.000Z" title="2022/2/15 下午3:25:45">2022-02-15</time>发表</span><span class="level-item"><time dateTime="2022-02-15T07:25:45.000Z" title="2022/2/15 下午3:25:45">2022-02-15</time>更新</span><span class="level-item">几秒读完 (大约9个字)</span></div></div><div class="content"><h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p><img src="/../images/image-20220215152331507.png" alt="image-20220215152331507"></p>
<p><img src="/../images/image-20220215152448093.png" alt="image-20220215152448093"></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">上一页</a></div><div class="pagination-next"><a href="/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/15/">15</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Tonygeli"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tonygeli</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SH</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">147</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tonygeli" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux%E5%91%BD%E4%BB%A4/"><span class="level-start"><span class="level-item">Linux命令</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">时间管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6/"><span class="level-start"><span class="level-item">读书</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bean/"><span class="tag">Bean</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus/"><span class="tag">Icarus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySql/"><span class="tag">MySql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Netty/"><span class="tag">Netty</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stream/"><span class="tag">Stream</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"><span class="tag">公众号</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><span class="tag">分布式事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><span class="tag">单点登录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"><span class="tag">自动装配</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-10T14:21:17.411Z">2022-05-10</time></p><p class="title"><a href="/2022/05/10/213Linux/13002Linux%E5%91%BD%E4%BB%A4find/">Linux命令find</a></p><p class="categories"><a href="/categories/Linux%E5%91%BD%E4%BB%A4/">Linux命令</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-10T06:58:05.176Z">2022-05-10</time></p><p class="title"><a href="/2022/05/10/3.%E8%AF%BB%E4%B9%A6/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%97%B6%E9%97%B4/">职场上如何管理时间</a></p><p class="categories"><a href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/">时间管理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-09T06:10:31.715Z">2022-05-09</time></p><p class="title"><a href="/2022/05/09/15000%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4/15030k8s-Master/">Kubernetes架构与工作流程及核心概念</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-08T15:13:17.249Z">2022-05-08</time></p><p class="title"><a href="/2022/05/08/213Linux/13001Linux%E5%91%BD%E4%BB%A4lsof/">Linux虚拟文件系统</a></p><p class="categories"><a href="/categories/Linux%E5%91%BD%E4%BB%A4/">Linux命令</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-08T13:02:44.791Z">2022-05-08</time></p><p class="title"><a href="/2022/05/08/3.%E8%AF%BB%E4%B9%A6/Kubernetes%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/">Kubernetes从入门到实践</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></p></div></article></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a><p class="is-size-7"><span>&copy; 2022 Tonygeli</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>