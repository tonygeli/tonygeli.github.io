<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>LILAIQUN</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LILAIQUN"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LILAIQUN"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="LILAIQUN"><meta property="og:url" content="https://tonygeli.github.io/"><meta property="og:site_name" content="LILAIQUN"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tonygeli.github.io/img/og_image.png"><meta property="article:author" content="Tonygeli"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonygeli.github.io"},"headline":"LILAIQUN","image":["https://tonygeli.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tonygeli"},"publisher":{"@type":"Organization","name":"LILAIQUN","logo":{"@type":"ImageObject","url":"https://tonygeli.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-08T02:20:11.000Z" title="2022/3/8 上午10:20:11">2022-03-08</time>发表</span><span class="level-item"><time dateTime="2022-03-08T02:20:11.000Z" title="2022/3/8 上午10:20:11">2022-03-08</time>更新</span><span class="level-item">6 分钟读完 (大约846个字)</span></div></div><div class="content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>1.<strong>解释下对象的创建过程</strong></p>
<p>分配空间 初始化 引用赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;T&gt;		<span class="comment">// 分配空间</span></span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="number">4</span> invokespecial #<span class="number">3</span> &lt;T.&lt;init&gt;&gt;	<span class="comment">// 初始化</span></span><br><span class="line"><span class="number">7</span> astore_1			<span class="comment">// 引用赋值</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>2.DCL单例 double check lock 到底需不需要volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(Mg.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 没加volatile 指令重排后，先引用赋值</span></span><br><span class="line"><span class="comment">      * INSTANCE != null</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      INSTANCE = <span class="keyword">new</span> <span class="title class_">Mg</span>();			 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br></pre></td></tr></table></figure>

<p>3.对象在内存中的存储布局</p>
<ul>
<li>1.Markword                           8B</li>
<li>2.Class pointer类型指针        4B</li>
<li>3.instance data示例对象</li>
<li>4.padding 对齐</li>
</ul>
<p>4.对象头信息</p>
<p>5.对象怎么定位</p>
<p>6.对象怎么分配</p>
<p>7.内存多少字节</p>
<p>new Object(); 16字节</p>
<h3 id="1-最顶级的异常类是什么，什么情况下会用到，他的子类有什么，error什么时候会用到"><a href="#1-最顶级的异常类是什么，什么情况下会用到，他的子类有什么，error什么时候会用到" class="headerlink" title="1.最顶级的异常类是什么，什么情况下会用到，他的子类有什么，error什么时候会用到"></a>1.最顶级的异常类是什么，什么情况下会用到，他的子类有什么，error什么时候会用到</h3><p>**<em>*Throwable*<em>：</em></em> 有两个重要的子类：Exception（异常）和 Error（错误）</p>
<p>**<em>*Error（错误）*</em>:**是程序无法处理的错误  OutOfMemoryError</p>
<p>**<em>*Exception（异常）*</em>:**是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException </p>
<h3 id="2-java语法糖有了解吗"><a href="#2-java语法糖有了解吗" class="headerlink" title="2.java语法糖有了解吗"></a>2.java语法糖有了解吗</h3><p><strong>自动装箱与拆箱</strong></p>
<p><strong>可变参数</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... strs)</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++)  </span><br><span class="line">        System.out.println(strs[i]); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="7-新生代和老年代的比例大小，怎么设置老年代的比例"><a href="#7-新生代和老年代的比例大小，怎么设置老年代的比例" class="headerlink" title="7.新生代和老年代的比例大小，怎么设置老年代的比例"></a>7.新生代和老年代的比例大小，怎么设置老年代的比例</h3><p>-Xmx 最大堆内存</p>
<p>-Xms 最小堆内存</p>
<p>-XX:SurvivorRatio 设置eden:from:to的比例 默认是8 实际默认并不一定</p>
<p>-XX:NewRatio 新生代与老年代的比率 默认是2，老年代是新生代的2倍</p>
<p>非堆空间也是持久代，方法区，jdk8以后的元数据区。</p>
<p>-XX:PermSize 初始永久代的大小</p>
<p>-XX:MaxPermSize 最大永久代的大小 注意永久代就是通常指的方法区，保存类信息，常量表等，在jdk8中已经废弃了永久代，而是用元数据去代取，默认的非常大可以用：</p>
<p>持久代的空间与我们的类的大小有很大的关系，类加载后放着持久代，如果不是频繁使用动态字节码技术、发射、OSGI等技术，持久代的大小基本上可以预估的，测试环境是多少，上线后基本没有差别。</p>
<p>-XX:<strong>MaxMetaspaceSize</strong>配置最大元数据区的大小</p>
<h3 id="8-jvm怎么查看内存占用情况"><a href="#8-jvm怎么查看内存占用情况" class="headerlink" title="8.jvm怎么查看内存占用情况"></a>8.jvm怎么查看内存占用情况</h3><p>9.aqs<br>10.synchronized的底层原理，它是可重入锁吗。怎么实现可重入锁</p>
<p>13.有a,b,c三列，建了一个 组合索引，和在a上建了索引。现在查询a&#x3D;？.会选择哪个索引<br>14.mysql有哪些约束<br>15.innodb默认的事务隔离级别，要做分布式事务，最高能到哪个隔离级别<br>16.tcp三次握手，tcp协议是在网络链路哪一层<br>17.http头部有哪些参数<br>18.hashmap1.8的改动。写出123456的红黑树<br>19.集合中有哪些有序的集合<br>20.linkedhashmap和treemap的区别</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>程序结束，直接中断。不可访问固有资源，因为可能随时中断</p>
<p><code>Thread.setDaemon()</code></p>
<h3 id="ThreadLocal原理与场景"><a href="#ThreadLocal原理与场景" class="headerlink" title="ThreadLocal原理与场景"></a>ThreadLocal原理与场景</h3><p>1.对象跨层传递，避免多次传递<br>2.线程间数据隔离<br>3.事务操作，存储线程事务信息<br>4.数据库连接，session会话管理</p>
<p>内存泄漏原因：</p>
<p>weakreference无论内存是否足够，都会被回收</p>
<p>强软弱虚  </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-21T15:33:37.985Z" title="2022/2/21 下午11:33:37">2022-02-21</time>发表</span><span class="level-item"><time dateTime="2022-02-21T15:36:44.506Z" title="2022/2/21 下午11:36:44">2022-02-21</time>更新</span><span class="level-item">几秒读完 (大约12个字)</span></div></div><div class="content"><h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><h3 id="一、Validator参数校验器"><a href="#一、Validator参数校验器" class="headerlink" title="一、Validator参数校验器"></a>一、Validator参数校验器</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-21T07:41:16.000Z" title="2022/2/21 下午3:41:16">2022-02-21</time>发表</span><span class="level-item"><time dateTime="2022-02-21T07:41:16.000Z" title="2022/2/21 下午3:41:16">2022-02-21</time>更新</span><span class="level-item">20 分钟读完 (大约3073个字)</span></div></div><div class="content"><h1 id="2-1-2-线程安全"><a href="#2-1-2-线程安全" class="headerlink" title="2.1.2 线程安全"></a>2.1.2 线程安全</h1><p><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">什么是线程安全</a><br><a href="#%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">解决线程安全</a><br>    <a href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97">方法一：使用synchronized关键字</a><br>    <a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8Lock%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB">方法二：使用Lock接口下的实现类</a><br>    <a href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8ThreadLocal">方法三：使用线程本地存储ThreadLocal</a><br>    <a href="#%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%B9%90%E8%A7%82%E9%94%81%E6%9C%BA%E5%88%B6">方法四：使用乐观锁机制</a></p>
<h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>什么是线程安全呢？什么样的情况会造成线程安全问题呢？怎么解决线程安全呢？这些问题都是在下文中所要讲述的。</p>
<p><strong>线程安全：</strong>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p>
<p>那什么时候会造成线程安全问题呢？当多个线程同时去访问一个对象时，就可能会出现线程安全问题。那么怎么解决呢？请往下看！</p>
<h2 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h2><p>在这里提供4种方法来解决线程安全问题，也是最常用的4种方法。前提是项目在一个服务器中，如果是分布式项目可能就会用到分布锁了，这个就放到后面文章来详谈了。</p>
<p>讲4种方法前，还是先来了解一下悲观锁和乐观锁吧！</p>
<p>悲观锁，顾名思义它是悲观的。讲得通俗点就是，认为自己在使用数据的时候，一定有别的线程来修改数据，因此在获取数据的时候先加锁，确保数据不会被线程修改。形象理解就是总觉得有刁民想害朕。</p>
<p>而乐观锁就比较乐观了，认为在使用数据时，不会有别的线程来修改数据，就不会加锁，只是在更新数据的时候去判断之前有没有别的线程来更新了数据。具体用法在下面讲解。</p>
<p>现在来看有那<strong>4种方法</strong>吧！</p>
<h3 id="方法一：使用synchronized关键字"><a href="#方法一：使用synchronized关键字" class="headerlink" title="方法一：使用synchronized关键字"></a>方法一：使用synchronized关键字</h3><p>一个表现为原生语法层面的互斥锁，它是一种悲观锁，使用它的时候我们一般需要一个监听对象 并且监听对象必须是唯一的，通常就是当前类的字节码对象。它是JVM级别的，不会造成死锁的情况。使用synchronized可以拿来修饰类，静态方法，普通方法和代码块。比如：Hashtable类就是使用synchronized来修饰方法的。put方法部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;		<span class="comment">// Make sure the value is not null</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<p>而ConcurrentHashMap类中就是使用synchronized来锁代码块的。</p>
<p>synchronized关键字底层实现主要是通过monitorenter 与monitorexit计数 ，如果计数器不为0，说明资源被占用，其他线程就不能访问了，但是可重入的除外。说到这，就来讲讲什么是可重入的。这里其实就是指的可重入锁：指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响，执行对象中所有同步方法不用再次获得锁。避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。</p>
<p>其实在使用synchronized时，存在一个锁升级原理。它是指在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。锁升级的目的是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。可能你又会问什么是偏向锁？什么是轻量级锁？什么是重量级锁？这里就简单描述一下吧，能够帮你更好的理解synchronized。</p>
<p>偏向锁（无锁）：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后（线程的id会记录在对象的Mark Word中），消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</p>
<p>轻量级锁（CAS）：就是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；轻量级锁的意图是在没有多线程竞争的情况下，通过CAS操作尝试将MarkWord更新为指向LockRecord的指针，减少了使用重量级锁的系统互斥量产生的性能消耗。</p>
<p>重量级锁：虚拟机使用CAS操作尝试将MarkWord更新为指向LockRecord的指针，如果更新成功表示线程就拥有该对象的锁；如果失败，会检查MarkWord是否指向当前线程的栈帧，如果是，表示当前线程已经拥有这个锁；如果不是，说明这个锁被其他线程抢占，此时膨胀为重量级锁。</p>
<h3 id="方法二：使用Lock接口下的实现类"><a href="#方法二：使用Lock接口下的实现类" class="headerlink" title="方法二：使用Lock接口下的实现类"></a>方法二：使用Lock接口下的实现类</h3><p>Lock是juc（java.util.concurrent）包下面的一个接口。常用的实现类就是ReentrantLock 类，它其实也是一种悲观锁。一种表现为 API 层面的互斥锁。通过lock() 和 unlock() 方法配合使用。因此也可以说是一种手动锁，使用比较灵活。但是使用这个锁时一定要注意要释放锁，不然就会造成死锁。一般配合try&#x2F;finally 语句块来完成。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketThreadSafe</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">      <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">               lock.lock();</span><br><span class="line">               <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName()+<span class="string">&quot;你的票号是&quot;</span>+num--);</span><br><span class="line">               &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">              &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                 lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比 synchronized，ReentrantLock 增加了一些高级功能，主要有以下 3 项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p>
<p>等待可中断是指：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</p>
<p>公平锁是指：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> </span><br><span class="line">	sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br></pre></td></tr></table></figure>

<p>锁绑定多个条件是指：一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123; <span class="comment">//ConditionObject是Condition的实现类</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="方法三：使用线程本地存储ThreadLocal"><a href="#方法三：使用线程本地存储ThreadLocal" class="headerlink" title="方法三：使用线程本地存储ThreadLocal"></a>方法三：使用线程本地存储ThreadLocal</h3><p>当多个线程操作同一个变量且互不干扰的场景下，可以使用ThreadLocal来解决。它会在每个线程中对该变量创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。通过set(T value)方法给线程的局部变量设置值；get()获取线程局部变量中的值。当给线程绑定一个 Object 内容后，只要线程不变,就可以随时取出；改变线程,就无法取出内容.。这里提供一个用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                  ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();</span><br><span class="line">                  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                        local.set(++a);   <span class="comment">//子线程对a的操作不会影响主线程中的a</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                              Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">&quot;子线程：&quot;</span>+local.get());</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            a = <span class="number">22</span>;</span><br><span class="line">            ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();</span><br><span class="line">            local.set(a);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                  System.out.println(<span class="string">&quot;主线程：&quot;</span>+local.get());</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>ThreadLocal线程容器保存变量时，底层其实是通过ThreadLocalMap来实现的。它是以当前ThreadLocal变量为key ，要存的变量为value。获取的时候就是以当前ThreadLocal变量去找到对应的key，然后获取到对应的值。源码参考如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">   <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">   <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">   <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">   		map.set(<span class="built_in">this</span>, value);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals; <span class="comment">//ThreadLocal.ThreadLocalMap threadLocals = null;Thread类中声明的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察源码就会发现，其实每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
<p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找即可。</p>
<h3 id="方法四：使用乐观锁机制"><a href="#方法四：使用乐观锁机制" class="headerlink" title="方法四：使用乐观锁机制"></a>方法四：使用乐观锁机制</h3><p>前面已经讲述了什么是乐观锁。这里就来描述哈在java开发中怎么使用的。</p>
<p>其实在表设计的时候，我们通常就需要往表里加一个version字段。每次查询时，查出带有version的数据记录，更新数据时，判断数据库里对应id的记录的version是否和查出的version相同。若相同，则更新数据并把版本号+1；若不同，则说明，该数据发生了并发，被别的线程使用了，进行递归操作，再次执行递归方法，直到成功更新数据为止。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-16T13:01:11.000Z" title="2022/2/16 下午9:01:11">2022-02-16</time>发表</span><span class="level-item"><time dateTime="2022-02-16T13:01:11.000Z" title="2022/2/16 下午9:01:11">2022-02-16</time>更新</span><span class="level-item">5 分钟读完 (大约711个字)</span></div></div><div class="content"><h1 id="主从延迟"><a href="#主从延迟" class="headerlink" title="主从延迟"></a>主从延迟</h1><h2 id="一、常见的主从架构"><a href="#一、常见的主从架构" class="headerlink" title="一、常见的主从架构"></a>一、常见的主从架构</h2><ul>
<li>一主一从</li>
<li>一主多从</li>
<li>多主一从</li>
<li>双主复制</li>
<li>级联复制</li>
</ul>
<h2 id="二、主从同步原理"><a href="#二、主从同步原理" class="headerlink" title="二、主从同步原理"></a>二、主从同步原理</h2><ul>
<li><p>binlog（二进制日志文件）</p>
</li>
<li><p>relay log（中继日志文件）</p>
</li>
</ul>
<p><img src="/../images/image-20220216203727511.png" alt="image-20220216203727511"></p>
<h4 id="主从同步过程"><a href="#主从同步过程" class="headerlink" title="主从同步过程"></a>主从同步过程</h4><ul>
<li>从库生成两个线程，一个I&#x2F;O线程，一个SQL线程；</li>
<li>i&#x2F;o线程去请求主库的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中；</li>
<li>主库会生成一个 log dump 线程，用来给从库 i&#x2F;o线程传binlog</li>
<li>SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；</li>
</ul>
<h2 id="三、如何判断主从是否延时"><a href="#三、如何判断主从是否延时" class="headerlink" title="三、如何判断主从是否延时"></a>三、如何判断主从是否延时</h2><p>通过监控 show slave status 命令输出的Seconds_Behind_Master参数的值来判断：</p>
<ul>
<li>NULL，表示io_thread或是sql_thread有任何一个发生故障</li>
<li>0，该值为零，表示主从复制良好</li>
<li>正值，表示主从已经出现延时，数字越大表示从库延迟越严重</li>
</ul>
<p><img src="/../images/image-20220216204001336.png" alt="image-20220216204001336"></p>
<h2 id="四、主从延迟原因"><a href="#四、主从延迟原因" class="headerlink" title="四、主从延迟原因"></a>四、主从延迟原因</h2><h4 id="随机重放"><a href="#随机重放" class="headerlink" title="随机重放"></a>随机重放</h4><p>MySQL的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高。Slave的SQL Thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序的，成本高很多。所以SQL Thread线程的速度赶不上主库学binlog的速度，就会产生主从延迟</p>
<h4 id="锁等待"><a href="#锁等待" class="headerlink" title="锁等待"></a>锁等待</h4><p>另一方面，由于SQL Thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL Thread所能处理的速度，或者当slave中有大型query语句产生了锁等待那么延时就产生了。</p>
<h2 id="五、主从延迟解决办法"><a href="#五、主从延迟解决办法" class="headerlink" title="五、主从延迟解决办法"></a>五、主从延迟解决办法</h2><h4 id="并行复制"><a href="#并行复制" class="headerlink" title="并行复制"></a>并行复制</h4><p>既然 SQL 单线程进行重放时速度有限，那么能不能采用多线程的方式来进行重放呢？MySQL 5.6 版本后，提供了一种并行复制的方式，通过将 SQL 线程转换为多个 work 线程来进行重放，这样就解决了主从延迟的问题</p>
<p><img src="/../images/640-5016434" alt="图片"></p>
<h4 id="降低并发"><a href="#降低并发" class="headerlink" title="降低并发"></a>降低并发</h4><p>如果你理解了随机重放这个导致主从延迟的原因，那么就比较好理解了，控制主库写入的速度，主从延迟发生的概率自然就小了。</p>
<h4 id="读主库"><a href="#读主库" class="headerlink" title="读主库"></a>读主库</h4><p>如果你做的是类似支付这种对实时性要求非常高的业务，那么最直接的方法就是直接读主库。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-15T07:25:45.000Z" title="2022/2/15 下午3:25:45">2022-02-15</time>发表</span><span class="level-item"><time dateTime="2022-02-15T07:25:45.000Z" title="2022/2/15 下午3:25:45">2022-02-15</time>更新</span><span class="level-item">几秒读完 (大约9个字)</span></div></div><div class="content"><h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p><img src="/../images/image-20220215152331507.png" alt="image-20220215152331507"></p>
<p><img src="/../images/image-20220215152448093.png" alt="image-20220215152448093"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-10T02:23:17.000Z" title="2022/2/10 上午10:23:17">2022-02-10</time>发表</span><span class="level-item"><time dateTime="2022-02-10T02:23:17.000Z" title="2022/2/10 上午10:23:17">2022-02-10</time>更新</span><span class="level-item">1 小时读完 (大约11204个字)</span></div></div><div class="content"><p>[TOC]</p>
<h1 id="java中你知道哪些锁？"><a href="#java中你知道哪些锁？" class="headerlink" title="java中你知道哪些锁？"></a>java中你知道哪些锁？</h1><p><strong>问题回答</strong></p>
<ol>
<li>乐观锁&#x2F;悲观锁</li>
<li>共享锁&#x2F;独享锁</li>
<li>公平锁&#x2F;非公平锁</li>
<li>互斥锁&#x2F;读写锁</li>
<li>可重入锁</li>
<li>自旋锁</li>
<li>分段锁</li>
<li>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</li>
</ol>
<p><img src="/../../images/3217f442be61462f9fddcdfcd1767cd1.png" alt="2021经典面试—多线程与并发"></p>
<h1 id="Java线程的状态或者生命周期？"><a href="#Java线程的状态或者生命周期？" class="headerlink" title="Java线程的状态或者生命周期？"></a>Java线程的状态或者生命周期？</h1><p><strong>问题回答</strong></p>
<ol>
<li>Java的线程状态被定义在公共枚举类java.lang.Thread.state中。一种有六种状态</li>
</ol>
<ul>
<li>新建（NEW）：表示线程新建出来还没有被启动的状态，比如：Thread t &#x3D; new MyThread();</li>
<li>就绪&#x2F;运行（RUNNABLE）：该状态包含了经典线程模型的两种状态：就绪(Ready)、运行(Running)：</li>
<li>阻塞（BLOCKED）：通常与锁有关系，表示线程正在获取有锁控制的资源，比如进入synchronized代码块，获取ReentryLock等；发起阻塞式IO也会阻塞，比如字符流字节流操作。</li>
<li>等待（WAITING）：线程在等待某种资源就绪。</li>
<li>超时等待（TIMED_WAIT）：线程进入条件和等待类似，但是它调用的是带有超时时间的方法。</li>
<li>终止（TERMINATED）：线程正常退出或异常退出后，就处于终结状态。也可以叫线程的死亡。</li>
</ul>
<h1 id="看下源码"><a href="#看下源码" class="headerlink" title="看下源码"></a>看下源码</h1><p>在Java.lang.Thread里，有个内部枚举: State，一个线程在某一时刻可以是State里的一种状态</p>
<p><img src="/../../images/9e5b83aedf6a4ce7a26f253a15629221.jpeg" alt="2021经典面试—多线程与并发"></p>
<h1 id="看图理解"><a href="#看图理解" class="headerlink" title="看图理解"></a>看图理解</h1><p><img src="/../../images/2ca9d8fc0c7c4efd906b4f5c8c8de23b.png" alt="2021经典面试—多线程与并发"></p>
<p>哪些情况或者方法可以进入等待状态？</p>
<ol>
<li>当一个线程执行了Object.wait()的时候，它一定在等待另一个线程执行Object.notify()或者Object.notifyAll()。</li>
<li>一个线程thread，其在主线程中被执行了thread.join()的时候，主线程即会等待该线程执行完成。</li>
<li>当一个线程执行了LockSupport.park()的时候，其在等待执行LockSupport.unpark(thread)。</li>
</ol>
<h1 id="哪些情况或者方法可以进入超时等待状态？"><a href="#哪些情况或者方法可以进入超时等待状态？" class="headerlink" title="哪些情况或者方法可以进入超时等待状态？"></a>哪些情况或者方法可以进入超时等待状态？</h1><p><strong>问题回答</strong></p>
<p>该状态不同于WAITING，它可以在指定的时间后自行返回</p>
<ol>
<li>Object.wait(long)</li>
<li>Thread.join(long)</li>
<li>LockSupport.parkNanos()</li>
<li>LockSupport.parkUntil()</li>
<li>Thread.sleep(long)</li>
</ol>
<h1 id="synchronized-与lock区别？"><a href="#synchronized-与lock区别？" class="headerlink" title="synchronized 与lock区别？"></a>synchronized 与lock区别？</h1><p><strong>问题回答</strong></p>
<ol>
<li>lock是一个接口，而synchronized是java的一个关键字</li>
<li>synchronized异常会释放锁，lock异常不会释放，所以一般try catch包起来，finally中写入unlock，避免死锁。</li>
<li>Lock可以提高多个线程进行读操作的效率</li>
<li>synchronized关键字，可以放代码块，实例方法，静态方法，类上</li>
<li>lock一般使用ReentrantLock类作为锁，配合lock()和unlock()方法。在finally块中写unlock()以防死锁。</li>
<li>jdk1.6之前synchronized低效。jdk1.6之后synchronized高效。</li>
</ol>
<h1 id="synchronized-与ReentrantLock区别？"><a href="#synchronized-与ReentrantLock区别？" class="headerlink" title="synchronized 与ReentrantLock区别？"></a>synchronized 与ReentrantLock区别？</h1><p><strong>问题回答</strong></p>
<ol>
<li>synchronized依赖JVM实现，ReentrantLock是JDK实现的。synchronized是内置锁，只要在代码开始的地方加synchronized，代码结束会自动释放。Lock必须手动加锁，手动释放锁。</li>
<li>ReenTrantLock比synchronized增加了一些高级功能。synchronized代码量少，自动化，但扩展性低，不够灵活；ReentrantLock扩展性好，灵活，但代码量相对多。</li>
<li>两者都是可重入锁。都是互斥锁。</li>
<li>synchronized是非公平锁，ReentrantLock可以指定是公平锁还是非公平锁。</li>
</ol>
<h1 id="synchronized-与ThreadLocal区别？"><a href="#synchronized-与ThreadLocal区别？" class="headerlink" title="synchronized 与ThreadLocal区别？"></a>synchronized 与ThreadLocal区别？</h1><p><strong>问题回答</strong></p>
<ol>
<li>都是为了解决多线程中相同变量的访问冲突问题。</li>
<li>Synchronized同步机制，提供一份变量，让不同的线程排队访问。</li>
<li>ThreadLocal关键字，为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</li>
<li>ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</li>
</ol>
<p><strong>看代码</strong></p>
<p><img src="/../../images/586fcd6673c54e65934e29a590876351.png" alt="2021经典面试—多线程与并发"></p>
<p><img src="/../../images/806bf51f163f4b0589054491df94e5d2.jpeg" alt="2021经典面试—多线程与并发"></p>
<h1 id="synchronized-与volatile区别？"><a href="#synchronized-与volatile区别？" class="headerlink" title="synchronized 与volatile区别？"></a>synchronized 与volatile区别？</h1><p><strong>问题回答</strong></p>
<ol>
<li>volatile是一个类型修饰符（type specifier）。</li>
<li>volatile，它能够使变量在值发生改变时能尽快地让其他线程知道。</li>
<li>关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且只能修改变量，而synchronized可以修饰方法，以及代码块。</li>
<li>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞</li>
<li>volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步</li>
<li>关键字volatile解决的下变量在多线程之间的可见性；而synchronized解决的是多线程之间资源同步问题</li>
</ol>
<h1 id="Thread类中的start-和run-方法有什么区别"><a href="#Thread类中的start-和run-方法有什么区别" class="headerlink" title="Thread类中的start()和run()方法有什么区别?"></a>Thread类中的start()和run()方法有什么区别?</h1><ol>
<li>通过调用线程类的start()方法来启动一个线程，使线程处于就绪状态，即可以被JVM来调度执行，在调度过程中，JVM通过调用线程类的run()方法来完成实际的业务逻辑，当run()方法结束后，此线程就会终止。</li>
<li>如果直接调用线程类的run()方法，会被当作一个普通的函数调用，程序中仍然只有主线程这一个线程。即start()方法能够异步地调用run()方法，但是直接调用run()方法却是同步的，无法达到多线程的目的。</li>
<li>因此，只有通过调用线程类的start()方法才能达到多线程的目的。</li>
</ol>
<h1 id="事务的隔离级别及引发的问题？"><a href="#事务的隔离级别及引发的问题？" class="headerlink" title="事务的隔离级别及引发的问题？"></a>事务的隔离级别及引发的问题？</h1><p><strong>问题回答</strong></p>
<ol>
<li>4个隔离级别：读未提交、读已提交、可重复读、串行化</li>
<li>分别怎么理解呢？</li>
</ol>
<ul>
<li>读未提交（READ UNCOMMITTED），事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li>读已提交（READ COMMITTED），一个事务能读取已经提交的事务所做的修改，不能读取未提交的事务所做的修改。也就是事务未提交之前，对其他事务不可见。</li>
<li>可重复读（REPEATABLE READ），保证在同一个事务中多次读取同样数据的结果是一样的。</li>
<li>串行化（SERIALIZABLE），强制事务串行执行。</li>
</ul>
<p>3.读已提交是sql server的默认隔离级别。</p>
<p>可重复读是mysql的默认隔离级别。</p>
<p><strong>简要回答</strong></p>
<ol>
<li><p>4个隔离级别，读未提交、读已提交、可重复读、可串行化。</p>
</li>
<li><p>读未提交（READ UNCOMMITTED），事务提交与否都可见，引发脏读、不可重复读、幻读。</p>
</li>
<li><p>读已提交（READ COMMITTED），已提交的事务可见，引发不可重复读、幻读。</p>
</li>
<li><p>可重复读（REPEATABLE READ），多次读取，数据一致，引发幻读。</p>
</li>
<li><p>串行化（SERIALIZABLE），串行执行。</p>
<p><img src="/../../images/5401cf883cdb467b8d85818095445e5e.png" alt="事务隔离级别和引发的问题"></p>
</li>
</ol>
<p>大多数数据库的默认隔离级别为: Read Commited,如Sql Server , Oracle。</p>
<p>少数数据库默认的隔离级别为Repeatable Read, 如MySQL InnoDB存储引擎。</p>
<h1 id="理解脏读、不可重复读、幻读"><a href="#理解脏读、不可重复读、幻读" class="headerlink" title="理解脏读、不可重复读、幻读"></a>理解脏读、不可重复读、幻读</h1><p>脏读：读到未提交的数据。</p>
<p><img src="/../../images/f32ed643c5ad48e0902498e7291f1d58.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>不可重复读：重点是修改，同样的条件, 你读取过的数据, 再次读取出来发现值不一样了。</p>
<p><img src="/../../images/cc7c6e189fd14fe6bb4a74e8e1a2d57f.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>幻读：重点在于新增或者删除，同样的条件, 第1次和第2次读出来的记录数不一样。</p>
<p><img src="/../../images/5a2058424a2f47998caf4cb774876084.jpeg" alt="2021经典面试—多线程与并发"></p>
<h1 id="简单理解4个隔离级别"><a href="#简单理解4个隔离级别" class="headerlink" title="简单理解4个隔离级别"></a>简单理解4个隔离级别</h1><ul>
<li>读未提交，比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交。此时，事务B能够读取事务A操作过程中的未提交的数据（1、2、3、4、5、6…10）。</li>
<li>读已提交，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交。此时，事务B只能读取到最终的10。</li>
<li>可重复读，事务B开始读取到的是某个值是0，事务A对值进行修改提交多次，事务B读取到的依然是0。多次读取，结果一致。</li>
<li>串行化，是最严格的事务隔离级别，它要求所有事务被串行执行，一个事务没有结束，另外的事务没法继续。</li>
</ul>
<h1 id="案列演示"><a href="#案列演示" class="headerlink" title="案列演示"></a>案列演示</h1><p><strong>读未提交</strong></p>
<p><img src="/../../images/e4517fdf17614cf79dace08d87b012a6.png" alt="2021经典面试—多线程与并发"></p>
<p><strong>读已提交</strong></p>
<p><img src="/../../images/054da07d4a9f4494b0523fe06b108ddc.png" alt="2021经典面试—多线程与并发"></p>
<p><strong>可重复读</strong></p>
<p><img src="/../../images/0fb78d0d29e74657b4430e5c30747330.png" alt="2021经典面试—多线程与并发"></p>
<p><strong>串行化</strong></p>
<p><img src="/../../images/b449ffec544746b99f4c219bb277898c.png" alt="2021经典面试—多线程与并发"></p>
<p>串行化1</p>
<h1 id="什么是线程安全，java如何保证线程安全？"><a href="#什么是线程安全，java如何保证线程安全？" class="headerlink" title="什么是线程安全，java如何保证线程安全？"></a>什么是线程安全，java如何保证线程安全？</h1><p><strong>问题回答</strong></p>
<ol>
<li>在多线程环境中，能永远保证程序的正确性。执行结果不存在二义性。说白了，运行多少次结果都是一致的。</li>
<li>换种说法，当多个线程访问某一个类（对象或方法）时，这个类始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。</li>
<li>使用synchronized关键字和使用锁。</li>
</ol>
<h1 id="介绍一下线程池？结果"><a href="#介绍一下线程池？结果" class="headerlink" title="介绍一下线程池？结果"></a>介绍一下线程池？结果</h1><p><strong>问题回答</strong></p>
<ol>
<li>线程池就是预先创建一些线程，它们的集合称为线程池。</li>
<li>线程池可以很好地提高性能，在系统启动时即创建大量空闲的线程，程序将一个task给到线程池，线程池就会启动一条线程来执行这个任务，执行结束后，该线程不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</li>
<li>线程的创建和销毁比较消耗时间，线程池可以避免这个问题。</li>
<li>Executors是jdk1.5之后的一个新类，提供了一些静态方法，帮助我们方便的生成一些常见的线程池</li>
</ol>
<ul>
<li>newSingleThreadExecutor：创建一个单线程化的Executor。</li>
<li>newFixedThreadPool：创建一个固定大小的线程池。</li>
<li>newCachedThreadPool：创建一个可缓存的线程池</li>
<li>newScheduleThreadPool：创建一个定长的线程池，可以周期性执行任务。</li>
</ul>
<p>我们还可以使用ThreadPoolExecutor自己定义线程池，弄懂它的构造参数即可</p>
<ul>
<li>int corePoolSize，&#x2F;&#x2F;核心池的大小</li>
<li>int maximumPoolSize，&#x2F;&#x2F;线程池最大线程数</li>
<li>long keepAliveTime，&#x2F;&#x2F;保持时间&#x2F;额外线程的存活时间</li>
<li>TimeUnit unit，&#x2F;&#x2F;时间单位</li>
<li>BlockingQueue<Runnable> workQueue，&#x2F;&#x2F;任务队列</li>
<li>ThreadFactory threadFactory，&#x2F;&#x2F;线程工厂</li>
<li>RejectedExecutionHandler handler &#x2F;&#x2F;异常的捕捉器</li>
</ul>
<p><strong>简要回答</strong></p>
<ol>
<li>线程池就是预先创建一些线程</li>
<li>线程池可以很好地提高性能</li>
<li>线程池可以避免线程的频繁创建和销毁</li>
<li>Executors可以创建常见的4种线程（单线程池、固定大小的、可缓存的、可周期性执行任务的）。</li>
<li>可以通过ThreadPoolExecutor自己定义线程池。</li>
</ol>
<p><strong>看看Excutors中的方法</strong></p>
<p><img src="/../../images/289984c236f24f4687c85da6a5714b96.png" alt="2021经典面试—多线程与并发"></p>
<p>Excutors中的方法</p>
<p><strong>看看ThreadPoolExecutor的构造函数</strong></p>
<p><img src="/../../images/7acfe86c68a74d83bb3f09b4ca1d5063.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>ThreadPoolExecutor的构造函数</p>
<h1 id="常见的线程池有哪些？"><a href="#常见的线程池有哪些？" class="headerlink" title="常见的线程池有哪些？"></a>常见的线程池有哪些？</h1><p><strong>问题回答</strong></p>
<ol>
<li>Executors是jdk1.5之后的一个新类，提供了一些静态方法，帮助我们方便的生成一些常见的线程池</li>
<li>单线程线程池，通过newSingleThreadExecutor()创建</li>
<li>固定大小的线程池，通过newFixedThreadPool()创建</li>
<li>可缓存的线程池，通过newCachedThreadPool()创建</li>
<li>可周期性执行任务的线程池，通过newScheduleThreadPool()创建</li>
</ol>
<p><strong>看下Excutors的使用</strong></p>
<p><img src="/../../images/3648b15bca0141e3b6923085dfa3c618.png" alt="2021经典面试—多线程与并发"></p>
<p>Excutors的使用</p>
<h1 id="几个线程的区别？"><a href="#几个线程的区别？" class="headerlink" title="几个线程的区别？"></a>几个线程的区别？</h1><p>newCachedThreadPool</p>
<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p><strong>这种类型的线程池特点是：</strong></p>
<ul>
<li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
</ul>
<p>newFixedThreadPool</p>
<p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p>
<p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<p>newSingleThreadExecutor</p>
<p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>
<p>newScheduleThreadPool</p>
<p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p>
<h1 id="同步和异步有何异同？"><a href="#同步和异步有何异同？" class="headerlink" title="同步和异步有何异同？"></a>同步和异步有何异同？</h1><p><strong>问题回答</strong></p>
<ol>
<li>同步发了指令，会等待返回，然后再发送下一个。</li>
<li>异步发了指令，不会等待返回，随时可以再发送下一个请求</li>
<li>同步可以避免出现死锁，读脏数据的发生</li>
<li>异步则是可以提高效率</li>
<li>实现同步的机制主要有临界区、互斥、信号量和事件</li>
</ol>
<p><strong>哪些集合是线程安全？</strong></p>
<p><strong>问题回答</strong></p>
<ol>
<li>Vector：就比Arraylist多了个同步化机制（线程安全）。</li>
<li>Hashtable：就比Hashmap多了个线程安全。</li>
<li>ConcurrentHashMap:是一种高效但是线程安全的集合。</li>
</ol>
<h1 id="如何异步获取多线程返回的数据？"><a href="#如何异步获取多线程返回的数据？" class="headerlink" title="如何异步获取多线程返回的数据？"></a>如何异步获取多线程返回的数据？</h1><h1 id="问题包含"><a href="#问题包含" class="headerlink" title="问题包含"></a>问题包含</h1><p>说一下Callable这个接口的理解？</p>
<p>说一下Future接口的理解？</p>
<p>说一下FutureTask类的理解？</p>
<p>说一下CompletionService接口的理解？</p>
<p><strong>问题回答</strong></p>
<ol>
<li>通过Callable+Future，Callable负责执行返回，Future负责接收。Callable接口对象可以交给ExecutorService的submit方法去执行。</li>
<li>通过Callable+FutureTask，Callable负责执行返回，FutureTask负责接收。FutureTask同时实现了Runnable和Callable接口，可以给到ExecutorService的submit方法和Thread去执行。</li>
<li>通过CompletionService，jdk1.8之后提供了完成服务CompletionService，可以实现这样的需求。</li>
<li>注意，实现Runnable接口任务执行结束后无法获取执行结果。</li>
</ol>
<p><strong>Callable有返回值，Runnable没有返回值</strong></p>
<p><img src="/../../images/925ac13572eb4fcfae5b2d355f546fc8.png" alt="2021经典面试—多线程与并发"></p>
<p>Callable有返回值，Runnable没有返回值</p>
<p><strong>看看Future接口</strong></p>
<p>看看所有方法</p>
<p><img src="/../../images/3f69af409b114351bcb7c4d352161662.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>Future接口方法</p>
<p>重点看看get方法</p>
<p><img src="/../../images/2c2377497a764fa49a19398a5c2f358e.png" alt="2021经典面试—多线程与并发"></p>
<p>get方法</p>
<p><strong>总结下：</strong></p>
<p><strong>V get()</strong> <strong>：</strong>获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</p>
<p><strong>V get(Long timeout , TimeUnit unit)</strong> ：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。</p>
<p><strong>boolean isDone()</strong> ：判断任务是否完成如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。future.isDone()</p>
<p><strong>boolean isCanceller()</strong> <strong>：</strong>如果任务完成前被取消，则返回true。 future.isCanceller()</p>
<p><strong>boolean cancel(boolean mayInterruptRunning)</strong> <strong>：</strong>如果任务还没开始，执行cancel(…)方法将返回false；如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回true；当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false；当任务已经完成，执行cancel(…)方法将返回false。mayInterruptRunning参数表示是否中断执行中的线程。</p>
<p>通过方法分析我们也知道实际上Future提供了3种功能：</p>
<p>（1）能够中断执行中的任务</p>
<p>（2）判断任务是否执行完成</p>
<p>（3）获取任务执行完成后的结果。</p>
<h1 id="看看ExecutorService的submit方法"><a href="#看看ExecutorService的submit方法" class="headerlink" title="看看ExecutorService的submit方法"></a>看看ExecutorService的submit方法</h1><p><img src="/../../images/76b4c5ef24e64f3486f37d92ed1d2974.png" alt="2021经典面试—多线程与并发"></p>
<p>submit方法</p>
<p>注意：</p>
<p>Callable接口的call方法有返回值，Runnable接口的run方法没有返回值</p>
<p>submit（Runnable）：Future&lt;?&gt; ，返回的Future无法获取返回值。submit（Runnable, T）：Future<T>，返回的Future无法获取返回值。</p>
<p><strong>看看FutureTask</strong></p>
<p>看FutureTask定义</p>
<p><img src="/../../images/4c338b5ffdad44f7aab2d302c46dc63d.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>FutureTask定义</p>
<p>看RunnableFuture定义，同时实现了Runnable、Future</p>
<p><img src="/../../images/87f2909220e041bf920bb511fbc54ddd.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>RunnableFuture定义</p>
<p>所以，FutureTask</p>
<p>ExecutorService的submit方法接收Runnable和Callable，所以接收FutureTask。</p>
<p>Thread只支持Runnable，所以也支持FutureTask。FutureTask让Thread也可以有返回值的效果。</p>
<p><strong>看代码</strong></p>
<h1 id="Callable接口配合ExecutorService的submit方法"><a href="#Callable接口配合ExecutorService的submit方法" class="headerlink" title="Callable接口配合ExecutorService的submit方法"></a>Callable接口配合ExecutorService的submit方法</h1><p><img src="/../../images/2e384ae2b2894b87ba6564ac9393808b.png" alt="2021经典面试—多线程与并发"></p>
<p>AsynTask1.java</p>
<p>结果</p>
<p><img src="/../../images/c3586a11023a4bb7b9acbbc2cc057a43.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>结果</p>
<h1 id="Callable接口配合FutureTask，ExecutorService的submit方法去执行"><a href="#Callable接口配合FutureTask，ExecutorService的submit方法去执行" class="headerlink" title="Callable接口配合FutureTask，ExecutorService的submit方法去执行"></a>Callable接口配合FutureTask，ExecutorService的submit方法去执行</h1><p><img src="/../../images/831acac36d7e4695aeb9fb99827861f0.png" alt="2021经典面试—多线程与并发"></p>
<p>AsynTask2.java</p>
<p>结果</p>
<p><img src="/../../images/a5c08166ad9a4abc90cd07ce5462c992.png" alt="2021经典面试—多线程与并发"></p>
<p>结果</p>
<h1 id="Callable接口配合FutureTask，给Thread类去执行"><a href="#Callable接口配合FutureTask，给Thread类去执行" class="headerlink" title="Callable接口配合FutureTask，给Thread类去执行"></a>Callable接口配合FutureTask，给Thread类去执行</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsynTask3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    asynTask3();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程执行完成&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/../../images/931b824d4a3149e4b909163d76767bed.png" alt="2021经典面试—多线程与并发"></p>
<p>AsynTask3.java</p>
<p><img src="/../../images/1050ded7b1b742d088897b0f6b094b7f.png" alt="2021经典面试—多线程与并发"></p>
<p>结果</p>
<h1 id="CompletionService配合Callable"><a href="#CompletionService配合Callable" class="headerlink" title="CompletionService配合Callable"></a>CompletionService配合Callable</h1><p><img src="/../../images/110d09ea14b34a92a03fd3bc1d2196ab.png" alt="2021经典面试—多线程与并发"></p>
<p>AsynTask4</p>
<p>结果</p>
<p><img src="/../../images/c3c1de2f0ce640c7ad66eeaaf3acecc7.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>结果</p>
<h1 id="CompletionService和Future的区别呢？"><a href="#CompletionService和Future的区别呢？" class="headerlink" title="CompletionService和Future的区别呢？"></a>CompletionService和Future的区别呢？</h1><ul>
<li>Future获取结果，一个一个地取，一个取完了，再取另外一个，就会等待</li>
<li>CompletionService，任意一个线程有返回，就立马取出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsynTask5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        asynCompletionService();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------分割线-------------------&quot;</span>);</span><br><span class="line">        asynFuture();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程执行完毕&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">asynCompletionService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用ExecutorService</span></span><br><span class="line">            <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建完成服务</span></span><br><span class="line">            CompletionService&lt;Integer&gt; completionService = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;Integer&gt;(executorService);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//提交任务</span></span><br><span class="line">                completionService.submit(<span class="keyword">new</span> <span class="title class_">HandleFuture</span>&lt;&gt;(i));</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="comment">//获取结果，一个一个阻塞的取出。这中间肯定会浪费一定的时间在等待上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> completionService.take().get();</span><br><span class="line">                System.out.println(<span class="string">&quot;结果：&quot;</span> + result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">asynFuture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用ExecutorService</span></span><br><span class="line">            <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Future列表</span></span><br><span class="line">            List&lt;Future&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//提交任务</span></span><br><span class="line">                Future&lt;Integer&gt; submit = executorService.submit(<span class="keyword">new</span> <span class="title class_">HandleFuture</span>&lt;&gt;(i));</span><br><span class="line">                result.add(submit);</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="comment">//获取结果，输出和线程的放入顺序无关系。每一个线程执行成功后，立刻就输出</span></span><br><span class="line">            <span class="keyword">for</span> (Future&lt;Integer&gt; integerFuture : result) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> integerFuture.get();</span><br><span class="line">                System.out.println(<span class="string">&quot;结果：&quot;</span> + integer);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandleFuture</span>&lt;Integer&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandleFuture</span><span class="params">(Integer num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2</span> * <span class="number">1000l</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="/../../images/81dd746c0a23407ca29a902153fdf729.jpeg" alt="2021经典面试—多线程与并发"></p>
<h1 id="如何自定义线程池？"><a href="#如何自定义线程池？" class="headerlink" title="如何自定义线程池？"></a>如何自定义线程池？</h1><p>corePoolSize：核心池的大小</p>
<ul>
<li>默认情况下，在创建了线程池之后，线程池中的线程数为0</li>
<li>当有任务到来后，如果线程池中存活的线程数小于corePoolSize，则创建一个线程。</li>
</ul>
<p>maximumPoolSize：线程池最大线程数</p>
<ul>
<li>线程池中允许的最大线程数，这个参数表示了线程池中最多能创建的线程数量。</li>
<li>当任务数量比corePoolSize大时，任务添加到workQueue</li>
<li>当workQueue满了，将继续创建线程以处理任务。</li>
<li>maximumPoolSize表示当wordQueue满了，线程池中最多可以创建的线程数量。</li>
</ul>
<p>keepAliveTime：</p>
<ul>
<li>当线程池处于空闲状态时，超过keepAliveTime时间之后，空闲的线程会被终止。</li>
<li>只有当线程池中的线程数大于corePoolSize时，这个参数才会起作用，但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li>
<li>当线程数大于corePoolSize时，如果一个线程的空闲时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。</li>
</ul>
<p>unit：参数keepAliveTime的时间单位，有7种取值</p>
<ul>
<li>TimeUnit.DAYS; &#x2F;&#x2F;天</li>
<li>TimeUnit.HOURS; &#x2F;&#x2F;小时</li>
<li>TimeUnit.MINUTES; &#x2F;&#x2F;分钟</li>
<li>TimeUnit.SECONDS; &#x2F;&#x2F;秒</li>
<li>TimeUnit.MILLISECONDS; &#x2F;&#x2F;毫秒</li>
<li>TimeUnit.MICROSECONDS; &#x2F;&#x2F;微妙</li>
<li>TimeUnit.NANOSECONDS; &#x2F;&#x2F;纳秒</li>
</ul>
<p>workQueue ： 任务队列，阻塞队列，存储提交的等待任务。常见子类有：</p>
<ul>
<li>ArrayBlockingQueue;</li>
<li>LinkedBlockingQueue;</li>
<li>SynchronousQueue;</li>
</ul>
<p>threadFactory : 线程工厂，指定创建线程的工厂</p>
<p>handler ： 任务队列添加异常的捕捉器，当任务超出线程池范围和队列容量时，采取何种拒绝策略。参考 RejectedExecutionHandler，常见实现类。</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li>
<li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li>
</ul>
<h1 id="看一个自定义线程的例子"><a href="#看一个自定义线程的例子" class="headerlink" title="看一个自定义线程的例子"></a>看一个自定义线程的例子</h1><p><img src="/../../images/ca3daa377a7c4091808d53dcbc87247a.png" alt="2021经典面试—多线程与并发"></p>
<p>简单演示</p>
<p>执行结果</p>
<p><img src="/../../images/564a8d1042a448ae9d01ba050d6adba6.png" alt="2021经典面试—多线程与并发"></p>
<p>执行结果</p>
<h1 id="工作中哪些地方使用了多线程？"><a href="#工作中哪些地方使用了多线程？" class="headerlink" title="工作中哪些地方使用了多线程？"></a>工作中哪些地方使用了多线程？</h1><p><strong>问题回答</strong></p>
<ol>
<li>一般业务，web层–&gt; service层 –&gt;dao –&gt; sql基本用不到多线程</li>
<li>数据量很大（1000w级别、TB级别）的I&#x2F;O操作，可以考虑多线程</li>
</ol>
<p>举一些例子</p>
<ol>
<li>自己做并发测试的时候，假如想写想模拟3000个并发请求。</li>
<li>多线程下单抢单，假如支持5000人的并发下单。</li>
<li>多线程写入mysql，假如有1000w条数据要入库。</li>
<li>多线程写入redis，假如有1000w的数据要存入redis。</li>
<li>多线程导入ES索引，假如有1000w的数据要添加到ES索引。</li>
<li>poi多线程导出，假如xls里面有10w的数据需要导出。</li>
<li>poi多线程导入，假如有10w条数据需要导入到xls。</li>
<li>多线程发送邮件，假如有10w用户需要发送邮件。</li>
<li>多线程发送短信，假如有10w用户需要发送邮件。</li>
</ol>
<p>10.多线程备份日志，假如10tb日志文件要备份。</p>
<p>11.多线程验证数据，比如验证url是否存在，假如有100w个url</p>
<h1 id="数据并发操作可能的问题"><a href="#数据并发操作可能的问题" class="headerlink" title="数据并发操作可能的问题?"></a>数据并发操作可能的问题?</h1><p><strong>问题回答</strong></p>
<ol>
<li>丢失的修改</li>
<li>不可重复读,读第二次,数据就不对了</li>
<li>读脏数据</li>
<li>幻影读</li>
</ol>
<p><strong>脏读</strong>:指事务读到了其它事务做了修改而未提交的数据</p>
<p><strong>不可重复读</strong>:不能重复读两次,读两次就不同了</p>
<p><strong>幻读</strong>:同一个事务T1在两个不同的时间段t执行同一条查询语句得到的记录数量不同</p>
<p><img src="/../../images/229550e4735d493fbeecb320413e6262.jpeg" alt="2021经典面试—多线程与并发"></p>
<h1 id="消息等待通知wait-x2F-notify具体的应用"><a href="#消息等待通知wait-x2F-notify具体的应用" class="headerlink" title="消息等待通知wait&#x2F;notify具体的应用"></a>消息等待通知wait&#x2F;notify具体的应用</h1><p><strong>问题回答</strong></p>
<ol>
<li>一个线程修改了一个对象的值，另外一个线程需要感知到这个变化</li>
<li>Java中我们使用的对象锁以及wait&#x2F;notify方法进行线程通信</li>
<li>等待方遵循的原则：<br>获取对象的锁不满足条件 就调用wait()方法条件满足继续执行</li>
<li>通知方原则：<br>获取对象的锁改变条件， 然后notify</li>
</ol>
<h1 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h1><p><strong>问题回答</strong></p>
<ol>
<li>execute() 参数 Runnable ；</li>
<li>submit() 参数 (Runnable) 或 (Runnable 和 结果 T) 或 (Callable)；</li>
<li>execute(Runnable x) 没有返回值。可以执行任务，但无法判断任务是否成功完成。</li>
<li>submit(Callable x)有返回值，返回一个Future类的对象。</li>
<li>Future对象</li>
</ol>
<ul>
<li>通过get方法，获取线程返回结果</li>
<li>通过get方法，接收任务执行时候抛出的异常</li>
<li>通过isDone方法，可以判断线程是否执行完成。</li>
</ul>
<p><strong>看execute和submit方法的定义</strong></p>
<p><img src="/../../images/fb2b9b10bcfd4835a90cc07d4ff34d62.png" alt="2021经典面试—多线程与并发"></p>
<p><strong>看submit方法的定义</strong></p>
<p><img src="/../../images/e72049ee4fe848529beb80bde7b6da75.png" alt="2021经典面试—多线程与并发"></p>
<p><strong>看看Future的get方法</strong></p>
<p>可以接收结果，可以接收任务执行时候抛出的异常</p>
<p><img src="/../../images/f88c2bb2190c43d09525472f4e585b9c.png" alt="2021经典面试—多线程与并发"></p>
<p><strong>看看Future的方法</strong></p>
<p><img src="/../../images/60d4bdac19ae4d728c4569f3b975dfe4.jpeg" alt="2021经典面试—多线程与并发"></p>
<h1 id="线程的创建方式有哪些？"><a href="#线程的创建方式有哪些？" class="headerlink" title="线程的创建方式有哪些？"></a>线程的创建方式有哪些？</h1><p><strong>问题回答</strong></p>
<ol>
<li>继承Thread类实现</li>
<li>实现Runnable接口方式</li>
<li>实现Callable接口方式</li>
<li>其中前两种比较常用。但是，需要有返回值需要实现Callable接口。</li>
</ol>
<h1 id="继承Thread类实现"><a href="#继承Thread类实现" class="headerlink" title="继承Thread类实现"></a>继承Thread类实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 继承Thread类，并重写run方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="built_in">super</span>.run();</span><br><span class="line">         System.out.println(<span class="string">&quot;MyThread...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现Runnable接口方式"><a href="#实现Runnable接口方式" class="headerlink" title="实现Runnable接口方式"></a>实现Runnable接口方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 实现Runnable接口，并重写run方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;MyRunnable...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">MyRunnable runnable=<span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h1 id="实现Callable接口方式"><a href="#实现Callable接口方式" class="headerlink" title="实现Callable接口方式"></a>实现Callable接口方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 实现Callable接口，并重写call方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;MyCallable...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//创建和调用</span></span><br><span class="line"> <span class="type">MyCallable</span> <span class="variable">callable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line"> <span class="type">ExecutorService</span> <span class="variable">eService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"> Future&lt;String&gt; future = eService.submit(callable);</span><br><span class="line">     </span><br><span class="line"> <span class="comment">//获取返回结果</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    String result=future.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>callable需要配合线程池使用</li>
<li>callable比runnable功能复杂一些<br>Callable的call方法有返回值并且可以抛异常，而Runnable的run方法就没有返回值也没有抛异常，也就是可以知道执行线程的时候除了什么错误。</li>
<li>Callable运行后可以拿到一个Future对象，这个对象表示异步计算结果，可以从通过Future的get方法获取到call方法返回的结果。但要注意调用Future的get方法时，当前线程会阻塞，直到call方法返回结果。</li>
</ul>
<h1 id="说一下CAS锁机制？"><a href="#说一下CAS锁机制？" class="headerlink" title="说一下CAS锁机制？"></a>说一下CAS锁机制？</h1><p><strong>问题回答</strong></p>
<ol>
<li>CAS（Compare and Swap 比较并交换），是一种无锁算法，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</li>
<li>CAS算法涉及到三个操作数</li>
</ol>
<ul>
<li>需要读写的内存位置(V)</li>
<li>进行比较的预期原值(A)</li>
<li>拟写入的新值(B)</li>
</ul>
<p>3.如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。</p>
<h1 id="说一下ConcurrentHashMap？"><a href="#说一下ConcurrentHashMap？" class="headerlink" title="说一下ConcurrentHashMap？"></a>说一下ConcurrentHashMap？</h1><p><strong>问题回答</strong></p>
<ol>
<li>ConcurrentHashMap是Java中的一个线程安全且高效的HashMap实现</li>
<li>JDK1.7 ConcurrentHashMap 由Segment 数组+HashEntry 组成，也就是数组+链表。</li>
<li>JDK1.7 ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。支持 N 个 Segment 这么多次数的并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</li>
<li>JDK1.8抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性</li>
<li>JDK1.8将HashEntry改为了Node，和 1.8 HashMap 结构类似，当链表节点数超过指定阈值的话，会转换成红黑树的。</li>
</ol>
<p><strong>看看图片</strong></p>
<p>jdk 1.7 ConcurrentHashMap</p>
<p><img src="/../../images/93ef31c1ce474e19a2be84fedd9470db.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>jdk 1.7 ConcurrentHashMap</p>
<p>jdk1.8 ConcurrentHashMap</p>
<p><img src="/../../images/beaae0269a1143afb6e35cfcd8852da7.png" alt="2021经典面试—多线程与并发"></p>
<p>jdk1.8 ConcurrentHashMap</p>
<h1 id="说一下Threadlocal关键字？"><a href="#说一下Threadlocal关键字？" class="headerlink" title="说一下Threadlocal关键字？"></a>说一下Threadlocal关键字？</h1><p><strong>问题回答</strong></p>
<ol>
<li>线程本地变量，可以为变量在每个线程中都创建一个副本，使每个线程都可以访问自己内部的副本变量</li>
</ol>
<h1 id="说一下乐观锁和悲观锁的区别？"><a href="#说一下乐观锁和悲观锁的区别？" class="headerlink" title="说一下乐观锁和悲观锁的区别？"></a>说一下乐观锁和悲观锁的区别？</h1><p><strong>问题回答</strong></p>
<ol>
<li>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。<br>synchronized、Lock属于悲观锁。Lock有三种实现类：ReentrantLock、ReadLock（读锁）和WriteLock（写锁）。</li>
<li>乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁。</li>
<li>CAS属于乐观锁。</li>
<li>悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</li>
<li>悲观锁对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>乐观锁不会上锁，在更新时会判断数据有没有被修改，一般会使用“数据版本机制”或“CAS操作”来实现。</li>
</ol>
<h1 id="数据版本机制"><a href="#数据版本机制" class="headerlink" title="数据版本机制"></a>数据版本机制</h1><p>实现数据版本一般有两种，第一种是使用版本号，第二种是使用时间戳。以版本号方式为例。</p>
<p>版本号方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。</p>
<p>当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。核心SQL代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table set xxx=#&#123;xxx&#125;, version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h1><p>CAS（Compare and Swap 比较并交换），当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>　CAS操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。</p>
<h1 id="说一下事务特性"><a href="#说一下事务特性" class="headerlink" title="说一下事务特性?"></a>说一下事务特性?</h1><p><strong>问题回答</strong></p>
<ol>
<li>事务特性指的就是ACID。</li>
<li>分别是原子性（Atomicity)、一致性（Consistency)、隔离性（Isolation）、持久性（Durability）。</li>
<li>分别解释下：</li>
</ol>
<ul>
<li>原子性：原子性是指事务包含的操作要么全部成功，要么全部失败。因此事务的操作成功就必须要完全应用到数据库。</li>
<li>一致性：一致性强调的是数据是一致性的。假设用户A和用户B两者的钱加起来一共是5000，那么不管A还是B如何转账，转几次账，事务结束后两个用户的钱加起来应该还是5000，这就是事务的一致性。</li>
<li>隔离性：当多个用户并发访问数据库时，多个并发事务是相互隔离的。事务之间不能相互干扰。</li>
<li>持久性：一个事务一旦被提交了，那么对数据库中的数据改变是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作</li>
</ul>
<p><strong>简要理解</strong></p>
<ol>
<li>也就是acid。</li>
<li>分别是原子性、一致性、隔离性、持久性。</li>
<li>原子性，要么同时成功要么同时失败。</li>
<li>一致性，数据应该是一致的。</li>
<li>隔离性，多个并发事务是相互隔离的。</li>
<li>持久性，事务提交，对数据的改变是永久的。</li>
</ol>
<p><strong>关于几个特性，补充理解</strong></p>
<ul>
<li>原子性，算是事务最基本的特性了。</li>
<li>一致性，感觉像事务的目标，其他的三个特性都是为了保证数据一致性存在的。</li>
<li>隔离性，为了保证并发情况下的一致性而引入，并发状态下单靠原子性不能完全解决一致性的问题，在多个事务并发进行的情况下，即使保证了每个事务的原子性，仍然可能导致数据不一致。比如，事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2将100元转入帐号A，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上，事务1最终完成后，帐号A只增加了100元，因为事务1覆盖了事务2的修改结果。</li>
<li>持久性，好理解，事务一旦提交，对数据库的影响是永久的，保证所有操作都是有效。</li>
</ul>
<h1 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h1><p><img src="/../../images/d3224adc229e4c12b8eb089742712602.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>事务特性</p>
<h1 id="说一下互斥锁-x2F-读写锁？"><a href="#说一下互斥锁-x2F-读写锁？" class="headerlink" title="说一下互斥锁&#x2F;读写锁？"></a>说一下互斥锁&#x2F;读写锁？</h1><p><strong>问题回答</strong></p>
<ol>
<li>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁，就是具体的实现。</li>
<li>一次只能一个线程拥有互斥锁，其他线程只有等待</li>
<li>互斥锁在Java中的具体实现就是ReentrantLock。</li>
<li>读写锁在Java中的具体实现就是ReadWriteLock。</li>
</ol>
<h1 id="说一下偏向锁-x2F-轻量级锁-x2F-重量级锁？"><a href="#说一下偏向锁-x2F-轻量级锁-x2F-重量级锁？" class="headerlink" title="说一下偏向锁&#x2F;轻量级锁&#x2F;重量级锁？"></a>说一下偏向锁&#x2F;轻量级锁&#x2F;重量级锁？</h1><p><strong>问题回答</strong></p>
<ol>
<li>这三种锁是指锁状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</li>
<li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li>
<li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li>
<li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。</li>
</ol>
<h1 id="说一下公平锁-x2F-非公平锁？"><a href="#说一下公平锁-x2F-非公平锁？" class="headerlink" title="说一下公平锁&#x2F;非公平锁？"></a>说一下公平锁&#x2F;非公平锁？</h1><p><strong>问题回答</strong></p>
<ol>
<li>公平锁是指多个线程按照申请锁顺序来获取锁。</li>
<li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</li>
<li>对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</li>
<li>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</li>
</ol>
<h1 id="说一下分段锁？"><a href="#说一下分段锁？" class="headerlink" title="说一下分段锁？"></a>说一下分段锁？</h1><p><strong>问题回答</strong></p>
<ol>
<li>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</li>
<li>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。</li>
<li>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对分段加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行插入。</li>
<li>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</li>
<li>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</li>
</ol>
<h1 id="说一下可重入锁？"><a href="#说一下可重入锁？" class="headerlink" title="说一下可重入锁？"></a>说一下可重入锁？</h1><p><strong>问题回答</strong></p>
<ol>
<li>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</li>
<li>对于Java ReetrantLock而言，从名字就可以看出是一个重入锁，其名字是Re entrant Lock 重新进入锁。</li>
<li>对于Synchronized而言，也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</li>
</ol>
<p><strong>看代码理解可重入锁</strong></p>
<p><img src="/../../images/06248f2c89744fb380d39ee9d1a7b965.jpeg" alt="2021经典面试—多线程与并发"></p>
<p>可重入锁</p>
<p>上面的代码就是一个可重入锁的一个特点。如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。</p>
<h1 id="说一下对象锁和类锁？"><a href="#说一下对象锁和类锁？" class="headerlink" title="说一下对象锁和类锁？"></a>说一下对象锁和类锁？</h1><p><strong>问题回答</strong></p>
<ol>
<li>java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，实际区别大</li>
<li>对象锁是用于对象实例方法，或者一个对象实例上的</li>
<li>类锁是用于类的静态方法或者一个类的class对象上的。</li>
<li>我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的</li>
</ol>
<h1 id="说一下死锁？"><a href="#说一下死锁？" class="headerlink" title="说一下死锁？"></a>说一下死锁？</h1><p><strong>问题回答</strong></p>
<ol>
<li>Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。即线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。</li>
</ol>
<h1 id="说一下独享锁-x2F-共享锁？"><a href="#说一下独享锁-x2F-共享锁？" class="headerlink" title="说一下独享锁&#x2F;共享锁？"></a>说一下独享锁&#x2F;共享锁？</h1><p><strong>问题回答</strong></p>
<ol>
<li>独享锁是指该锁一次只能被一个线程所持有。</li>
<li>共享锁是指该锁可被多个线程所持有。</li>
<li>对于Java ReentrantLock（重入锁）而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。</li>
<li>读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。</li>
<li>独享锁与共享锁也是通过AQS（AbstractQuenedSynchronizer抽象的队列式同步器）来实现的，通过实现不同的方法，来实现独享或者共享。</li>
<li>对于Synchronized而言，当然是独享锁。</li>
</ol>
<h1 id="说一下自旋锁？"><a href="#说一下自旋锁？" class="headerlink" title="说一下自旋锁？"></a>说一下自旋锁？</h1><p><strong>问题回答</strong></p>
<ol>
<li>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</li>
<li>优点是减少线程上下文切换的消耗</li>
<li>缺点是循环会消耗CPU。</li>
</ol>
<h1 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h1><p><strong>问题回答</strong></p>
<ol>
<li>程序被载入到内存中并准备执行，它就是一个进程</li>
<li>单个进程中执行中每个任务就是一个线程</li>
<li>一个线程只能属于一个进程，但是一个进程可以拥有多个线程</li>
</ol>
<h1 id="静态方法是否线程安全？"><a href="#静态方法是否线程安全？" class="headerlink" title="静态方法是否线程安全？"></a>静态方法是否线程安全？</h1><p><strong>问题回答</strong></p>
<ol>
<li>看静态方法是否引起线程安全问题要看在静态方法中是否使用了静态成员。</li>
<li>如果该静态方法不去操作一个静态成员，只在方法内部使用实例字段(instance field)，不会引起安全性问题</li>
<li>如果该静态方法操作了一个静态字段，则需要在静态方法中采用互斥访问的方式进行安全处理。</li>
</ol>
<p>redis如何新节点如何同步</p>
<p>segment 分多少段</p>
<p>top </p>
<p>Jstack pid </p>
<p>G1 &#x3D;&#x3D;&#x3D;&#x3D;  </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-07T09:08:08.000Z" title="2022/2/7 下午5:08:08">2022-02-07</time>发表</span><span class="level-item"><time dateTime="2022-02-07T09:08:08.000Z" title="2022/2/7 下午5:08:08">2022-02-07</time>更新</span><span class="level-item">32 分钟读完 (大约4837个字)</span></div></div><div class="content"><p>[toc]</p>
<h1 id="1、什么是-Mybatis？"><a href="#1、什么是-Mybatis？" class="headerlink" title="1、什么是 Mybatis？"></a>1、什么是 Mybatis？</h1><p>1.Mybatis 是⼀个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发 时只需要关注 SQL 语句本身，不需要 花费精⼒去处理加载驱动、创建连接、 创 建 statement 等繁杂的过程。程序员直 接编写原⽣态 sql，可以严格控制 sql执⾏性能，灵活度⾼。<br>2.MyBatis 可以使⽤ XML 或注解来配 置和映射原⽣信息，将 POJO 映射成数据库中的记 录 ，避免了⼏乎所有的JDBC代码和⼿动设置参数以及获取结果集。<br>3.通过 xml ⽂件或注解的⽅式将要执⾏的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进⾏映射⽣成最终执⾏的 sql 语句，最后由 mybatis 框架执⾏ sql 并将结果映射为 java 对象并返回。（从执⾏ sql 到返回result 的过程）。 </p>
<h1 id="2-MyBatis的优点"><a href="#2-MyBatis的优点" class="headerlink" title="2.MyBatis的优点"></a>2.MyBatis的优点</h1><p>1.基于 SQL 语句编程，相当灵活，不会对应⽤程序或者数据库的现有设计造成任何影响，SQL 写在 XML ⾥，解除 sql 与程序代码的耦合，便于统⼀管理；提供 XML 标签，⽀持编写动态 SQL 语 句，并可重⽤。<br>2.与 JDBC 相⽐，减少了 50%以上的 代码量，消除了 JDBC ⼤量冗余的代 码， 不需要⼿动开关连接；<br>3.很 好 的 与 各 种 数 据 库 兼 容 （ 因 为 MyBatis 使⽤ JDBC 来连接数据库，所 以 只要 JDBC ⽀持的数据库 MyBatis 都⽀持）。<br>4.能够与 Spring 很好的集成；<br>5.提供映射标签，⽀持对象与数据库的 ORM 字段关系映射；提供对象关系映 射标签，⽀持对象关系组件维护。</p>
<h1 id="3-MyBatis-框架的缺点："><a href="#3-MyBatis-框架的缺点：" class="headerlink" title="3.MyBatis 框架的缺点："></a>3.MyBatis 框架的缺点：</h1><p>1.SQL 语句的编写⼯作量较⼤，尤其当 字段多、关联表多时，对开发⼈员编写 SQL 语句的功底有⼀定要求。<br>2.SQL 语句依赖于数据库，导致数据库 移植性差，不能随意更换数据库。</p>
<h1 id="4、MyBatis-框架适⽤场合："><a href="#4、MyBatis-框架适⽤场合：" class="headerlink" title="4、MyBatis 框架适⽤场合："></a>4、MyBatis 框架适⽤场合：</h1><p>1.MyBatis 专注于 SQL 本身，是⼀个⾜够灵活的 DAO 层解决⽅案。<br>2.对性能的要求很⾼，或者需求变化较 多的项⽬，如互联⽹项⽬，MyBatis 将 是不错的选择。</p>
<h1 id="5、MyBatis-与-Hibernate-有哪些不同？"><a href="#5、MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="5、MyBatis 与 Hibernate 有哪些不同？"></a>5、MyBatis 与 Hibernate 有哪些不同？</h1><p> 1.Mybatis 和 hibernate 不同，它不完全是</p>
<h2 id="2-MYBATIS之MAPPER接口的注册过程"><a href="#2-MYBATIS之MAPPER接口的注册过程" class="headerlink" title="2.MYBATIS之MAPPER接口的注册过程"></a>2.MYBATIS之MAPPER接口的注册过程</h2><p>Mapper接口用于定义执行SQL语句相关的方法，方法名一般和Mapper XML配置文件中&lt;select|update|delete|insert&gt;标签的id属性相同，接口的完全限定名一般对应Mapper XML配置文件的命名空间。</p>
<p>可以看一下Mapper XML，如下面的UserMapper.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.blog4java.mybatis.example.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;sql id=&quot;userAllField&quot;&gt;</span><br><span class="line">      id,create_time, name, password, phone, nick_name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;listAllUser&quot;   resultType=&quot;com.blog4java.mybatis.example.entity.UserEntity&quot; &gt;</span><br><span class="line">        select</span><br><span class="line">        &lt;include refid=&quot;userAllField&quot;/&gt;</span><br><span class="line">        from user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getUserByEntity&quot;  resultType=&quot;com.blog4java.mybatis.example.entity.UserEntity&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">        &lt;include refid=&quot;userAllField&quot;/&gt;</span><br><span class="line">        from user</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">                AND id = #&#123;id&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;name != null&quot;&gt;</span><br><span class="line">                AND name = #&#123;name&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;phone != null&quot;&gt;</span><br><span class="line">                AND phone = #&#123;phone&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getUserByPhone&quot; resultType=&quot;com.blog4java.mybatis.example.entity.UserEntity&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">        &lt;include refid=&quot;userAllField&quot;/&gt;</span><br><span class="line">        from user</span><br><span class="line">        where phone = $&#123;phone&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>UserMapper的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;UserEntity&gt; listAllUser();</span><br><span class="line"></span><br><span class="line">    List&lt;UserEntity&gt; getUserByEntity( UserEntity user);</span><br><span class="line"></span><br><span class="line">    UserEntity getUserByPhone(@Param(&quot;phone&quot;) String phone);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下如何执行这个UserMapper.xml，参考下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取配置文件输入流</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 通过SqlSessionFactoryBuilder的build()方法创建SqlSessionFactory实例</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"><span class="comment">// 调用openSession()方法创建SqlSession实例</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">// 获取UserMapper代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="comment">// 执行Mapper方法，获取执行结果</span></span><br><span class="line">List&lt;UserEntity&gt; userList = userMapper.listAllUser();</span><br><span class="line"></span><br><span class="line">System.out.println(JSON.toJSONString(userList));</span><br></pre></td></tr></table></figure>

<p>如上面的代码所示，在创建SqlSession实例后，需要调用SqlSession的getMapper()方法获取一个UserMapper的引用，然后通过该引用调用Mapper接口中定义的方法，UserMapper是一个接口，我们调用SqlSession对象getMapper()返回的到底是什么呢？</p>
<p>我们知道，接口中定义的方法必须通过某个类实现该接口，然后创建该类的实例，才能通过实例调用方法。所以SqlSession对象的getMapper()方法返回的一定是某个类的实例。具体是哪个类的实例呢？实际上getMapper()方法返回的是一个动态代理对象。</p>
<p>我们一步步解析 DefaultSqlSession实现了SqlSession接口，可以直接看一下DefaultSqlSession对getMapper()的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SqlSession对象getMapper()具体的实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="built_in">this</span>);  <span class="comment">// this:sqlSession</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过调用configuration类的getMapper获取UserMapper的实列，继续看看getMapper的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> &#123;  <span class="comment">// configuration类的getMapper的实现</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>configuration类的getMapper的是通过调用mapperRegistry的getMapper方法来实现的</p>
<p><strong>这里的mapperRegistry用于注册Mapper接口信息，建立Mapper接口的Class对象和MapperProxyFactory对象之间的关系，其中MapperProxyFactory对象用于创建Mapper动态代理对象</strong></p>
<p>继续下一步</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/4925ef65d1764d2abeab75982197f6d6.png?lastModify=1623470232" alt="Mybatis之Mapper接口的注册过程"></p>
<p>根据Mapper接口Class对象获取Mapper动态代理对象</p>
<p>Mapper动态代理对象是通过MapperProxyFactory创建的。</p>
<p>重点来了，MapperProxyFactory如何通过动态代理来创建Mapper对象的</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/658577fd8f6e4bfb94945b74192bb7d5.png?lastModify=1623470232" alt="Mybatis之Mapper接口的注册过程"></p>
<p>MapperProxy使用的是JDK内置的动态代理</p>
<p>MapperProxy使用的是JDK内置的动态代理，实现了InvocationHandler接口，invoke()方法中为通用的拦截逻辑，具体内容在介绍Mapper方法调用过程时再做介绍。使用JDK内置动态代理，通过MapperProxy类实现InvocationHandler接口，定义方法执行拦截逻辑后，还需要调用java.lang.reflect.Proxy类的newProxyInstance()方法创建代理对象。</p>
<p>MyBatis对这一过程做了封装，使用MapperProxyFactory创建Mapper动态代理对象。</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/19f7239d661149ca847ea7171a542faf.png?lastModify=1623470232" alt="Mybatis之Mapper接口的注册过程"></p>
<p>MapperProxyFactory类对jdk动态代理做了进一步的封装</p>
<p>如上面的代码所示，MapperProxyFactory类的工厂方法newInstance()是非静态的。也就是说，使用MapperProxyFactory创建Mapper动态代理对象首先需要创建MapperProxyFactory实例。MapperProxyFactory实例是什么时候创建的呢？</p>
<p>Configuration对象中有一个mapperRegistry属性，创建Configuration对象过程中，<a target="_blank" rel="noopener" href="https://www.toutiao.com/item/6956133794403435038/">具体看这篇文章</a>，解析<mappers>标签的时候会调用mapperRegistry中的addMapper(Class<T> type)，创建MapperProxyFactory实例。</p>
<p>MyBatis通过mapperRegistry属性注册Mapper接口与MapperProxyFactory对象之间的对应关系。下面是MapperRegistry类的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public class MapperRegistry &#123;</span><br><span class="line">  // Configuration对象引用</span><br><span class="line">  private final Configuration config;</span><br><span class="line">  // 用于注册Mapper接口Class对象，和MapperProxyFactory对象对应关系</span><br><span class="line">  private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  public MapperRegistry(Configuration config) &#123;</span><br><span class="line">    this.config = config;</span><br><span class="line">  &#125;</span><br><span class="line">  // 根据Mapper接口Class对象获取Mapper动态代理对象</span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    if (mapperProxyFactory == null) &#123;</span><br><span class="line">      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public &lt;T&gt; boolean hasMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return knownMappers.containsKey(type);</span><br><span class="line">  &#125;</span><br><span class="line">  // 根据Mapper接口Class对象，创建MapperProxyFactory对象，并注册到knownMappers属性中</span><br><span class="line">  public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    if (type.isInterface()) &#123;</span><br><span class="line">      if (hasMapper(type)) &#123;</span><br><span class="line">        throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      boolean loadCompleted = false;</span><br><span class="line">      try &#123;</span><br><span class="line">        knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">        // It&#x27;s important that the type is added before the parser is run</span><br><span class="line">        // otherwise the binding may automatically be attempted by the</span><br><span class="line">        // mapper parser. If the type is already known, it won&#x27;t try.</span><br><span class="line">        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = true;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        if (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @since 3.2.2</span><br><span class="line">   */</span><br><span class="line">  public Collection&lt;Class&lt;?&gt;&gt; getMappers() &#123;</span><br><span class="line">    return Collections.unmodifiableCollection(knownMappers.keySet());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @since 3.2.2</span><br><span class="line">   */</span><br><span class="line">  public void addMappers(String packageName, Class&lt;?&gt; superType) &#123;</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">    for (Class&lt;?&gt; mapperClass : mapperSet) &#123;</span><br><span class="line">      addMapper(mapperClass);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @since 3.2.2</span><br><span class="line">   */</span><br><span class="line">  public void addMappers(String packageName) &#123;</span><br><span class="line">    addMappers(packageName, Object.class);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面的代码所示，MapperRegistry类有一个knownMappers属性，用于注册Mapper接口对应的Class对象和MapperProxyFactory对象之间的关系。另外，MapperRegistry提供了addMapper()方法，用于向knownMappers属性中注册Mapper接口信息。在addMapper()方法中，为每个Mapper接口对应的Class对象创建一个MapperProxyFactory对象，然后添加到knownMappers属性中。</p>
<p>MapperRegistry还提供了getMapper()方法，能够根据Mapper接口的Class对象获取对应的MapperProxyFactory对象，然后就可以使用MapperProxyFactory对象创建Mapper动态代理对象了。</p>
<p>MyBatis框架在应用启动时会解析所有的Mapper接口，然后调用MapperRegistry对象的addMapper()方法将Mapper接口信息和对应的MapperProxyFactory对象注册到MapperRegistry对象中。</p>
<h2 id="3-从源码层面解释：为什么执行MYBATIS接口就可以执行SQL？"><a href="#3-从源码层面解释：为什么执行MYBATIS接口就可以执行SQL？" class="headerlink" title="3.从源码层面解释：为什么执行MYBATIS接口就可以执行SQL？"></a>3.从源码层面解释：为什么执行MYBATIS接口就可以执行SQL？</h2><h1 id="1-场景分析"><a href="#1-场景分析" class="headerlink" title="1:场景分析"></a>1:场景分析</h1><p>在我们使用SpringBoot+MyBatis的时候，我们一般是先引入依赖，然后配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">      mapper-locations: classpath:mapper/*.xml</span><br><span class="line">      type-aliases-package: com.coco.pojo</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然还要在启动类上加上一个注解</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/3937db9fa56947899d61bc78a04a819d.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>这时候，就可以编写一个接口，然后调用这个方法就可以执行配置文件中对应的SQL语句了</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/5c8dd828dee64ec6b031c80c0a745d6b.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>那么底层原理到底是怎么实现的呢？？</p>
<h1 id="2-万事开头难"><a href="#2-万事开头难" class="headerlink" title="2:万事开头难"></a>2:万事开头难</h1><p>分析一个框架源码的时候最难的就是不知道该从哪开始，我是这样想的，既然我们只要写一个这样的接口，那么就可以调用对应的SQL语句，那么肯定是在哪个环节对这个接口做一些特殊的处理</p>
<p>我们在启动类上加了一个注解，而且注解中的包路径正是我们接口的路径，这时候我们就有点眉目了。</p>
<p>进入 <strong>@MapperScan(“com.coco.mapper”)</strong> 这个注解中</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/2aba0c9e45b1412fb74acd771cebf494.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>我们看到除了注解的基本三个注解之外，还有一个注解就是 <strong>@Import({ MapperScannerRegistrar.class})</strong> ，很多小伙伴可能不知道这个注解有什么用，我们先解释一下</p>
<h1 id="3-SPRINGBOOT中-IMPORT注解的作用"><a href="#3-SPRINGBOOT中-IMPORT注解的作用" class="headerlink" title="3: SPRINGBOOT中@IMPORT注解的作用"></a>3: SPRINGBOOT中@IMPORT注解的作用</h1><p>在SpringBoot中当我们要声明一个Bean的时候，我们可以在该类上加上 <strong>@Service，@Compont</strong> 等，或者是在配置类中加上 <strong>@Bean</strong> 这个注解，除此之外还有一种方法，就是 <strong>@Import</strong></p>
<p>@Import注解中会标明一个类，而且在SpringBoot启动的时候会处理也就是会实例化这个Bean，也就是会对这个Bean做一些处理</p>
<h1 id="4-MAPPERSCANNERREGISTRAR-CLASS的作用"><a href="#4-MAPPERSCANNERREGISTRAR-CLASS的作用" class="headerlink" title="4: MAPPERSCANNERREGISTRAR.CLASS的作用"></a>4: MAPPERSCANNERREGISTRAR.CLASS的作用</h1><p>即然知道了 <strong>@Import</strong> 注解的作用，那现在我们进入到这个类中看看，这个类实现了** ImportBeanDefinitionRegistrar** 这个接口</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/09a4d2ca48d740c38f33a061b1b4aa51.png?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>这个接口有什么用呢？？简单的来说就是MyBatis通过这个入口可以让Spring扫描到某些Bean，并且这些Bean会被Spring所管理，也就是说这些Bean会被Spring进行初始化。</p>
<p>所以我们自定义的Mapper接口会被Spring扫描到，然后会被Spring进行加载</p>
<p>ImportBeanDefinitionRegistrar这个接口就代表着当把Bean生成了对应的 <strong>BeanDefinition</strong> 的时候，就会调用这个接口的方法，我们看下这个接口中定义的方法</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/01a26972e56f4587b43fa1a81eced2e1.png?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>这个方法做什么的呢？？</p>
<p>Spring在加载Bean的时候，首先会将Bean生成一个个的对应的 <strong>BeanDefinition</strong> ，后续就会通过这些一个个的 <strong>BeanDefinition</strong> 来进行初始化，也就是生成对应的Bean。</p>
<p>简而言之：Spring会通过MyBatis提供的 <strong>@MapperScan(“com.coco.mapper”)</strong> 这个注解会扫描我们自定义的Mapper接口，然后Spring就会为这些Mapper接口生成对应的 <strong>BeanDefinition</strong></p>
<h1 id="5-DEBUG模式进入源码"><a href="#5-DEBUG模式进入源码" class="headerlink" title="5: DEBUG模式进入源码"></a>5: DEBUG模式进入源码</h1><p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/16b84ced71b647ec85e74efd16a3c789.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>然后debug模式启动SpringBoot项目，当然前提是整合了MyBatis哈，这个方法我进行了截取，其实只需要关注下面这几行代码就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    </span><br><span class="line">    //获取到MapperScan注解</span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    </span><br><span class="line">    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">    // 获取MapperScan注解中basePackages的属性值</span><br><span class="line">    for (String pkg : annoAttrs.getStringArray(&quot;basePackages&quot;)) &#123;</span><br><span class="line">      if (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 真正开始处理这个包路径下的接口，也就是我们的Mapper接口</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里就可以获取到我们自定义mapper接口的包的全路径了</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/22ee326e02bc46fbadd26be350a682d6.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<h1 id="6-开始处理MAPPER接口"><a href="#6-开始处理MAPPER接口" class="headerlink" title="6: 开始处理MAPPER接口"></a>6: 开始处理MAPPER接口</h1><p>我们进入到上面的 scanner.doScan(StringUtils.toStringArray(basePackages)); 这个方法</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/fa6b19fd5327477bbb2bdd1ab836f7d8.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>然后进入 <strong>Set beanDefinitions &#x3D; super.doScan(basePackages);</strong> 发现好多代码，其实这个方法的返回值是一个 <strong>BeanDefinitionHolder</strong> 的集合，而 <strong>BeanDefinitionHolder</strong> 就是bean的名称和该bean的BeanDefinition的组成</p>
<p>其实到这里我们应该能明白，这个方法的作用就是：扫描我们自定义的Mapper接口，然后为每一个接口生成一个对应的BeanDefinition，然后将其返回</p>
<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/a70eaf14689641b48a0d5a020a0fb4ea.png?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">                Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);</span><br><span class="line">                Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();</span><br><span class="line">                for (String basePackage : basePackages) &#123;</span><br><span class="line">                        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">                        for (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">                                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">                                candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">                                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);</span><br><span class="line">                                if (candidate instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">                                        postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (candidate instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">                                        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                                        BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                                        definitionHolder =</span><br><span class="line">                                                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">                                        beanDefinitions.add(definitionHolder);</span><br><span class="line">                                        registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return beanDefinitions;</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/281b2ea126e541e39f4f0aa4afe8fffa.png?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>我们debug到这一步可以看到返回值，也证实了我们之前说的</p>
<h1 id="7-拿到BEANDEFINITION之后的处理"><a href="#7-拿到BEANDEFINITION之后的处理" class="headerlink" title="7: 拿到BEANDEFINITION之后的处理"></a>7: 拿到BEANDEFINITION之后的处理</h1><p>现在我们来看下 <strong>processBeanDefinitions(beanDefinitions);</strong> 这个方法，因为之前我们已经拿到了Mapper接口的BeanDefinition了，所以接下来就要进一步的处理</p>
<p>这个方法的代码依旧很多，我这里就不贴出来了，这里我先说一下这个方法是干什么的。</p>
<p>Spring在初始化Bean之前，我们是可以改变Bean的BeanDefinition的属性值得，而这个方法做的事情就是这个，经过这个方法处理之后，我们之前得到的BeanDefiniton会发生一些改变。我这里贴出二张图进行对比一下</p>
<h1 id="这是之前的："><a href="#这是之前的：" class="headerlink" title="这是之前的："></a>这是之前的：</h1><p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/e86c7c377179442fbd8ce481e7e3cc6f.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<h1 id="这是经过该方法处理之后的："><a href="#这是经过该方法处理之后的：" class="headerlink" title="这是经过该方法处理之后的："></a>这是经过该方法处理之后的：</h1><p><img src="file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/e6cca4863df54c728865ceb9a2448cb3.jpeg?lastModify=1623470232" alt="从源码层面解释：为什么执行MyBatis接口就可以执行SQL？"></p>
<p>可以发现该Bean的 <strong>beanClass</strong> 属性变了，已经不再是我们自定义的Bean的class了</p>
<p>改变之后有什么问题呢？？</p>
<p>Spring在初始化Bean的时候，会拿到该Bean的BenDefinition，然后就是根据 <strong>beanClass</strong> 这个属性值初始化Bean，本来我们Mapper接口初始化之后应该就是我们自己定义的Bean，也就是我们执行a.getClass的值应该是 com.xxx.a 这种形式的</p>
<p>但是现在变了，也就是说我们自定义的Mapper接口在被Spring初始化之后，再执行a.getClass会变成** org.mybatis.spring.mapper.MapperFactoryBean**</p>
<h1 id="8-初始化BEAN"><a href="#8-初始化BEAN" class="headerlink" title="8: 初始化BEAN"></a>8: 初始化BEAN</h1><p>经过上面的步骤之后，我们是拿到了Mapper接口的BeanDefinition，现在Spring就要开始初始化这些Bean了</p>
<p>因为此时就涉及到了Spring的源码了，我这里就不细说了</p>
<p>大致的流程：</p>
<p>1: Spring在初始化bean的时候，会根据Bean的scope属性进行初始化，而我们自定义的Mapper接口由于BeanDefinition的beanClass属性被修改了，所以在初始化的时候，经过一系列的判断最终会由MyBatis中的 <strong>MapperProxy</strong> 生成一个代理类，底层是通过jdk动态代理实现的</p>
<p>2: 然后当我们调用Mapper接口方法的时候就会执行 <strong>invoke</strong> 方法，因为是jdk动态代理生成的代理类。</p>
<p>3: 这时候，MyBatis是可以拿到该方法所在的类和该类的全路径的，比如我们在 <strong>com.coco.mapper</strong> 包下自定义了一个 <strong>TestMapper</strong> 接口，然后里面有一个 test() 方法，这时候我们可以通过一系列的方法得到一个值，该值就是:** com.coco.mapper.TestMapper.test** , 也就是该Mapper接口的全路径+方法名</p>
<p>4: MyBatis在解析xml配置文件的时候，有一个 <strong>namespace</strong> 的属性，它的值就是Mapper接口的全路径名，然后加上 id 的值，MyBatis底层会将所有的这种路径全都保存在一个Map中，然后执行接口方法的时候就会根据第3步生成的值去匹配，就能拿到对应的SQL语句了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">    &lt;mapper namespace=&quot;com.coco.mapper.TestMapper&quot;&gt;</span><br><span class="line">        &lt;select id=&quot;test&quot;&gt;</span><br><span class="line">           select * from test</span><br><span class="line">        &lt;/select&gt;</span><br><span class="line">    &lt;/mapper&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-29T07:05:03.000Z" title="2021/12/29 下午3:05:03">2021-12-29</time>发表</span><span class="level-item"><time dateTime="2021-12-29T07:05:03.000Z" title="2021/12/29 下午3:05:03">2021-12-29</time>更新</span><span class="level-item">7 分钟读完 (大约1034个字)</span></div></div><div class="content"><h1 id="4001-JDK中的ThreadPoolExecutor"><a href="#4001-JDK中的ThreadPoolExecutor" class="headerlink" title="4001-JDK中的ThreadPoolExecutor"></a>4001-JDK中的ThreadPoolExecutor</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/13G4Vs5Kcy9yrwYsX2yoiQ">https://mp.weixin.qq.com/s/13G4Vs5Kcy9yrwYsX2yoiQ</a></p>
</blockquote>
<h2 id="一、内容概述"><a href="#一、内容概述" class="headerlink" title="一、内容概述"></a>一、内容概述</h2><p>首先描述了ThreadPoolExecutor的构造流程以及内部状态管理的机理，随后用大量篇幅深入源码探究了ThreadPoolExecutor线程分配、任务处理、拒绝策略、启动停止等过程，其中对Worker内置类进行重点分析，内容不仅包含其工作原理，更对其设计思路进行了一定分析。文章内容既包含了源码流程分析，还具有设计思路探讨和二次开发实践。</p>
<p><img src="/../images/image-20211229144419379.png" alt="image-20211229144419379"></p>
<h2 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h2><h3 id="2-1-构造函数参数"><a href="#2-1-构造函数参数" class="headerlink" title="2.1 构造函数参数"></a>2.1 构造函数参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>corePoolSize</strong>：核心线程数。提交任务时，当线程池中的线程数 小于 corePoolSize 时，会 新 创建一个核心线程执行任务。当线程数 等于 corePoolSize 时，会将任务 添加进任务队列。</li>
<li><strong>maximumPoolSize</strong>：最大线程数。提交任务时，当 任务队列已满 并且线程池中的总线程数 不大于 maximumPoolSize 时，线程池会令非核心线程执行提交的任务。当 大于 maximumPoolSize 时，会执行拒绝策略。</li>
<li><strong>keepAliveTime</strong>：非核心线程 空闲时 的存活时间。</li>
<li><strong>unit</strong>：keepAliveTime 的单位。</li>
<li><strong>workQueue</strong>：任务队列（阻塞队列）。</li>
<li><strong>threadFactory</strong>：线程工厂。线程池用来新创建线程的工厂类。</li>
<li><strong>handler</strong>：拒绝策略，线程池遇到无法处理的情况时会执行该拒绝策略选择抛弃或忽略任务等。</li>
</ol>
<h3 id="2-3-常用线程池"><a href="#2-3-常用线程池" class="headerlink" title="2.3 常用线程池"></a>2.3 常用线程池</h3><p>在进入 ThreadPoolExecutor 的源码分析前，我们先介绍下常用的线程池（其实并不常用，只是JDK自带了）。这些线程池可由 Executors 这个工具类（或叫线程池工厂）来创建。</p>
<p><strong>2.3.1 FixedThreadPool</strong></p>
<p>固定线程数线程池的创建方式如下：其中核心线程数与最大线程数固定且相等，采用以链表为底层结构的无界阻塞队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>核心线程数与最大线程数相等，因此不会创建空闲线程。keepAliveTime 设置与否无关紧要。</li>
<li>采用无界队列，任务会被无限添加，直至内存溢出（OOM）。</li>
<li>由于无界队列不可能被占满，任务在执行前不可能被拒绝（前提是线程池一直处于运行状态）。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于线程数固定的场景</li>
<li>适用负载比较重的服务器</li>
</ul>
<p><strong>2.3.2 SingleThreadExecutor</strong></p>
<p>单线程线程池的创建方式如下：其中核心线程数与最大线程数都为1，采用以链表为底层结构的无界阻塞队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<ul>
<li>与 FixedThreadPool 类似，只是线程数为1而已。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>适用单线程的场景。</li>
<li>适用于对提交任务的处理有顺序性要求的场景。</li>
</ul>
<p><strong>2.3.3 CachedThreadPool</strong></p>
<p>缓冲线程池的创建方式如下：其中核心线程数为0，最大线程数为Integer.MAX_VALUE（可以理解为无穷大）。采用同步阻塞队列。</p>
<p>- </p>
<p><strong>特点</strong>：</p>
<ul>
<li>核心线程数为0，则初始就创建空闲线程，并且空闲线程的只能等待任务60s，60s内没有提交任务，空闲线程将被销毁。</li>
<li>最大线程数为无穷大，这样会造成巨量线程同时运行，CPU负载过高，导致应用崩溃。</li>
<li>采用同步阻塞队列，即队列不存储任务。提交一个消费一个。由于最大线程数为无穷大，因此，只要提交任务就一定会被消费（应用未崩溃前）。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于耗时短、异步的小程序。</li>
<li>适用于负载较轻的服务器。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-28T10:06:35.000Z" title="2021/12/28 下午6:06:35">2021-12-28</time>发表</span><span class="level-item"><time dateTime="2021-12-28T10:06:35.000Z" title="2021/12/28 下午6:06:35">2021-12-28</time>更新</span><span class="level-item">3 分钟读完 (大约460个字)</span></div></div><div class="content"><h1 id="Spring-OXM实践"><a href="#Spring-OXM实践" class="headerlink" title="Spring OXM实践"></a>Spring OXM实践</h1><blockquote>
<p>示例代码仓库： <a target="_blank" rel="noopener" href="https://gitee.com/tonygeli/springoxmdemo">https://gitee.com/tonygeli/springoxmdemo</a></p>
</blockquote>
<h3 id="OXMapper是什么？"><a href="#OXMapper是什么？" class="headerlink" title="OXMapper是什么？"></a>OXMapper是什么？</h3><p>Spring3.0的一个新特性是O&#x2F;XMapper。O&#x2F;X映射器这个概念并不新鲜，O代表Object，X代表XML。它的目的是在Java对象（POJO）和XML文档之间来回转换。</p>
<h3 id="用途？"><a href="#用途？" class="headerlink" title="用途？"></a>用途？</h3><p>将Java对象转换为一个XML文档</p>
<p>要利用Spring的O&#x2F;X功能，您需要一个在Java对象和XML之间来回转换的实用程序。Castor就是这样一个流行的第三方工具，本文将使用这个工具。其他这样的工具包括XMLBeans、JavaArchitectureforXMLBinding(JAXB)、JiBX和XStream。</p>
<p>SpringO&#x2F;X框架只定义两个接口：Marshaller编组和Unmarshaller解组，它们用于执行O&#x2F;X功能，这是使用这个框架的另一个重大好处。这些接口的实现完全对独立开发人员开放，开发人员可以轻松切换它们而无需修改代码。例如，如果您一开始使用Castor进行O&#x2F;X转换，但后来发现它缺乏您需要的某个功能，这时您可以切换到XMLBeans而无需任何代码更改。唯一需要做的就是更改Spring配置文件以使用新的O&#x2F;X框架。</p>
<h3 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-oxm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.thoughtworks.xstream<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xstream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>AppConfig.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XStreamMarshaller <span class="title function_">XStreamMarshaller</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XStreamMarshaller</span> <span class="variable">xStreamMarshaller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStreamMarshaller</span>();</span><br><span class="line">        xStreamMarshaller.setSupportedClasses(Company.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// com.thoughtworks.xstream.security.ForbiddenClassException</span></span><br><span class="line">        <span class="type">AnyTypePermission</span> <span class="variable">anyTypePermission</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnyTypePermission</span>();</span><br><span class="line">        xStreamMarshaller.setTypePermissions(anyTypePermission);</span><br><span class="line">        <span class="keyword">return</span> xStreamMarshaller;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">annoCtx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        annoCtx.register(AppConfig.class);</span><br><span class="line">        annoCtx.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">XStreamMarshaller</span> <span class="variable">xStreamMarshaller</span> <span class="operator">=</span> annoCtx.getBean(XStreamMarshaller.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>();</span><br><span class="line">        company.setId(<span class="number">100</span>);</span><br><span class="line">        company.setCompanyName(<span class="string">&quot;PQR&quot;</span>);</span><br><span class="line">        company.setCeoName(<span class="string">&quot;MNO&quot;</span>);</span><br><span class="line">        company.setNoEmp(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        xStreamMarshaller.marshal(company, <span class="keyword">new</span> <span class="title class_">StreamResult</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;company.xml&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;marshal success&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Company</span> <span class="variable">outputCompany</span> <span class="operator">=</span> (Company) xStreamMarshaller.unmarshal(<span class="keyword">new</span> <span class="title class_">StreamSource</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;company.xml&quot;</span>)));</span><br><span class="line">        System.out.println(outputCompany);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-09T03:49:15.000Z" title="2021/12/9 上午11:49:15">2021-12-09</time>发表</span><span class="level-item"><time dateTime="2021-12-09T03:49:15.000Z" title="2021/12/9 上午11:49:15">2021-12-09</time>更新</span><span class="level-item">1 分钟读完 (大约150个字)</span></div></div><div class="content"><p>通过npm安装Vue CLI</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"></span><br><span class="line">vue create electron-vue</span><br><span class="line">&gt; Vue CLI v4.5.15</span><br><span class="line">&gt; Vue 3.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Installing-Electron-into-your-Vue-Application"><a href="#Installing-Electron-into-your-Vue-Application" class="headerlink" title="Installing Electron into your Vue Application"></a>Installing Electron into your Vue Application</h3><p>After creating our Vue project, let’s now install Electron in our Vue project using the following commands:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev electron@latest</span><br></pre></td></tr></table></figure>

<p>By using the <code>--save-dev</code> switch, Electron will be installed as a development dependency in your project.</p>
<p><code>&quot;electron&quot;: &quot;^16.0.4&quot;</code></p>
<h3 id="Bootstrapping-the-Electron-App"><a href="#Bootstrapping-the-Electron-App" class="headerlink" title="Bootstrapping the Electron App"></a>Bootstrapping the Electron App</h3><p>After installing Electron, you need to add some code to bootstrap your Electron app and create a GUI window where the Vue app will be opened.</p>
<p>Go ahead and create a <code>main.js</code> file inside your Vue project and add the following code:</p>
<p><a target="_blank" rel="noopener" href="https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-124092">https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-124092</a>   16h<br><a target="_blank" rel="noopener" href="https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-127197">https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-127197</a> 8h<br><a target="_blank" rel="noopener" href="https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-127198">https://ee.58corp.com/detail/iwork/v4/issue/detail/USER-127198</a>   8h</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">上一页</a></div><div class="pagination-next"><a href="/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/14/">14</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Tonygeli"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tonygeli</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SH</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">132</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tonygeli" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bean/"><span class="tag">Bean</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus/"><span class="tag">Icarus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySql/"><span class="tag">MySql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Netty/"><span class="tag">Netty</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stream/"><span class="tag">Stream</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"><span class="tag">公众号</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><span class="tag">分布式事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><span class="tag">单点登录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"><span class="tag">自动装配</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-07T01:46:49.745Z">2022-05-07</time></p><p class="title"><a href="/2022/05/07/90000%E6%96%87%E7%AB%A0/90012Bean%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E7%A5%9E%E5%99%A8Mapstruct/">自动转换神器 Mapstruct</a></p><p class="categories"><a href="/categories/Spring/">Spring</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-05T16:00:00.000Z">2022-05-06</time></p><p class="title"><a href="/2022/05/06/90000%E6%96%87%E7%AB%A0/90000Hexo%E9%85%8D%E7%BD%AE%E4%B8%8EIcarus%E4%B8%BB%E9%A2%98/">Hexo配置与Icarus主题</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-05T16:00:00.000Z">2022-05-06</time></p><p class="title"><a href="/2022/05/06/213Linux/Docker/Ubuntu%20LNMP/">Ubuntu LNMP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-04T16:29:42.493Z">2022-05-05</time></p><p class="title"><a href="/2022/05/05/90000%E6%96%87%E7%AB%A0/90005Stream%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/">90005Stream代码优化</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-29T15:15:26.673Z">2022-04-29</time></p><p class="title"><a href="/2022/04/29/30000Spring/30101%20SecurityContextHolder/"> </a></p></div></article></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a><p class="is-size-7"><span>&copy; 2022 Tonygeli</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>