<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>LILAIQUN</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LILAIQUN"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LILAIQUN"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="LILAIQUN"><meta property="og:url" content="https://tonygeli.github.io/"><meta property="og:site_name" content="LILAIQUN"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tonygeli.github.io/img/og_image.png"><meta property="article:author" content="Tonygeli"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonygeli.github.io"},"headline":"LILAIQUN","image":["https://tonygeli.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tonygeli"},"publisher":{"@type":"Organization","name":"LILAIQUN","logo":{"@type":"ImageObject","url":"https://tonygeli.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?1ecc72096a22e2426f0bc13519c3c3c7";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/article-17">Share</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-09T06:14:46.000Z" title="2021/6/9 下午2:14:46">2021-06-09</time>发表</span><span class="level-item"><time dateTime="2021-06-09T06:14:46.000Z" title="2021/6/9 下午2:14:46">2021-06-09</time>更新</span><span class="level-item">7 分钟读完 (大约1085个字)</span></div></div><div class="content"><h1 id="2-6-4HyperLogLog"><a href="#2-6-4HyperLogLog" class="headerlink" title="2.6.4HyperLogLog"></a>2.6.4HyperLogLog</h1><p>​	在开始这一节之前，我们先思考一个常见的业务问题：如果你负责开发维护一个大型的网站，有一天老板找产品经理要网站每个网页每天的 UV 数据，然后让你来开发这个统计模块，你会如何实现？</p>
<p>​	如果统计 PV 那非常好办，给每个网页一个独立的 Redis 计数器就可以了，这个计数器的 key 后缀加上当天的日期。这样来一个请求，incrby 一次，最终就可以统计出所有的 PV 数据。</p>
<p>​	但是 UV 不一样，它要去重，同一个用户一天之内的多次访问请求只能计数一次。这就要求每一个网页请求都需要带上用户的 ID，无论是登陆用户还是未登陆用户都需要一个唯一ID 来标识。</p>
<p>​	你也许已经想到了一个简单的方案，那就是为每一个页面一个独立的 set 集合来存储所有当天访问过此页面的用户 ID。当一个请求过来时，我们使用 sadd 将用户 ID 塞进去就可以了。通过 scard 可以取出这个集合的大小，这个数字就是这个页面的 UV 数据。没错，这是一个非常简单的方案。</p>
<p>​	但是，如果你的页面访问量非常大，比如一个爆款页面几千万的 UV，你需要一个很大的 set 集合来统计，这就非常浪费空间。如果这样的页面很多，那所需要的存储空间是惊人的。为这样一个去重功能就耗费这样多的存储空间，值得么？其实老板需要的数据又不需要太精确，105w 和 106w 这两个数字对于老板们来说并没有多大区别，So，有没有更好的解决方案呢？</p>
<p>​	这就是本节要引入的一个解决方案，Redis 提供了 HyperLogLog 数据结构就是用来解决这种统计问题的。HyperLogLog 提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，标准误差是 0.81%，这样的精确度已经可以满足上面的 UV 统计需求了。</p>
<p>​	HyperLogLog 数据结构是 Redis 的高级数据结构，它非常有用，但是令人感到意外的是，使用过它的人非常少。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>HyperLogLog 提供了两个指令 pfadd 和 pfcount，根据字面意义很好理解，一个是增加计数，一个是获取计数。pfadd 用法和 set 集合的 sadd 是一样的，来一个用户 ID，就将用户 ID 塞进去就是。pfcount 和 scard 用法是一样的，直接获取计数值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd codehole user1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user6</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user7 user8 user9 user10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PfTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			jedis.pfadd(<span class="string">&quot;codehole&quot;</span>, <span class="string">&quot;user&quot;</span> + i);</span><br><span class="line">      <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> jedis.pfcount(<span class="string">&quot;codehole&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (total != i + <span class="number">1</span>) &#123;</span><br><span class="line">				System.out.printf(<span class="string">&quot;%d %d\n&quot;</span>, total, i + <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; </span><br><span class="line">    &#125;</span><br><span class="line">		jedis.close();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>们将数据增加到 10w 差了 277 个，按百分比是 0.277%，对于上面的 UV 统计需求来说，误差率也不算高。然后我们把上面的脚本再跑一边，也就相当于将数据重复加入一边，查看输出，可以发现，pfcount 的结果没有任何改变，还是 99723，说明它确实具备去重功能。</p>
<h3 id="pfmerge适合什么场合用？"><a href="#pfmerge适合什么场合用？" class="headerlink" title="pfmerge适合什么场合用？"></a>pfmerge适合什么场合用？</h3><p>HyperLogLog 除了上面的 pfadd 和 pfcount 之外，还提供了第三个指令 pfmerge，用于将多个 pf 计数值累加在一起形成一个新的 pf 值。比如在网站中我们有两个内容差不多的页面，运营说需要这两个页面的数据进行合并。其中页面的 UV 访问量也需要合并，那这个时候 pfmerge 就可以派上用场了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-09T06:07:37.000Z" title="2021/6/9 下午2:07:37">2021-06-09</time>发表</span><span class="level-item"><time dateTime="2021-06-09T06:07:37.000Z" title="2021/6/9 下午2:07:37">2021-06-09</time>更新</span><span class="level-item">10 分钟读完 (大约1453个字)</span></div></div><div class="content"><h1 id="2-6-3位图"><a href="#2-6-3位图" class="headerlink" title="2.6.3位图"></a>2.6.3位图</h1><p><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">基本使用</a><br><a href="#%E7%BB%9F%E8%AE%A1%E5%92%8C%E6%9F%A5%E6%89%BE">统计和查找</a><br><a href="#%E9%AD%94%E6%9C%AF%E6%8C%87%E4%BB%A4bitfield">魔术指令bitfield</a></p>
<p>​	在我们平时开发过程中，会有一些 bool 型数据需要存取，比如用户一年的签到记录，签了是 1，没签是 0，要记录 365 天。如果使用普通的 key&#x2F;value，每个用户要记录 365 个，当用户上亿的时候，需要的存储空间是惊人的。</p>
<p>​	为了解决这个问题，Redis 提供了位图数据结构，这样每天的签到记录只占据一个位，365 天就是 365 个位，46 个字节 (一个稍长一点的字符串) 就可以完全容纳下，这就大大节约了存储空间。</p>
<p>​	位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组。我们可以使用普通的 get&#x2F;set 直接获取和设置整个位图的内容，也可以使用位图操作 <code>getbit</code>&#x2F;<code>setbit</code> 等将 byte 数组看成「位数组」来处理。</p>
<p>​	以老钱的经验，在面试中有 Redis 位图使用经验的同学很少，如果你对 Redis 的位图有所了解，它将会是你的面试加分项。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。</p>
<p>接下来我们使用位操作将字符串设置为 hello (不是直接使用 set 指令)，首先我们需要得到 hello 的 ASCII 码，用 Python 命令行可以很方便地得到每个字符的 ASCII 码的二进制值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;h&#x27;</span>)) </span><br><span class="line"><span class="string">&#x27;0b1101000&#x27;</span> <span class="comment"># 高位 -&gt; 低位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;e&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0b1100101&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;l&#x27;</span>)) </span><br><span class="line"><span class="string">&#x27;0b1101100&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;l&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0b1101100&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;o&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0b1101111&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../../images/WX20210608-190816@2x.png" alt="WX20210608-190816@2x"></p>
<p>接下来我们使用 <code>redis-cli</code> 设置第一个字符，也就是位数组的前 8 位，我们只需要设置值为 1 的位，如上图所示，h 字符只有 1&#x2F;2&#x2F;4 位需要设置，e 字符只有 9&#x2F;10&#x2F;13&#x2F;15 位需要设置。值得注意的是位数组的顺序和字符的位顺序是相反的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">2</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">4</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">9</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">10</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">13</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit s <span class="number">15</span> <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get s </span><br><span class="line"><span class="string">&quot;he&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子可以理解为「零存整取」，同样我们还也可以「零存零取」，「整存零取」。「零存」就是使用 setbit 对位值进行逐个设置，「整存」就是使用字符串一次性填充所有位数组，覆盖掉旧值。</p>
<p><strong>零存零取</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit w <span class="number">1</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit w <span class="number">2</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit w <span class="number">4</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">1</span> <span class="comment"># 获取某个具体位置的值 0/1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">2</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">4</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getbit w <span class="number">5</span></span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果对应位的字节是不可打印字符，redis-cli 会显示该字符的 16 进制形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit x <span class="number">0</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setbit x <span class="number">1</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get x</span><br><span class="line"><span class="string">&quot;\xc0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="统计和查找"><a href="#统计和查找" class="headerlink" title="统计和查找"></a>统计和查找</h3><p>​	Redis 提供了位图统计指令 bitcount 和位图查找指令 bitpos，bitcount 用来统计指定位置范围内 1 的个数，bitpos 用来查找指定范围内出现的第一个 0 或 1。</p>
<p>​	比如我们可以通过 bitcount 统计用户一共签到了多少天，通过 bitpos 指令查找用户从哪一天开始第一次签到。如果指定了范围参数[start, end]，就可以统计在某个时间范围内用户签到了多少天，用户自某天以后的哪天开始签到。</p>
<p>​	遗憾的是， start 和 end 参数是字节索引，也就是说指定的位范围必须是 8 的倍数，而不能任意指定。这很奇怪，我表示不是很能理解 Antirez 为什么要这样设计。因为这个设计，我们无法直接计算某个月内用户签到了多少天，而必须要将这个月所覆盖的字节内容全部取出来 (getrange 可以取出字符串的子串) 然后在内存里进行统计，这个非常繁琐。</p>
<p>接下来我们简单试用一下 bitcount 指令和 bitpos 指令:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitcount w</span><br><span class="line">(integer) <span class="number">21</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitcount w <span class="number">0</span> <span class="number">0</span> <span class="comment"># 第一个字符中 1 的位数</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitcount w <span class="number">0</span> <span class="number">1</span> <span class="comment"># 前两个字符中 1 的位数</span></span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">0</span> <span class="comment"># 第一个 0 位</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">1</span> <span class="comment"># 第一个 1 位</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="comment"># 从第二个字符算起，第一个 1 位</span></span><br><span class="line">(integer) <span class="number">9</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bitpos w <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="comment"># 从第三个字符算起，第一个 1 位</span></span><br><span class="line">(integer) <span class="number">17</span></span><br></pre></td></tr></table></figure>

<h3 id="魔术指令bitfield"><a href="#魔术指令bitfield" class="headerlink" title="魔术指令bitfield"></a>魔术指令bitfield</h3><p>前文我们设置 (<code>setbit</code>) 和获取 (<code>getbit</code>) 指定位的值都是单个位的，如果要一次操作多个位，就必须使用管道来处理。 不过 Redis 的 3.2 版本以后新增了一个功能强大的指令，有了这条指令，不用管道也可以一次进行多个位的操作。 bitfield 有三个子指令，分别是get&#x2F;set&#x2F;incrby，它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个子指令。</p>
<p><img src="/../../images/WX20210608-190816@2x-3150521.png" alt="WX20210608-190816@2x-3150521"></p>
<p>接下来我们对照着上面的图看个简单的例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get u4 0 <span class="comment"># 从第一个位开始取 4 个位，结果是无符号数 (u)</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get u3 2 <span class="comment"># 从第三个位开始取 3 个位，结果是无符号数 (u)</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get i4 0 <span class="comment"># 从第一个位开始取 4 个位，结果是有符号数 (i)</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get i3 2 <span class="comment"># 从第三个位开始取 3 个位，结果是有符号数 (i)</span></span><br><span class="line">(<span class="built_in">integer</span>) -3</span><br></pre></td></tr></table></figure>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-08T10:50:59.000Z" title="2021/6/8 下午6:50:59">2021-06-08</time>发表</span><span class="level-item"><time dateTime="2021-06-08T10:50:59.000Z" title="2021/6/8 下午6:50:59">2021-06-08</time>更新</span><span class="level-item">16 分钟读完 (大约2445个字)</span></div></div><div class="content"><h1 id="2-6-2延时队列"><a href="#2-6-2延时队列" class="headerlink" title="2.6.2延时队列"></a>2.6.2延时队列</h1><p><a href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">异步消息队列</a><br><a href="#%E9%98%9F%E5%88%97%E7%A9%BA%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F">队列空了怎么办？</a><br><a href="#%E9%98%9F%E5%88%97%E5%BB%B6%E8%BF%9F">队列延迟</a><br><a href="#%E7%A9%BA%E9%97%B2%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%8A%A8%E6%96%AD%E5%BC%80">空闲连接自动断开</a><br><a href="#%E9%94%81%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86">锁冲突处理</a><br><a href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">延时队列的实现</a></p>
<p>​	我们平时习惯于使用 Rabbitmq 和 Kafka 作为消息队列中间件，来给应用程序之间增加异步消息传递功能。这两个中间件都是专业的消息队列中间件，特性之多超出了大多数人的理解能力。</p>
<p>​	使用过 Rabbitmq 的同学知道它使用起来有多复杂，发消息之前要创建 Exchange，再创建 Queue，还要将 Queue 和 Exchange 通过某种规则绑定起来，发消息的时候要指定 routing-key，还要控制头部信息。消费者在消费消息之前也要进行上面一系列的繁琐过程。但是绝大多数情况下，虽然我们的消息队列只有一组消费者，但还是需要经历上面这些繁琐的过程。</p>
<p>​	有了 Redis，它就可以让我们解脱出来，对于那些只有一组消费者的消息队列，使用 Redis 就可以非常轻松的搞定。Redis 的消息队列不是专业的消息队列，它没有非常多的高级特性，没有 ack 保证，如果对消息的可靠性有着极致的追求，那么它就不适合使用。</p>
<h3 id="异步消息队列"><a href="#异步消息队列" class="headerlink" title="异步消息队列"></a>异步消息队列</h3><p>Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用<code>rpush</code>&#x2F;<code>lpush</code>操作入队列，使用 <code>lpop</code> 和 <code>rpop</code> 来出队列。</p>
<p><img src="/../../images/WX20210608-162235@2x.png" alt="WX20210608-162235@2x"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush notify-queue apple banana pear </span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line"><span class="string">&quot;apple&quot;</span></span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line"><span class="string">&quot;banana&quot;</span></span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 1 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line"><span class="string">&quot;pear&quot;</span></span><br><span class="line">&gt; llen notify-queue </span><br><span class="line">(<span class="built_in">integer</span>) 0 </span><br><span class="line">&gt; lpop notify-queue </span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h3 id="队列空了怎么办？"><a href="#队列空了怎么办？" class="headerlink" title="队列空了怎么办？"></a>队列空了怎么办？</h3><p>​	客户端是通过队列的 pop 操作来获取消息，然后进行处理。处理完了再接着获取消息，再进行处理。如此循环往复，这便是作为队列消费者的客户端的生命周期。</p>
<p>​	可是如果队列空了，客户端就会陷入 pop 的死循环，不停地 pop，没有数据，接着再 pop，又没有数据。这就是浪费生命的空轮询。空轮询不但拉高了客户端的 CPU，redis 的 QPS 也会被拉高，如果这样空轮询的客户端有几十来个，Redis 的慢查询可能会显著增多。</p>
<p>​	通常我们使用 sleep 来解决这个问题，让线程睡一会，睡个 1s 钟就可以了。不但客户端的 CPU 能降下来，Redis 的 QPS 也降下来了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>) # java 睡 1s</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/WX20210608-162458@2x.png" alt="WX20210608-162458@2x"></p>
<h3 id="队列延迟"><a href="#队列延迟" class="headerlink" title="队列延迟"></a>队列延迟</h3><p>用上面睡眠的办法可以解决问题。但是有个小问题，那就是睡眠会导致消息的延迟增大。如果只有 1 个消费者，那么这个延迟就是 1s。如果有多个消费者，这个延迟会有所下降，因为每个消费者的睡觉时间是岔开来的。</p>
<p>​	有没有什么办法能显著降低延迟呢？你当然可以很快想到：那就把睡觉的时间缩短点。这种方式当然可以，不过有没有更好的解决方案呢？当然也有，那就是 <code>blpop</code>&#x2F;<code>brpop</code>。</p>
<p>​	这两个指令的前缀字符 b 代表的是 <code>blocking</code>，也就是阻塞读。</p>
<p>​	阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。用 blpop&#x2F;brpop 替代前面的 lpop&#x2F;rpop，就完美解决了上面的问题。…</p>
<h3 id="空闲连接自动断开"><a href="#空闲连接自动断开" class="headerlink" title="空闲连接自动断开"></a>空闲连接自动断开</h3><p>​	你以为上面的方案真的很完美么？先别急着开心，其实他还有个问题需要解决。</p>
<p>​	什么问题？—— <strong>空闲连接</strong>的问题。</p>
<p>​	如果线程一直阻塞在哪里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用。这个时候 <code>blpop</code>&#x2F;<code>brpop</code> 会抛出异常来。</p>
<p>​	所以编写客户端消费者的时候要小心，注意捕获异常，还要重试。…</p>
<h3 id="锁冲突处理"><a href="#锁冲突处理" class="headerlink" title="锁冲突处理"></a>锁冲突处理</h3><p>​	上节课我们讲了分布式锁的问题，但是没有提到客户端在处理请求时加锁没加成功怎么办。一般有 3 种策略来处理加锁失败： </p>
<p>​	1、直接抛出异常，通知用户稍后重试；<br>​	2、sleep 一会再重试；<br>​	3、将请求转移至延时队列，过一会再试；</p>
<p><strong>直接抛出特定类型的异常</strong></p>
<p>这种方式比较适合由用户直接发起的请求，用户看到错误对话框后，会先阅读对话框的内容，再点击重试，这样就可以起到人工延时的效果。如果考虑到用户体验，可以由前端的代码替代用户自己来进行延时重试控制。它本质上是对当前请求的放弃，由用户决定是否重新发起新的请求。</p>
<p><strong>sleep</strong></p>
<p>sleep 会阻塞当前的消息处理线程，会导致队列的后续消息处理出现延迟。如果碰撞的比较频繁或者队列里消息比较多，sleep 可能并不合适。如果因为个别死锁的 key 导致加锁不成功，线程会彻底堵死，导致后续消息永远得不到及时处理。</p>
<p><strong>延时队列</strong></p>
<p>这种方式比较适合异步消息处理，将当前冲突的请求扔到另一个队列延后处理以避开冲突。</p>
<h3 id="延时队列的实现"><a href="#延时队列的实现" class="headerlink" title="延时队列的实现"></a>延时队列的实现</h3><p>延时队列可以通过 Redis 的 zset(有序列表) 来实现。我们将消息序列化成一个字符串作为 zset 的 value，这个消息的到期处理时间作为 score，然后用多个线程轮询 zset 获取到期的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delay</span>(<span class="params">msg</span>): </span><br><span class="line">	msg.<span class="built_in">id</span> = <span class="built_in">str</span>(uuid.uuid4()) <span class="comment"># 保证 value 值唯一</span></span><br><span class="line">	value = json.dumps(msg) </span><br><span class="line">	retry_ts = time.time() + <span class="number">5</span> <span class="comment"># 5 秒后重试</span></span><br><span class="line">	redis.zadd(<span class="string">&quot;delay-queue&quot;</span>, retry_ts, value) </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>(): </span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">		<span class="comment"># 最多取 1 条</span></span><br><span class="line">  	values = redis.zrangebyscore(<span class="string">&quot;delay-queue&quot;</span>, <span class="number">0</span>, time.time(), start=<span class="number">0</span>, num=<span class="number">1</span>) </span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> values: </span><br><span class="line">      time.sleep(<span class="number">1</span>) <span class="comment"># 延时队列空的，休息 1s</span></span><br><span class="line">			<span class="keyword">continue</span> </span><br><span class="line">		value = values[<span class="number">0</span>] <span class="comment"># 拿第一条，也只有一条</span></span><br><span class="line">		success = redis.zrem(<span class="string">&quot;delay-queue&quot;</span>, value) <span class="comment"># 从消息队列中移除该消息</span></span><br><span class="line">		<span class="keyword">if</span> success: <span class="comment"># 因为有多进程并发的可能，最终只会有一个进程可以抢到消息</span></span><br><span class="line">			msg = json.loads(value) </span><br><span class="line">			handle_msg(msg)</span><br></pre></td></tr></table></figure>

<p>​	Redis 的 zrem 方法是多线程多进程争抢任务的关键，它的返回值决定了当前实例有没有抢到任务，因为 <code>loop</code> 方法可能会被多个线程、多个进程调用，同一个任务可能会被多个进程线程抢到，通过 <code>zrem</code>来决定唯一的属主。</p>
<p>​	同时，我们要注意一定要对 handle_msg 进行异常捕获，避免因为个别任务处理问题导致循环异常退出。以下是 Java 版本的延时队列实现，因为要使用到 Json 序列化，所以还需要 <code>fastjson</code> 库的支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.TypeReference;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDelayingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TaskItem</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> String id;</span><br><span class="line">        <span class="keyword">public</span> T msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fastjson 序列化对象中存在 generic 类型时，需要使用 TypeReference</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Type</span> <span class="variable">TaskType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;TaskItem&lt;T&gt;&gt;() &#123;</span><br><span class="line">    &#125;.getType();</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisDelayingQueue</span><span class="params">(Jedis jedis, String queueKey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">        <span class="built_in">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delay</span><span class="params">(T msg)</span> &#123;</span><br><span class="line">        <span class="type">TaskItem</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskItem</span>();</span><br><span class="line">        task.id = UUID.randomUUID().toString(); <span class="comment">// 分配唯一的 uuid</span></span><br><span class="line">        task.msg = msg;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(task); <span class="comment">// fastjson 序列化</span></span><br><span class="line">        jedis.zadd(queueKey, System.currentTimeMillis() + <span class="number">5000</span>, s); <span class="comment">// 塞入延时队列 ,5s 后再试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line"><span class="comment">// 只取一条</span></span><br><span class="line">            <span class="type">Set</span> <span class="variable">values</span> <span class="operator">=</span> jedis.zrangeByScore(queueKey, <span class="number">0</span>, System.currentTimeMillis(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (values.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>); <span class="comment">// 歇会继续</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> values.iterator().next();</span><br><span class="line">            <span class="keyword">if</span> (jedis.zrem(queueKey, s) &gt; <span class="number">0</span>) &#123; <span class="comment">// 抢到了</span></span><br><span class="line">                <span class="type">TaskItem</span> <span class="variable">task</span> <span class="operator">=</span> JSON.parseObject(s, TaskType); <span class="comment">// fastjson 反序列化</span></span><br><span class="line">                <span class="built_in">this</span>.handleMsg(task.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMsg</span><span class="params">(T msg)</span> &#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();</span><br><span class="line">        <span class="type">RedisDelayingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisDelayingQueue</span>&lt;&gt;(jedis, <span class="string">&quot;q-demo&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    queue.delay(<span class="string">&quot;codehole&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                queue.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.join();</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            consumer.interrupt();</span><br><span class="line">            consumer.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>进一步优化</strong></p>
<p>上面的算法中同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到的进程都是白取了一次任务，这是浪费。可以考虑使用 lua scripting 来优化一下这个逻辑，将zrangebyscore 和 zrem 一同挪到服务器端进行原子化操作，这样多个进程之间争抢任务时就不会出现这种浪费了。</p>
<p><strong>思考</strong></p>
<p>1、Redis 作为消息队列为什么不能保证 100% 的可靠性？ </p>
<p>2、使用 Lua Scripting 来优化延时队列的逻辑。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-08T08:14:33.000Z" title="2021/6/8 下午4:14:33">2021-06-08</time>发表</span><span class="level-item"><time dateTime="2021-06-08T08:14:33.000Z" title="2021/6/8 下午4:14:33">2021-06-08</time>更新</span><span class="level-item">13 分钟读完 (大约1919个字)</span></div></div><div class="content"><h1 id="2-6-1-分布式锁"><a href="#2-6-1-分布式锁" class="headerlink" title="2.6.1.分布式锁"></a>2.6.1.分布式锁</h1><p><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a><br><a href="#%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98">超时问题</a><br><a href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7">可重入性</a></p>
<p>分布式应用进行逻辑处理时经常会遇到并发问题。</p>
<p>比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。（Wiki 解释：所谓<strong>原子操作</strong>是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch 线程切换。）</p>
<p><img src="/../../images/WX20210608-102304@2x.png" alt="WX20210608-102304@2x"></p>
<p>这个时候就要使用到分布式锁来限制程序的并发执行。Redis 分布式锁使用非常广泛，它是面试的重要考点之一，很多同学都知道这个知识，也大致知道分布式锁的原理，但是具体到细节的使用上往往并不完全正确。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这里的冒号:就是一个普通的字符，没特别含义，它可以是任意其它字符，不要误解</span><br><span class="line">&gt; setnx lock:codehole <span class="literal">true</span></span><br><span class="line">OK</span><br><span class="line">... <span class="keyword">do</span> something critical ...</span><br><span class="line">&gt; del lock:codehole</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>​	但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p>
<p>​	于是我们在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:codehole <span class="literal">true</span></span><br><span class="line">OK</span><br><span class="line">&gt; expire lock:codehole 5</span><br><span class="line">... <span class="keyword">do</span> something critical ...</span><br><span class="line">&gt; del lock:codehole</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>​	但是以上逻辑还有问题。<strong>如果在 setnx 和 expire 之间服务器进程突然挂掉了</strong>，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p>
<p>​	这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。也许你会想到用 Redis 事务来解决。但是这里不行，因为 expire 是依赖于 setnx 的执行结果的，如果 setnx 没抢到锁，expire 是不应该执行的。事务里没有 if-else 分支逻辑，事务的特点是一口气执行，要么全部执行要么一个都不执行。</p>
<p>​	为了解决这个疑难，Redis 开源社区涌现了一堆分布式锁的 library，专门用来解决这个问题。实现方法极为复杂，小白用户一般要费很大的精力才可以搞懂。如果你需要使用分布式锁，意味着你不能仅仅使用 Jedis 或者 redis-py 就行了，还得引入分布式锁的 library。 </p>
<p><img src="/../../images/WX20210608-104119@2x.png" alt="WX20210608-104119@2x"></p>
<p>​	为了治理这个乱象，Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 <code>setnx</code> 和<code>expire</code> 指令可以一起执行，彻底解决了分布式锁的乱象。从此以后所有的第三方分布式锁library 可以休息了。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> lock:codehole <span class="literal">true</span> ex 5 nx </span><br><span class="line">OK ... <span class="keyword">do</span> something critical ... </span><br><span class="line">&gt; del lock:codehole</span><br></pre></td></tr></table></figure>

<p> 上面这个指令就是 setnx 和 expire 组合在一起的原子指令，它就是分布式锁的奥义所在。</p>
<h3 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h3><p>Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁，但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻辑执行完之间拿到了锁。</p>
<p>为了避免这个问题，Redis 分布式锁不要用于较长时间的任务。如果真的偶尔出现了，数据出现的小波错乱可能需要人工介入解决。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag = random.nextint() <span class="comment"># 随机数</span></span><br><span class="line"><span class="keyword">if</span> redis.set(key, tag, nx=True, ex=5):</span><br><span class="line">	do_something()</span><br><span class="line">redis.delifequals(key, tag) <span class="comment"># 不存在的 delifequals 指令</span></span><br></pre></td></tr></table></figure>

<p>有一个更加安全的方案是为 set 指令的 value 参数设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key。但是匹配 value 和删除 key 不是一个原子操作，Redis 也没有提供类似于 delifequals 这样的指令，这就需要使用 Lua 脚本来处理了，因为 Lua 脚本可以保证连续多个指令的原子性执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delifequals</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[1]) == ARGV[1] <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[1])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">return</span> 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>可重入性是指线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，那么这个锁就是可重入的。比如 Java 语言里有个 ReentrantLock 就是可重入锁。Redis 分布式锁如果要支持可重入，需要对客户端的 set 方法进行包装，使用线程的 Threadlocal 变量存储当前持有锁的计数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 </span></span><br><span class="line"><span class="keyword">import</span> redis </span><br><span class="line"><span class="keyword">import</span> threading </span><br><span class="line">locks = threading.local() </span><br><span class="line">locks.redis = &#123;&#125; </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">key_for</span>(<span class="params">user_id</span>): </span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;account_&#123;&#125;&quot;</span>.<span class="built_in">format</span>(user_id) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_lock</span>(<span class="params">client, key</span>): </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">bool</span>(client.<span class="built_in">set</span>(key, <span class="literal">True</span>, nx=<span class="literal">True</span>, ex=<span class="number">5</span>)) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_unlock</span>(<span class="params">client, key</span>): </span><br><span class="line">	client.delete(key) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lock</span>(<span class="params">client, user_id</span>): </span><br><span class="line">  key = key_for(user_id) </span><br><span class="line">	<span class="keyword">if</span> key <span class="keyword">in</span> locks.redis:</span><br><span class="line">		locks.redis[key] += <span class="number">1</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">	ok = _lock(client, key) </span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> ok: </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">	locks.redis[key] = <span class="number">1</span> </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unlock</span>(<span class="params">client, user_id</span>): </span><br><span class="line">	key = key_for(user_id) </span><br><span class="line">	<span class="keyword">if</span> key <span class="keyword">in</span> locks.redis: </span><br><span class="line">		locks.redis[key] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> locks.redis[key] &lt;= <span class="number">0</span>: </span><br><span class="line">			<span class="keyword">del</span> locks.redis[key] </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">client = redis.StrictRedis() </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;lock&quot;</span>, lock(client, <span class="string">&quot;codehole&quot;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;lock&quot;</span>, lock(client, <span class="string">&quot;codehole&quot;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;unlock&quot;</span>, unlock(client, <span class="string">&quot;codehole&quot;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;unlock&quot;</span>, unlock(client, <span class="string">&quot;codehole&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上还不是可重入锁的全部，精确一点还需要考虑内存锁计数的过期时间，代码复杂度将会继续升高。老钱不推荐使用可重入锁，它加重了客户端的复杂性，在编写业务方法时注意在逻辑结构上进行调整完全可以不使用可重入锁。下面是 Java 版本的可重入锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisWithReentrantLock</span> &#123; </span><br><span class="line">	<span class="keyword">private</span> ThreadLocal&lt;Map&gt; lockers = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(); </span><br><span class="line">	<span class="keyword">private</span> Jedis jedis; </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RedisWithReentrantLock</span><span class="params">(Jedis jedis)</span> &#123; </span><br><span class="line">		<span class="built_in">this</span>.jedis = jedis; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">_lock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> jedis.set(key, <span class="string">&quot;&quot;</span>, <span class="string">&quot;nx&quot;</span>, <span class="string">&quot;ex&quot;</span>, <span class="number">5L</span>) != <span class="literal">null</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">_unlock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		jedis.del(key); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">private</span> Map &lt;String, Integer&gt; currentLockers() &#123; </span><br><span class="line">		Map &lt;String, Integer&gt; refs = lockers.get(); </span><br><span class="line">		<span class="keyword">if</span> (refs != <span class="literal">null</span>) &#123; </span><br><span class="line">			<span class="keyword">return</span> refs; </span><br><span class="line">		&#125; </span><br><span class="line">		lockers.set(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()); </span><br><span class="line">		<span class="keyword">return</span> lockers.get(); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		<span class="type">Map</span> <span class="variable">refs</span> <span class="operator">=</span> currentLockers(); </span><br><span class="line">		<span class="type">Integer</span> <span class="variable">refCnt</span> <span class="operator">=</span> refs.get(key); </span><br><span class="line">		<span class="keyword">if</span> (refCnt != <span class="literal">null</span>) &#123; </span><br><span class="line">			refs.put(key, refCnt + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="built_in">this</span>._lock(key); </span><br><span class="line">		<span class="keyword">if</span> (!ok) &#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		refs.put(key, <span class="number">1</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	&#125; </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123; </span><br><span class="line">		<span class="type">Map</span> <span class="variable">refs</span> <span class="operator">=</span> currentLockers();</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">refCnt</span> <span class="operator">=</span> refs.get(key); </span><br><span class="line">		<span class="keyword">if</span> (refCnt == <span class="literal">null</span>) &#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		refCnt -= <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">if</span> (refCnt &gt; <span class="number">0</span>) &#123; </span><br><span class="line">			refs.put(key, refCnt); </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">			refs.remove(key);</span><br><span class="line">			<span class="built_in">this</span> ._unlock(key); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">		<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(); </span><br><span class="line">		<span class="type">RedisWithReentrantLock</span> <span class="variable">redis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisWithReentrantLock</span>(jedis); </span><br><span class="line">		System.out.println(redis.lock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">		System.out.println(redis.lock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">		System.out.println(redis.unlock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">		System.out.println(redis.unlock(<span class="string">&quot;codehole&quot;</span>)); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2021/06/01/90000%E6%96%87%E7%AB%A0/90010%E5%90%8C%E5%9F%9F%E4%B8%8B%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><img class="fill" src="/../../images/cover10.jpg" alt="90010同域下的单点登录"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-01T03:07:53.000Z" title="2021/6/1 上午11:07:53">2021-06-01</time>发表</span><span class="level-item"><time dateTime="2022-05-08T11:55:11.885Z" title="2022/5/8 下午7:55:11">2022-05-08</time>更新</span><span class="level-item">10 分钟读完 (大约1542个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/01/90000%E6%96%87%E7%AB%A0/90010%E5%90%8C%E5%9F%9F%E4%B8%8B%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/">90010同域下的单点登录</a></h1><div class="content"><h2 id="同域下的单点登录"><a href="#同域下的单点登录" class="headerlink" title="同域下的单点登录"></a>同域下的单点登录</h2><p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。</p>
<p>我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：</p>
<ul>
<li>Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。</li>
<li>sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。</li>
</ul>
<p><img src="/../../images/4e31c204eea22ee07154df928a5ff5350da03d7a.png" alt="image"></p>
<p>那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。<strong>我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。</strong></p>
<p>Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。</p>
<p>同域下的单点登录就实现了，<strong>但这还不是真正的单点登录。</strong></p>
<h2 id="不同域下的单点登录"><a href="#不同域下的单点登录" class="headerlink" title="不同域下的单点登录"></a>不同域下的单点登录</h2><p>同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？</p>
<p>这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。<br><img src="/../../images/dcb743204f8a201be53df5338fc34affe5fa1059.png" alt="cas_flow_diagram"></p>
<p>上图是CAS官网上的标准流程，具体流程如下：</p>
<ol>
<li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li>
<li>跳转到CAS server，即SSO登录系统，<strong>以后图中的CAS Server我们统一叫做SSO系统。</strong> SSO系统也没有登录，弹出用户登录页。</li>
<li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li>
<li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</li>
<li>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li>
<li>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</li>
</ol>
<p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p>
<ol>
<li>用户访问app2系统，app2系统没有登录，跳转到SSO。</li>
<li>由于SSO已经登录了，不需要重新登录认证。</li>
<li>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</li>
<li>app2拿到ST，后台访问SSO，验证ST是否有效。</li>
<li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li>
</ol>
<p>这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。</p>
<p><strong>有的同学问我，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？</strong></p>
<p><strong>其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单点登录（SSO）的所有流程都介绍完了，原理大家都清楚了。总结一下单点登录要做的事情：</p>
<ul>
<li><strong>单点登录（SSO系统）是保障各业务系统的用户资源的安全 。</strong></li>
<li><strong>各个业务系统获得的信息是，这个用户能不能访问我的资源。</strong></li>
<li><strong>单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。</strong></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-31T06:15:14.000Z" title="2021/5/31 下午2:15:14">2021-05-31</time>发表</span><span class="level-item"><time dateTime="2021-05-31T06:15:14.000Z" title="2021/5/31 下午2:15:14">2021-05-31</time>更新</span><span class="level-item">11 分钟读完 (大约1607个字)</span></div></div><div class="content"><h1 id="集群1——-Sentinel"><a href="#集群1——-Sentinel" class="headerlink" title="集群1—— Sentinel"></a>集群1—— Sentinel</h1><p>目前我们讲的 Redis 还只是主从方案，最终一致性。读者们可思考过，如果主节点凌晨3 点突发宕机怎么办？就坐等运维从床上爬起来，然后手工进行从主切换，再通知所有的程序把地址统统改一遍重新上线么？毫无疑问，这样的人工运维效率太低，事故发生时估计得至少 1 个小时才能缓过来。如果是一个大型公司，这样的事故足以上新闻了。</p>
<p>所以我们必须有一个高可用方案来抵抗节点故障，当故障发生时可以自动进行从主切换，程序可以不用重启，运维可以继续睡大觉，仿佛什么事也没发生一样。Redis 官方提供了这样一种方案 —— Redis Sentinel(哨兵)。</p>
<img src="../../images/WX20210531-095606@2x.png" alt="WX20210531-095606@2x" style="zoom:50%;" />

<p>我们可以将 Redis Sentinel 集群看成是一个 ZooKeeper 集群，它是集群高可用的心脏，它一般是由 3～5 个节点组成，这样挂了个别节点集群还可以正常运转。它负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时，客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户端。如此应用程序将无需重启即可自动完成节点切换。比如上图的主节点挂掉后，集群将可能自动调整为下图所示结构。</p>
<img src="../../images/WX20210531-095636@2x.png" alt="WX20210531-095636@2x" style="zoom:50%;" />

<p>从这张图中我们能看到主节点挂掉了，原先的主从复制也断开了，客户端和损坏的主节点也断开了。从节点被提升为新的主节点，其它从节点开始和新的主节点建立复制关系。客户端通过新的主节点继续进行交互。Sentinel 会持续监控已经挂掉了主节点，待它恢复后，集群会调整为下面这张图。</p>
<img src="../../images/WX20210531-095748@2x.png" alt="WX20210531-095748@2x" style="zoom:50%;" />

<p>此时原先挂掉的主节点现在变成了从节点，从新的主节点那里建立复制关系。</p>
<h3 id="1-消息丢失"><a href="#1-消息丢失" class="headerlink" title="1.消息丢失"></a>1.消息丢失</h3><p>Redis 主从采用异步复制，意味着当主节点挂掉时，从节点可能没有收到全部的同步消息，这部分未同步的消息就丢失了。如果主从延迟特别大，那么丢失的数据就可能会特别多。Sentinel 无法保证消息完全不丢失，但是也尽可能保证消息少丢失。它有两个选项可以限制主从延迟过大。</p>
<p>min-slaves-to-write 1</p>
<p>min-slaves-max-lag 10</p>
<p>第一个参数表示主节点必须至少有一个从节点在进行正常复制，否则就<strong>停止对外写服务，丧失可用性</strong>。何为正常复制，何为异常复制？这个就是由第二个参数控制的，它的单位是秒，表示如果 10s 没有收到从节点的反馈，就意味着从节点同步不正常，要么网络断开了，要么一直没有给反馈。</p>
<h3 id="2-Sentinel基本使用"><a href="#2-Sentinel基本使用" class="headerlink" title="2.Sentinel基本使用"></a>2.Sentinel基本使用</h3><p>接下来我们看看客户端如何使用 sentinel，标准的流程应该是客户端可以通过 sentinel发现主从节点的地址，然后在通过这些地址建立相应的连接来进行数据存取操作。我们来看看 Python 客户端是如何做的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> redis.sentinel <span class="keyword">import</span> Sentinel</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sentinel = Sentinel([(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">26379</span>)], socket_timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sentinel.discover_master(<span class="string">&#x27;mymaster&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">6379</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sentinel.discover_slaves(<span class="string">&#x27;mymaster&#x27;</span>)</span><br><span class="line">[(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">6380</span>)]</span><br></pre></td></tr></table></figure>

<p>sentinel 的默认端口是 26379，不同于 Redis 的默认端口 6379，通过 sentinel 对象的</p>
<p><code>discover_master</code> <code>discover_slaves</code> 方法可以发现主从地址，主地址只有一个，从地址可以有多个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>master = sentinel.master_for(<span class="string">&#x27;mymaster&#x27;</span>, socket_timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slave = sentinel.slave_for(<span class="string">&#x27;mymaster&#x27;</span>, socket_timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>master.<span class="built_in">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slave.get(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过 xxx_for 方法可以从连接池中拿出一个连接来使用，因为从地址有多个，redis 客户端对从地址采用轮询方案，也就是 RoundRobin 轮着来。</p>
<p>有个问题是，但 sentinel 进行主从切换时，客户端如何知道地址变更了 ? 通过分析源码，我发现 redis-py 在建立连接的时候进行了主库地址变更判断。<strong>连接池建立新连接时</strong>，会去查询主库地址，然后跟内存中的主库地址进行比对，如果变更了，就断开所有连接，<strong>重新使用新地址建立新连接</strong>。如果是旧的主库挂掉了，那么所有正在使用的连接都会被关闭，然后在重连时就会用上新地址。</p>
<p>但是这样还不够，如果是 sentinel 主动进行主从切换，主库并没有挂掉，而之前的主库连接已经建立了在使用了，没有新连接需要建立，那这个连接是不是一致切换不了？继续深入研究源码，我发现 redis-py 在另外一个点也做了控制。那就是在处理命令的时候捕获了一个特殊的异常 ReadOnlyError，在这个异常里将所有的旧连接全部关闭了，后续指令就会进行重连。<strong>主从切换后，之前的主库被降级到从库，所有的修改性的指令都会抛出 ReadonlyError。</strong></p>
<p>如果没有修改性指令，虽然连接不会得到切换，但是数据不会被破坏，所以即使不切换也没关系。</p>
<p>作业</p>
<p>1、尝试自己搭建一套 redis-sentinel 集群；</p>
<p>2、使用 Python 或者 Java 的客户端对集群进行一些常规操作；</p>
<p>3、试试主从切换，主动切换和被动切换都试一试，看看客户端能否正常切换连接；</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-31T06:14:43.000Z" title="2021/5/31 下午2:14:43">2021-05-31</time>发表</span><span class="level-item"><time dateTime="2021-05-31T06:14:43.000Z" title="2021/5/31 下午2:14:43">2021-05-31</time>更新</span><span class="level-item">14 分钟读完 (大约2171个字)</span></div></div><div class="content"><h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p>[1.CAP原理](#1.CAP 原理)<br><a href="#2.%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4">2.最终一致</a><br><a href="#3.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5">3.主从同步</a><br><a href="#4.%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5">4.增量同步</a><br><a href="#5.%E5%BF%AB%E7%85%A7%E5%90%8C%E6%AD%A5">5.快照同步</a><br><a href="#6.%E5%A2%9E%E5%8A%A0%E4%BB%8E%E8%8A%82%E7%82%B9">6.增加从节点</a><br><a href="#7.%E6%97%A0%E7%9B%98%E5%A4%8D%E5%88%B6">7.无盘复制</a><br><a href="#8.Wait%E6%8C%87%E4%BB%A4">8.Wait指令</a><br><a href="#9.%E5%B0%8F%E7%BB%93">9.小结</a><br>[10.集群1—— Sentinel](#10.集群1—— Sentinel)<br><a href="#11.%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1">11.消息丢失</a><br><a href="#12.Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">12.Sentinel基本使用</a></p>
<p>很多企业都没有使用到 Redis 的集群，但是至少都做了主从。有了主从，当 master 挂掉的时候，运维让从库过来接管，服务就可以继续，否则 master 需要经过数据恢复和重启的过程，这就可能会拖很长的时间，影响线上业务的持续服务。</p>
<p>在了解 Redis 的主从复制之前，让我们先来理解一下现代分布式系统的理论基石——CAP 原理。</p>
<h3 id="1-CAP-原理"><a href="#1-CAP-原理" class="headerlink" title="1.CAP 原理"></a>1.CAP 原理</h3><p>CAP 原理就好比分布式领域的牛顿定律，它是分布式存储的理论基石。自打 CAP 的论文发表之后，分布式存储中间件犹如雨后春笋般一个一个涌现出来。理解这个原理其实很简单，本节我们首先对这个原理进行一些简单的讲解。</p>
<p><strong>C</strong> - <strong>C</strong>onsistent ，一致性<br><strong>A</strong> - <strong>A</strong>vailability ，可用性<br><strong>P</strong> - <strong>P</strong>artition tolerance ，分区容忍性</p>
<p>分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着「<strong>网络分区</strong>」。在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的「一致性」将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲「可用性」，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。</p>
<img src="../../images/WX20210531-095055@2x.png" alt="WX20210531-095055@2x" style="zoom:50%;" />

<p>一句话概括 CAP 原理就是——<strong>网络分区发生时，一致性和可用性两难全</strong>。 </p>
<h3 id="2-最终一致"><a href="#2-最终一致" class="headerlink" title="2.最终一致"></a>2.最终一致</h3><p>​	Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足「<strong>一致性</strong>」要求。当客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以 Redis 满足「<strong>可用性</strong>」。<br>​	Redis 保证「<strong>最终一致性</strong>」，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。</p>
<h3 id="3-主从同步"><a href="#3-主从同步" class="headerlink" title="3.主从同步"></a>3.主从同步</h3><p>Redis 同步支持主从同步和从从同步，从库同步功能是 Redis 后续版本增加的功能，为了减轻主库的同步负担。后面为了描述上的方便，统一理解为主从同步。</p>
<img src="../../images/WX20210531-095334@2x.png" alt="WX20210531-095334@2x" style="zoom:50%;" />



<h3 id="4-增量同步"><a href="#4-增量同步" class="headerlink" title="4.增量同步"></a>4.增量同步</h3><p>Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一遍向主节点反馈自己同步到哪里了 (偏移量)。因为内存的 buffer 是有限的，所以 Redis 主库不能将所有的指令都记录在内存 buffer中。Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。</p>
<p>如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么当网络状况恢复时，Redis 的主节点中那些没有同步的指令在 buffer 中有可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制 — — 快照同步。</p>
<h3 id="5-快照同步"><a href="#5-快照同步" class="headerlink" title="5.快照同步"></a>5.快照同步</h3><p>快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次 bgsave 将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空。加载完毕后通知主节点继续进行增量同步。</p>
<p>在整个快照同步进行的过程中，主节点的复制 buffer 还在不停的往前移动，如果快照同步的时间过长或者复制 buffer 太小，都会导致同步期间的增量指令在复制 buffer 中被覆盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如此极有可能会陷入快照同步的死循环。</p>
<img src="../../images/WX20210531-095441@2x.png" alt="WX20210531-095441@2x" style="zoom:50%;" />

<p>所以务必配置一个合适的复制 buffer 大小参数，避免快照复制的死循环。</p>
<h3 id="6-增加从节点"><a href="#6-增加从节点" class="headerlink" title="6.增加从节点"></a>6.增加从节点</h3><p>当从节点刚刚加入到集群时，它必须先要进行一次快照同步，同步完成后再继续进行增量同步。</p>
<h3 id="7-无盘复制"><a href="#7-无盘复制" class="headerlink" title="7.无盘复制"></a>7.无盘复制</h3><p>主节点在进行快照同步时，会进行很重的文件 IO 操作，特别是对于非 SSD 磁盘存储时，快照会对系统的负载产生较大影响。特别是当系统正在进行 AOF 的 fsync 操作时如果发生快照，fsync 将会被推迟执行，这就会严重影响主节点的服务效率。</p>
<p>所以从 Redis 2.8.18 版开始支持无盘复制。所谓无盘复制是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一遍将序列化的内容发送到从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。</p>
<h3 id="8-Wait指令"><a href="#8-Wait指令" class="headerlink" title="8.Wait指令"></a>8.Wait指令</h3><p>Redis 的复制是异步进行的，wait 指令可以让异步复制变身同步复制，确保系统的强一致性 (不严格)。wait 指令是 Redis3.0 版本以后才出现的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> key value</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">wait</span> 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>wait 提供两个参数，第一个参数是从库的数量 N，第二个参数是时间 t，以毫秒为单位。它表示等待 wait 指令之前的所有写操作同步到 N 个从库 (也就是确保 N 个从库的同步没有滞后)，最多等待时间 t。如果时间 t&#x3D;0，表示无限等待直到 N 个从库同步完成达成一致。</p>
<p>假设此时出现了网络分区，wait 指令第二个参数时间 t&#x3D;0，主从同步无法继续进行，wait 指令会永远阻塞，Redis 服务器将丧失可用性。</p>
<h3 id="9-小结"><a href="#9-小结" class="headerlink" title="9.小结"></a>9.小结</h3><p>主从复制是 Redis 分布式的基础，Redis 的高可用离开了主从复制将无从进行。后面的章节我们会开始讲解 Redis 的集群模式，这几种集群模式都依赖于本节所讲的主从复制。不过复制功能也不是必须的，如果你将 Redis 只用来做缓存，跟 memcache 一样来对待，也就无需要从库做备份，挂掉了重新启动一下就行。但是只要你使用了 Redis 的持久化功能，就必须认真对待主从复制，它是系统数据安全的基础保障。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-31T01:35:50.000Z" title="2021/5/31 上午9:35:50">2021-05-31</time>发表</span><span class="level-item"><time dateTime="2021-05-31T01:35:50.000Z" title="2021/5/31 上午9:35:50">2021-05-31</time>更新</span><span class="level-item">1 分钟读完 (大约158个字)</span></div></div><div class="content"><p>MyISAM 和 InnoDB</p>
<p>不支持事务，每次查询都是原子的<br>表级锁，每次操作对全表加锁<br>存储表的总行数</p>
<p>索引文件、表结构文件、数据文件</p>
<p>采用非聚集索引，索引文件的数据存储指向数据文件的指针。辅索引和主索引基本一致，但辅助索引不能保证唯一性。</p>
<p>支持事务，4种隔离级别</p>
<p>行锁，支持并发写<br>不存总行数</p>
<p>索引类型及对数据库的性能的影响</p>
<p>普通、唯一、主键、联合、全文、</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-28T07:17:08.000Z" title="2021/5/28 下午3:17:08">2021-05-28</time>发表</span><span class="level-item"><time dateTime="2021-05-28T07:17:08.000Z" title="2021/5/28 下午3:17:08">2021-05-28</time>更新</span><span class="level-item">19 分钟读完 (大约2795个字)</span></div></div><div class="content"><h1 id="Redis集群的5种使用方式，及各自优缺点对比分析"><a href="#Redis集群的5种使用方式，及各自优缺点对比分析" class="headerlink" title="Redis集群的5种使用方式，及各自优缺点对比分析"></a>Redis集群的5种使用方式，及各自优缺点对比分析</h1><p>本文主要针对 Redis 常见的几种使用方式及其优缺点展开分析。</p>
<h1 id="一、常见使用方式"><a href="#一、常见使用方式" class="headerlink" title="一、常见使用方式"></a>一、常见使用方式</h1><p>Redis 的几种常见使用方式包括：</p>
<ul>
<li>Redis 单副本</li>
<li>Redis 多副本(主从)</li>
<li>Redis Sentinel(哨兵)</li>
<li>Redis Cluster</li>
<li>Redis 自研</li>
</ul>
<h1 id="二、各种使用方式的优缺点"><a href="#二、各种使用方式的优缺点" class="headerlink" title="二、各种使用方式的优缺点"></a>二、各种使用方式的优缺点</h1><p><strong>1、Redis 单副本</strong></p>
<p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p>
<p><img src="/../../images/23da1428f47c4de7a6eeeacc5d5fde31.jpeg" alt="Redis集群的5种使用方式，及各自优缺点对比分析"></p>
<p><strong>优点：</strong></p>
<p>架构简单，部署方便;</p>
<p>高性价比：缓存使用时无需备用节点(单实例可用性可以用 supervisor 或 crontab 保证)，当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务;</p>
<p>高性能。</p>
<p><strong>缺点：</strong></p>
<p>不保证数据的可靠性;</p>
<p>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务;</p>
<p>高性能受限于单核 CPU 的处理能力(Redis 是单线程机制)，CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代。</p>
<p><strong>2、Redis 多副本(主从)</strong></p>
<p>Redis 多副本，采用主从(replication)部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。</p>
<p><img src="/../../images/8120aa689db94dcf87083f048b64dab9.jpeg" alt="Redis集群的5种使用方式，及各自优缺点对比分析"></p>
<p><strong>优点：</strong></p>
<p>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行;另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题;</p>
<p>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</p>
<p><strong>缺点：</strong></p>
<p>故障恢复复杂，如果没有 RedisHA 系统(需要开发)，当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐;</p>
<p>主库的写能力受到单机的限制，可以考虑分片;</p>
<p>主库的存储能力受到单机的限制，可以考虑 Pika;</p>
<p>原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿;又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机;主库节点生成备份文件导致服务器磁盘 IO 和 CPU(压缩)资源消耗;发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</p>
<p><strong>3、Redis Sentinel(哨兵)</strong></p>
<p>Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。</p>
<p>其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1(n&gt;&#x3D;1)的奇数个。</p>
<p><img src="/../../images/667e7d7682cc4b02b287be6211b071ab.jpeg" alt="Redis集群的5种使用方式，及各自优缺点对比分析"></p>
<p><img src="/../../images/797018f905474ef2bad4e086848b1695.jpeg" alt="Redis集群的5种使用方式，及各自优缺点对比分析"></p>
<p><strong>优点：</strong></p>
<p>Redis Sentinel 集群部署简单;</p>
<p>能够解决 Redis 主从模式下的高可用切换问题;</p>
<p>很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求;</p>
<p>可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。</p>
<p><strong>缺点：</strong></p>
<p>部署相对 Redis 主从模式要复杂一些，原理理解更繁琐;</p>
<p>资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供服务;</p>
<p>Redis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。</p>
<p>不能解决读写分离问题，实现起来相对复杂。</p>
<p><strong>建议：</strong></p>
<p>如果监控同一业务，可以选择一套 Sentinel 集群监控多组 Redis 数据节点的方案，反之选择一套 Sentinel 监控一组 Redis 数据节点的方案。</p>
<p>sentinel monitor配置中的建议设置成 Sentinel 节点的一半加 1，当 Sentinel 部署在多个 IDC 的时候，单个 IDC 部署的 Sentinel 数量不建议超过(Sentinel 数量 – quorum)。</p>
<p>合理设置参数，防止误切，控制切换灵敏度控制：</p>
<p>a. quorum</p>
<p>b. down-after-milliseconds 30000</p>
<p>c. failover-timeout 180000</p>
<p>d. maxclient</p>
<p>e. timeout</p>
<p>部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱。</p>
<p>Redis 建议使用 pipeline 和 multi-keys 操作，减少 RTT 次数，提高请求效率。</p>
<p>自行搞定配置中心(zookeeper)，方便客户端对实例的链接访问。</p>
<p><strong>4、Redis Cluster</strong></p>
<p>Redis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。</p>
<p>Redis Cluster 集群节点最小配置 6 个节点以上(3 主 3 从)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p>
<p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p>
<p><img src="/../../images/990dc2eb3b1747c2805bab1daa1cba95.jpeg" alt="Redis集群的5种使用方式，及各自优缺点对比分析"></p>
<p><strong>优点：</strong></p>
<p>无中心架构;</p>
<p>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布;</p>
<p>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除;</p>
<p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升;</p>
<p>降低运维成本，提高系统的扩展性和可用性。</p>
<p><strong>缺点：</strong></p>
<p>Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p>
<p>节点会因为某些原因发生阻塞(阻塞时间大于 clutser-node-timeout)，被判断下线，这种 failover 是没有必要的。</p>
<p>数据通过异步复制，不保证数据的强一致性。</p>
<p>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p>
<p>Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。</p>
<p>Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。</p>
<p>Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。</p>
<p>Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。</p>
<p>不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</p>
<p>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p>
<p>避免产生 hot-key，导致主库节点成为系统的短板。</p>
<p>避免产生 big-key，导致网卡撑爆、慢查询等。</p>
<p>重试时间应该大于 cluster-node-time 时间。</p>
<p>Redis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。</p>
<p><strong>5、Redis 自研</strong></p>
<p>Redis 自研的高可用解决方案，主要体现在配置中心、故障探测和 failover 的处理机制上，通常需要根据企业业务的实际线上环境来定制化。</p>
<p><img src="/../../images/50ba483ccef444e6aca9723f1956b00b.jpeg" alt="Redis集群的5种使用方式，及各自优缺点对比分析"></p>
<p><img src="/../../images/f9b70a2e7afb4631aad48adaca70c03a.jpeg" alt="Redis集群的5种使用方式，及各自优缺点对比分析"></p>
<p><strong>优点：</strong></p>
<p>高可靠性、高可用性;</p>
<p>自主可控性高;</p>
<p>贴切业务实际需求，可缩性好，兼容性好。</p>
<p><strong>缺点：</strong></p>
<p>实现复杂，开发成本高;</p>
<p>需要建立配套的周边设施，如监控，域名服务，存储元数据信息的数据库等;</p>
<p>维护成本高。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-27T11:39:07.000Z" title="2021/5/27 下午7:39:07">2021-05-27</time>发表</span><span class="level-item"><time dateTime="2021-05-27T11:39:07.000Z" title="2021/5/27 下午7:39:07">2021-05-27</time>更新</span><span class="level-item">17 分钟读完 (大约2560个字)</span></div></div><div class="content"><h1 id="2-6-30-签到功能"><a href="#2-6-30-签到功能" class="headerlink" title="2.6.30 签到功能"></a>2.6.30 签到功能</h1><p>常见的场景如下：</p>
<ul>
<li>给一个 userId ，判断用户登陆状态；</li>
<li>显示用户某个月的签到次数和首次签到时间；</li>
<li>两亿用户最近 7 天的签到情况，统计 7 天内连续签到的用户总数；</li>
</ul>
<p>通常情况下，我们面临的用户数量以及访问量都是巨大的，比如百万、千万级别的用户数量，或者千万级别、甚至亿级别的访问信息。</p>
<p>所以，我们必须要选择能够非常高效地统计大量数据（例如亿级）的集合类型。</p>
<p><strong>如何选择合适的数据集合，我们首先要了解常用的统计模式，并运用合理的数据类型来解决实际问题。</strong></p>
<p>四种统计类型：</p>
<ol>
<li>二值状态统计；</li>
<li>聚合统计；</li>
<li>排序统计；</li>
<li>基数统计。</li>
</ol>
<p>本文将由<strong>二值状态统计类型</strong>作为实战篇系列的开篇，文中将用到 String、Set、Zset、List、hash 以外的拓展数据类型 Bitmap 来实现。</p>
<p>文章涉及到的指令可以通过在线 Redis 客户端运行调试，地址：<a target="_blank" rel="noopener" href="https://try.redis.io/%EF%BC%8C%E8%B6%85%E6%96%B9%E4%BE%BF%E7%9A%84%E8%AF%B4%E3%80%82">https://try.redis.io/，超方便的说。</a></p>
<h1 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h1><blockquote>
<p>❝</p>
<p>多分享多付出，前期多给别人创造价值并且不计回报，从长远来看，这些付出都会成倍的回报你。</p>
<p>特别是刚开始跟别人合作的时候，不要去计较短期的回报，没有太大意义，更多的是锻炼自己的视野、视角以及解决问题的能力。</p>
</blockquote>
<h1 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h1><blockquote>
<p>❝</p>
<p>码哥，什么是二值状态统计呀？</p>
</blockquote>
<p>也就是集合中的元素的值只有 0 和 1 两种，在签到打卡和用户是否登陆的场景中，只需记录签到(1)或 未签到(0)，已登录(1)或未登陆(0)。</p>
<p>假如我们在判断用户是否登陆的场景中使用 Redis 的 String 类型实现（<strong>key -&gt; userId，value -&gt; 0 表示下线，1 - 登陆</strong>），假如存储 100 万个用户的登陆状态，如果以字符串的形式存储，就需要存储 100 万个字符串了，内存开销太大。</p>
<blockquote>
<p>❝</p>
<p>码哥，为什么 String 类型内存开销大？</p>
</blockquote>
<p>String 类型除了记录实际数据以外，还需要额外的内存记录数据长度、空间使用等信息。</p>
<p>当保存的数据包含字符串，String 类型就使用简单动态字符串（SDS）结构体来保存，如下图所示：</p>
<p><img src="/../../images/1389f0f4d72e4575a9e4aacdc4720f64.png" alt="Redis 实战篇：巧用 Bitmap 实现亿级海量数据统计"></p>
<p>SDS</p>
<ul>
<li><strong>len</strong>：占 4 个字节，表示 buf 的已用长度。</li>
<li><strong>alloc</strong>：占 4 个字节，表示 buf 实际分配的长度，通常 &gt; len。</li>
<li><strong>buf</strong>：字节数组，保存实际的数据，Redis 自动在数组最后加上一个 “\0”，额外占用一个字节的开销。</li>
</ul>
<p>所以，在 SDS 中除了 buf 保存实际的数据， len 与 alloc 就是额外的开销。</p>
<p>另外，还有一个 <strong>RedisObject 结构的开销</strong>，因为 Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等）。</p>
<p>所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。</p>
<p><img src="/../../images/bad86e4a31e145caa9f5c891a8ad3141.jpeg" alt="Redis 实战篇：巧用 Bitmap 实现亿级海量数据统计"></p>
<p>对于二值状态场景，我们就可以利用 Bitmap 来实现。比如登陆状态我们用一个 bit 位表示，一亿个用户也只占用 一亿 个 bit 位内存 ≈ （100000000 &#x2F; 8&#x2F; 1024&#x2F;1024）12 MB。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大概的空间占用计算公式是：($offset/8/1024/1024) MB</span><br></pre></td></tr></table></figure>

<blockquote>
<p>❝</p>
<p>什么是 Bitmap 呢？</p>
</blockquote>
<p>Bitmap 的底层数据结构用的是 String 类型的 SDS 数据结构来保存位数组，Redis 把每个字节数组的 8 个 bit 位利用起来，每个 bit 位 表示一个元素的二值状态（不是 0 就是 1）。</p>
<p>可以将 Bitmap 看成是一个 bit 为单位的数组，数组的每个单元只能存储 0 或者 1，数组的下标在 Bitmap 中叫做 offset 偏移量。</p>
<p>为了直观展示，我们可以理解成 buf 数组的每个字节用一行表示，每一行有 8 个 bit 位，8 个格子分别表示这个字节中的 8 个 bit 位，如下图所示：</p>
<p><img src="/../../images/df9a85c4301b46c28e3cc5eda4fe4cec.png" alt="Redis 实战篇：巧用 Bitmap 实现亿级海量数据统计"></p>
<p>Bitmap</p>
<p><strong>8 个 bit 组成一个 Byte，所以 Bitmap 会极大地节省存储空间。</strong> 这就是 Bitmap 的优势。</p>
<h1 id="判断用户登陆态"><a href="#判断用户登陆态" class="headerlink" title="判断用户登陆态"></a>判断用户登陆态</h1><blockquote>
<p>❝</p>
<p>怎么用 Bitmap 来判断海量用户中某个用户是否在线呢？</p>
</blockquote>
<p>Bitmap 提供了 GETBIT、SETBIT 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p>
<p>只需要一个 key &#x3D; login_status 表示存储用户登陆状态集合数据， 将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 GETBIT判断对应的用户是否在线。50000 万 用户只需要 6 MB 的空间。</p>
<p><strong>SETBIT 命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT &lt;key&gt; &lt;offset&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<p>设置或者清空 key 的 value 在 offset 处的 bit 值（只能是 0 或者 1）。</p>
<p><strong>GETBIT 命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT &lt;key&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure>

<p>获取 key 的 value 在 offset 处的 bit 位的值，当 key 不存在时，返回 0。</p>
<p>假如我们要判断 ID &#x3D; 10086 的用户的登陆情况：</p>
<p>第一步，执行以下指令，表示用户已登录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 10086 1</span><br></pre></td></tr></table></figure>

<p>第二步，检查该用户是否登陆，返回值 1 表示已登录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT login_status 10086</span><br></pre></td></tr></table></figure>

<p>第三步，登出，将 offset 对应的 value 设置成 0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 10086 0</span><br></pre></td></tr></table></figure>

<h1 id="用户每个月的签到情况"><a href="#用户每个月的签到情况" class="headerlink" title="用户每个月的签到情况"></a>用户每个月的签到情况</h1><p>在签到统计中，每个用户每天的签到用 1 个 bit 位表示，一年的签到只需要 365 个 bit 位。一个月最多只有 31 天，只需要 31 个 bit 位即可。</p>
<blockquote>
<p>❝</p>
<p>比如统计编号 89757 的用户在 2021 年 5 月份的打卡情况要如何进行？</p>
</blockquote>
<p>key 可以设计成 uid:sign:{userId}:{yyyyMM}，月份的每一天的值 - 1 可以作为 offset（因为 offset 从 0 开始，所以 offset &#x3D; 日期 - 1）。</p>
<p>第一步，执行下面指令表示记录用户在 2021 年 5 月 16 号打卡。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT uid:sign:89757:202105 15 1</span><br></pre></td></tr></table></figure>

<p>第二步，判断编号 89757 用户在 2021 年 5 月 16 号是否打卡。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT uid:sign:89757:202105 15</span><br></pre></td></tr></table></figure>

<p>第三步，统计该用户在 5 月份的打卡次数，使用 BITCOUNT 指令。该指令用于统计给定的 bit 数组中，值 &#x3D; 1 的 bit 位的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT uid:sign:89757:202105</span><br></pre></td></tr></table></figure>

<p>这样我们就可以实现用户每个月的打卡情况了，是不是很赞。</p>
<blockquote>
<p>❝</p>
<p>如何统计这个月首次打卡时间呢？</p>
</blockquote>
<p>Redis 提供了 BITPOS key bitValue [start] [end]指令，返回数据表示 Bitmap 中第一个值为 bitValue 的 offset 位置。</p>
<p>在默认情况下， 命令将检测整个位图， 用户可以通过可选的 start 参数和 end 参数指定要检测的范围。</p>
<p>所以我们可以通过执行以下指令来获取 userID &#x3D; 89757 在 2021 年 5 月份<strong>首次打卡</strong>日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITPOS uid:sign:89757:202105 1</span><br></pre></td></tr></table></figure>

<p>需要注意的是，我们需要将返回的 value + 1 ，因为 offset 从 0 开始。</p>
<h1 id="连续签到用户总数"><a href="#连续签到用户总数" class="headerlink" title="连续签到用户总数"></a>连续签到用户总数</h1><blockquote>
<p>❝</p>
<p>在记录了一个亿的用户连续 7 天的打卡数据，如何统计出这连续 7 天连续打卡用户总数呢？</p>
</blockquote>
<p>我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。</p>
<p>key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。</p>
<p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。</p>
<p>同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit &#x3D; 1 就说明该用户 7 天连续打卡。</p>
<p>结果保存到一个新 Bitmap 中，我们再通过 BITCOUNT 统计 bit &#x3D; 1 的个数便得到了连续打卡 7 天的用户总数了。</p>
<p>Redis 提供了 BITOP operation destkey key [key …]这个指令用于对一个或者多个 键 &#x3D; key 的 Bitmap 进行位元操作。</p>
<p>opration 可以是 and、OR、NOT、XOR。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。</p>
<p>便于理解，如下图所示：</p>
<p><img src="/../../images/13b56db85d50458caf2cd87e21a87949.png" alt="Redis 实战篇：巧用 Bitmap 实现亿级海量数据统计"></p>
<p>BITOP</p>
<p>3 个 Bitmap，对应的 bit 位做「与」操作，结果保存到新的 Bitmap 中。</p>
<p>操作指令表示将 三个 bitmap 进行 AND 操作，并将结果保存到 destmap 中。接着对 destmap 执行 BITCOUNT 统计。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 与操作</span><br><span class="line">BITOP AND destmap bitmap:01 bitmap:02 bitmap:03</span><br><span class="line">// 统计 bit 位 =  1 的个数</span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure>

<p>简单计算下 一个一亿个位的 Bitmap占用的内存开销，大约占 12 MB 的内存（10^8&#x2F;8&#x2F;1024&#x2F;1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>思路才是最重要，当我们遇到的统计场景只需要统计数据的二值状态，比如用户是否存在、 ip 是否是黑名单、以及签到打卡统计等场景就可以考虑使用 Bitmap。</p>
<p>只需要一个 bit 位就能表示 0 和 1。在统计海量数据的时候将大大减少内存占用。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/10/">上一页</a></div><div class="pagination-next"><a href="/page/12/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/10/">10</a></li><li><a class="pagination-link is-current" href="/page/11/">11</a></li><li><a class="pagination-link" href="/page/12/">12</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/16/">16</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Tonygeli"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tonygeli</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>SH</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">154</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">26</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tonygeli" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux%E5%91%BD%E4%BB%A4/"><span class="level-start"><span class="level-item">Linux命令</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">时间管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%93%E5%AD%98/"><span class="level-start"><span class="level-item">缓存</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6/"><span class="level-start"><span class="level-item">读书</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bean/"><span class="tag">Bean</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus/"><span class="tag">Icarus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySql/"><span class="tag">MySql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Netty/"><span class="tag">Netty</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stream/"><span class="tag">Stream</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8B%E5%8A%A1/"><span class="tag">事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"><span class="tag">公众号</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><span class="tag">内存分配</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><span class="tag">分布式事务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"><span class="tag">分布式缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"><span class="tag">单点登录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A0%86%E7%BC%93%E5%AD%98/"><span class="tag">堆缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%95%E7%94%A8/"><span class="tag">引用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"><span class="tag">自动装配</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%99%90%E6%B5%81/"><span class="tag">限流</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-14T09:31:46.339Z">2022-05-14</time></p><p class="title"><a href="/2022/05/14/article-17/">130个免费 微信小程序源码分享</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-14T07:58:07.688Z">2022-05-14</time></p><p class="title"><a href="/2022/05/14/14000JAVA/14002JAVA%E5%9B%9B%E7%A7%8D%E7%BC%93%E5%AD%98/">JAVA四种缓存</a></p><p class="categories"><a href="/categories/%E7%BC%93%E5%AD%98/">缓存</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-13T03:44:34.257Z">2022-05-13</time></p><p class="title"><a href="/2022/05/13/12000%E9%9D%A2%E8%AF%95/12005Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%886%E7%A7%8D%E5%9C%BA%E6%99%AF/">Spring事务失效6种场景</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-13T03:43:11.151Z">2022-05-13</time></p><p class="title"><a href="/2022/05/13/12000%E9%9D%A2%E8%AF%95/12004Java%E7%9A%84%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/">Java的引用问题</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-12T06:50:12.571Z">2022-05-12</time></p><p class="title"><a href="/2022/05/12/12000%E9%9D%A2%E8%AF%95/12003ThreadLocal%E6%BA%90%E7%A0%81/">ThreadLocal源码介绍</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="LILAIQUN" height="28"></a><p class="is-size-7"><span>&copy; 2022 Tonygeli</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>